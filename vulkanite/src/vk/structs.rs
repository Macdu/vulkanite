use crate::vk::raw::*;
use crate::vk::*;
use crate::*;
use std::array;
use std::ffi::{c_char, c_int, c_ulong, c_void};
use std::marker::PhantomData;
use std::mem::ManuallyDrop;
use std::ptr;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceAddress.html>"]
#[doc(alias = "VkDeviceAddress")]
pub type DeviceAddress = u64;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceSize.html>"]
#[doc(alias = "VkDeviceSize")]
pub type DeviceSize = u64;
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent2D.html>"]
#[doc(alias = "VkExtent2D")]
pub struct Extent2D {
    pub width: u32,
    pub height: u32,
}
unsafe impl Send for Extent2D {}
unsafe impl Sync for Extent2D {}
impl Default for Extent2D {
    fn default() -> Self {
        Self {
            width: Default::default(),
            height: Default::default(),
        }
    }
}
impl Extent2D {
    #[inline]
    pub fn width(mut self, value: u32) -> Self {
        self.width = value;
        self
    }
    #[inline]
    pub fn height(mut self, value: u32) -> Self {
        self.height = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent3D.html>"]
#[doc(alias = "VkExtent3D")]
pub struct Extent3D {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
unsafe impl Send for Extent3D {}
unsafe impl Sync for Extent3D {}
impl Default for Extent3D {
    fn default() -> Self {
        Self {
            width: Default::default(),
            height: Default::default(),
            depth: Default::default(),
        }
    }
}
impl Extent3D {
    #[inline]
    pub fn width(mut self, value: u32) -> Self {
        self.width = value;
        self
    }
    #[inline]
    pub fn height(mut self, value: u32) -> Self {
        self.height = value;
        self
    }
    #[inline]
    pub fn depth(mut self, value: u32) -> Self {
        self.depth = value;
        self
    }
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFlags.html>"]
#[doc(alias = "VkFlags")]
pub type Flags = u32;
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOffset2D.html>"]
#[doc(alias = "VkOffset2D")]
pub struct Offset2D {
    pub x: i32,
    pub y: i32,
}
unsafe impl Send for Offset2D {}
unsafe impl Sync for Offset2D {}
impl Default for Offset2D {
    fn default() -> Self {
        Self {
            x: Default::default(),
            y: Default::default(),
        }
    }
}
impl Offset2D {
    #[inline]
    pub fn x(mut self, value: i32) -> Self {
        self.x = value;
        self
    }
    #[inline]
    pub fn y(mut self, value: i32) -> Self {
        self.y = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOffset3D.html>"]
#[doc(alias = "VkOffset3D")]
pub struct Offset3D {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
unsafe impl Send for Offset3D {}
unsafe impl Sync for Offset3D {}
impl Default for Offset3D {
    fn default() -> Self {
        Self {
            x: Default::default(),
            y: Default::default(),
            z: Default::default(),
        }
    }
}
impl Offset3D {
    #[inline]
    pub fn x(mut self, value: i32) -> Self {
        self.x = value;
        self
    }
    #[inline]
    pub fn y(mut self, value: i32) -> Self {
        self.y = value;
        self
    }
    #[inline]
    pub fn z(mut self, value: i32) -> Self {
        self.z = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRect2D.html>"]
#[doc(alias = "VkRect2D")]
pub struct Rect2D {
    pub offset: Offset2D,
    pub extent: Extent2D,
}
unsafe impl Send for Rect2D {}
unsafe impl Sync for Rect2D {}
impl Default for Rect2D {
    fn default() -> Self {
        Self {
            offset: Default::default(),
            extent: Default::default(),
        }
    }
}
impl Rect2D {
    #[inline]
    pub fn offset(mut self, value: Offset2D) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn extent(mut self, value: Extent2D) -> Self {
        self.extent = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBaseInStructure.html>"]
#[doc(alias = "VkBaseInStructure")]
pub struct BaseInStructure<'a> {
    pub s_type: StructureType,
    pub p_next: *const BaseInStructure<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for BaseInStructure<'a> {}
unsafe impl<'a> Sync for BaseInStructure<'a> {}
impl<'a> Default for BaseInStructure<'a> {
    fn default() -> Self {
        Self {
            s_type: StructureType::ApplicationInfo,
            p_next: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BaseInStructure<'a> {
    #[inline]
    pub fn s_type(mut self, value: StructureType) -> Self {
        self.s_type = value;
        self
    }
    #[inline]
    pub fn next(mut self, value: Option<&'a BaseInStructure<'a>>) -> Self {
        self.p_next = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBaseOutStructure.html>"]
#[doc(alias = "VkBaseOutStructure")]
pub struct BaseOutStructure<'a> {
    pub s_type: StructureType,
    pub p_next: *const BaseOutStructure<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for BaseOutStructure<'a> {}
unsafe impl<'a> Sync for BaseOutStructure<'a> {}
impl<'a> Default for BaseOutStructure<'a> {
    fn default() -> Self {
        Self {
            s_type: StructureType::ApplicationInfo,
            p_next: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BaseOutStructure<'a> {
    #[inline]
    pub fn s_type(mut self, value: StructureType) -> Self {
        self.s_type = value;
        self
    }
    #[inline]
    pub fn next(mut self, value: Option<&'a BaseOutStructure<'a>>) -> Self {
        self.p_next = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier.html>"]
#[doc(alias = "VkBufferMemoryBarrier")]
pub struct BufferMemoryBarrier<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
    pub size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferMemoryBarrier<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferMemoryBarrier;
}
unsafe impl<'a> Send for BufferMemoryBarrier<'a> {}
unsafe impl<'a> Sync for BufferMemoryBarrier<'a> {}
impl<'a> Default for BufferMemoryBarrier<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
            src_queue_family_index: Default::default(),
            dst_queue_family_index: Default::default(),
            buffer: Default::default(),
            offset: Default::default(),
            size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferMemoryBarrier<'a> {
    #[inline]
    pub fn src_access_mask(mut self, value: AccessFlags) -> Self {
        self.src_access_mask = value;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, value: AccessFlags) -> Self {
        self.dst_access_mask = value;
        self
    }
    #[inline]
    pub fn src_queue_family_index(mut self, value: u32) -> Self {
        self.src_queue_family_index = value;
        self
    }
    #[inline]
    pub fn dst_queue_family_index(mut self, value: u32) -> Self {
        self.dst_queue_family_index = value;
        self
    }
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn offset(mut self, value: DeviceSize) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDispatchIndirectCommand.html>"]
#[doc(alias = "VkDispatchIndirectCommand")]
pub struct DispatchIndirectCommand {
    pub x: u32,
    pub y: u32,
    pub z: u32,
}
unsafe impl Send for DispatchIndirectCommand {}
unsafe impl Sync for DispatchIndirectCommand {}
impl Default for DispatchIndirectCommand {
    fn default() -> Self {
        Self {
            x: Default::default(),
            y: Default::default(),
            z: Default::default(),
        }
    }
}
impl DispatchIndirectCommand {
    #[inline]
    pub fn x(mut self, value: u32) -> Self {
        self.x = value;
        self
    }
    #[inline]
    pub fn y(mut self, value: u32) -> Self {
        self.y = value;
        self
    }
    #[inline]
    pub fn z(mut self, value: u32) -> Self {
        self.z = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawIndexedIndirectCommand.html>"]
#[doc(alias = "VkDrawIndexedIndirectCommand")]
pub struct DrawIndexedIndirectCommand {
    pub index_count: u32,
    pub instance_count: u32,
    pub first_index: u32,
    pub vertex_offset: i32,
    pub first_instance: u32,
}
unsafe impl Send for DrawIndexedIndirectCommand {}
unsafe impl Sync for DrawIndexedIndirectCommand {}
impl Default for DrawIndexedIndirectCommand {
    fn default() -> Self {
        Self {
            index_count: Default::default(),
            instance_count: Default::default(),
            first_index: Default::default(),
            vertex_offset: Default::default(),
            first_instance: Default::default(),
        }
    }
}
impl DrawIndexedIndirectCommand {
    #[inline]
    pub fn index_count(mut self, value: u32) -> Self {
        self.index_count = value;
        self
    }
    #[inline]
    pub fn instance_count(mut self, value: u32) -> Self {
        self.instance_count = value;
        self
    }
    #[inline]
    pub fn first_index(mut self, value: u32) -> Self {
        self.first_index = value;
        self
    }
    #[inline]
    pub fn vertex_offset(mut self, value: i32) -> Self {
        self.vertex_offset = value;
        self
    }
    #[inline]
    pub fn first_instance(mut self, value: u32) -> Self {
        self.first_instance = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawIndirectCommand.html>"]
#[doc(alias = "VkDrawIndirectCommand")]
pub struct DrawIndirectCommand {
    pub vertex_count: u32,
    pub instance_count: u32,
    pub first_vertex: u32,
    pub first_instance: u32,
}
unsafe impl Send for DrawIndirectCommand {}
unsafe impl Sync for DrawIndirectCommand {}
impl Default for DrawIndirectCommand {
    fn default() -> Self {
        Self {
            vertex_count: Default::default(),
            instance_count: Default::default(),
            first_vertex: Default::default(),
            first_instance: Default::default(),
        }
    }
}
impl DrawIndirectCommand {
    #[inline]
    pub fn vertex_count(mut self, value: u32) -> Self {
        self.vertex_count = value;
        self
    }
    #[inline]
    pub fn instance_count(mut self, value: u32) -> Self {
        self.instance_count = value;
        self
    }
    #[inline]
    pub fn first_vertex(mut self, value: u32) -> Self {
        self.first_vertex = value;
        self
    }
    #[inline]
    pub fn first_instance(mut self, value: u32) -> Self {
        self.first_instance = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier.html>"]
#[doc(alias = "VkImageMemoryBarrier")]
pub struct ImageMemoryBarrier<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub old_layout: ImageLayout,
    pub new_layout: ImageLayout,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub image: Option<Image>,
    pub subresource_range: ImageSubresourceRange,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageMemoryBarrier<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageMemoryBarrier;
}
unsafe impl<'a> Send for ImageMemoryBarrier<'a> {}
unsafe impl<'a> Sync for ImageMemoryBarrier<'a> {}
impl<'a> Default for ImageMemoryBarrier<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
            old_layout: ImageLayout::Undefined,
            new_layout: ImageLayout::Undefined,
            src_queue_family_index: Default::default(),
            dst_queue_family_index: Default::default(),
            image: Default::default(),
            subresource_range: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageMemoryBarrier<'a> {
    #[inline]
    pub fn src_access_mask(mut self, value: AccessFlags) -> Self {
        self.src_access_mask = value;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, value: AccessFlags) -> Self {
        self.dst_access_mask = value;
        self
    }
    #[inline]
    pub fn old_layout(mut self, value: ImageLayout) -> Self {
        self.old_layout = value;
        self
    }
    #[inline]
    pub fn new_layout(mut self, value: ImageLayout) -> Self {
        self.new_layout = value;
        self
    }
    #[inline]
    pub fn src_queue_family_index(mut self, value: u32) -> Self {
        self.src_queue_family_index = value;
        self
    }
    #[inline]
    pub fn dst_queue_family_index(mut self, value: u32) -> Self {
        self.dst_queue_family_index = value;
        self
    }
    #[inline]
    pub fn image(mut self, value: &'a Image) -> Self {
        self.image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn subresource_range(mut self, value: ImageSubresourceRange) -> Self {
        self.subresource_range = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier.html>"]
#[doc(alias = "VkMemoryBarrier")]
pub struct MemoryBarrier<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryBarrier<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryBarrier;
}
unsafe impl<'a> Send for MemoryBarrier<'a> {}
unsafe impl<'a> Sync for MemoryBarrier<'a> {}
impl<'a> Default for MemoryBarrier<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryBarrier<'a> {
    #[inline]
    pub fn src_access_mask(mut self, value: AccessFlags) -> Self {
        self.src_access_mask = value;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, value: AccessFlags) -> Self {
        self.dst_access_mask = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheHeaderVersionOne.html>"]
#[doc(alias = "VkPipelineCacheHeaderVersionOne")]
pub struct PipelineCacheHeaderVersionOne {
    pub header_size: u32,
    pub header_version: PipelineCacheHeaderVersion,
    pub vendor_id: u32,
    pub device_id: u32,
    pub pipeline_cache_uuid: [u8; UUID_SIZE as _],
}
unsafe impl Send for PipelineCacheHeaderVersionOne {}
unsafe impl Sync for PipelineCacheHeaderVersionOne {}
impl Default for PipelineCacheHeaderVersionOne {
    fn default() -> Self {
        Self {
            header_size: Default::default(),
            header_version: PipelineCacheHeaderVersion::One,
            vendor_id: Default::default(),
            device_id: Default::default(),
            pipeline_cache_uuid: array::from_fn(|_| Default::default()),
        }
    }
}
impl PipelineCacheHeaderVersionOne {
    #[inline]
    pub fn header_size(mut self, value: u32) -> Self {
        self.header_size = value;
        self
    }
    #[inline]
    pub fn header_version(mut self, value: PipelineCacheHeaderVersion) -> Self {
        self.header_version = value;
        self
    }
    #[inline]
    pub fn vendor_id(mut self, value: u32) -> Self {
        self.vendor_id = value;
        self
    }
    #[inline]
    pub fn device_id(mut self, value: u32) -> Self {
        self.device_id = value;
        self
    }
    #[inline]
    pub fn pipeline_cache_uuid(mut self, value: [u8; UUID_SIZE as _]) -> Self {
        self.pipeline_cache_uuid = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAllocationCallbacks.html>"]
#[doc(alias = "VkAllocationCallbacks")]
pub struct AllocationCallbacks {
    pub p_user_data: VoidPtr,
    pub pfn_allocation: FuncPtr,
    pub pfn_reallocation: FuncPtr,
    pub pfn_free: FuncPtr,
    pub pfn_internal_allocation: FuncPtr,
    pub pfn_internal_free: FuncPtr,
}
unsafe impl Send for AllocationCallbacks {}
unsafe impl Sync for AllocationCallbacks {}
impl Default for AllocationCallbacks {
    fn default() -> Self {
        Self {
            p_user_data: ptr::null(),
            pfn_allocation: ptr::null(),
            pfn_reallocation: ptr::null(),
            pfn_free: ptr::null(),
            pfn_internal_allocation: ptr::null(),
            pfn_internal_free: ptr::null(),
        }
    }
}
impl AllocationCallbacks {
    #[inline]
    pub fn user_data(mut self, value: VoidPtr) -> Self {
        self.p_user_data = value;
        self
    }
    #[inline]
    pub fn pfn_allocation(mut self, value: FuncPtr) -> Self {
        self.pfn_allocation = value;
        self
    }
    #[inline]
    pub fn pfn_reallocation(mut self, value: FuncPtr) -> Self {
        self.pfn_reallocation = value;
        self
    }
    #[inline]
    pub fn pfn_free(mut self, value: FuncPtr) -> Self {
        self.pfn_free = value;
        self
    }
    #[inline]
    pub fn pfn_internal_allocation(mut self, value: FuncPtr) -> Self {
        self.pfn_internal_allocation = value;
        self
    }
    #[inline]
    pub fn pfn_internal_free(mut self, value: FuncPtr) -> Self {
        self.pfn_internal_free = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkApplicationInfo.html>"]
#[doc(alias = "VkApplicationInfo")]
pub struct ApplicationInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_application_name: *const c_char,
    pub application_version: u32,
    pub p_engine_name: *const c_char,
    pub engine_version: u32,
    pub api_version: ApiVersion,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ApplicationInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ApplicationInfo;
}
unsafe impl<'a> Send for ApplicationInfo<'a> {}
unsafe impl<'a> Sync for ApplicationInfo<'a> {}
impl<'a> Default for ApplicationInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_application_name: ptr::null(),
            application_version: Default::default(),
            p_engine_name: ptr::null(),
            engine_version: Default::default(),
            api_version: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ApplicationInfo<'a> {
    #[inline]
    pub fn application_name(mut self, value: Option<&'a CStr>) -> Self {
        self.p_application_name = value.map(|v| v.as_ptr()).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn application_version(mut self, value: u32) -> Self {
        self.application_version = value;
        self
    }
    #[inline]
    pub fn engine_name(mut self, value: Option<&'a CStr>) -> Self {
        self.p_engine_name = value.map(|v| v.as_ptr()).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn engine_version(mut self, value: u32) -> Self {
        self.engine_version = value;
        self
    }
    #[inline]
    pub fn api_version(mut self, value: ApiVersion) -> Self {
        self.api_version = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties.html>"]
#[doc(alias = "VkFormatProperties")]
pub struct FormatProperties {
    pub linear_tiling_features: FormatFeatureFlags,
    pub optimal_tiling_features: FormatFeatureFlags,
    pub buffer_features: FormatFeatureFlags,
}
unsafe impl Send for FormatProperties {}
unsafe impl Sync for FormatProperties {}
impl Default for FormatProperties {
    fn default() -> Self {
        Self {
            linear_tiling_features: Default::default(),
            optimal_tiling_features: Default::default(),
            buffer_features: Default::default(),
        }
    }
}
impl FormatProperties {
    #[inline]
    pub fn linear_tiling_features(mut self, value: FormatFeatureFlags) -> Self {
        self.linear_tiling_features = value;
        self
    }
    #[inline]
    pub fn optimal_tiling_features(mut self, value: FormatFeatureFlags) -> Self {
        self.optimal_tiling_features = value;
        self
    }
    #[inline]
    pub fn buffer_features(mut self, value: FormatFeatureFlags) -> Self {
        self.buffer_features = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatProperties.html>"]
#[doc(alias = "VkImageFormatProperties")]
pub struct ImageFormatProperties {
    pub max_extent: Extent3D,
    pub max_mip_levels: u32,
    pub max_array_layers: u32,
    pub sample_counts: SampleCountFlags,
    pub max_resource_size: DeviceSize,
}
unsafe impl Send for ImageFormatProperties {}
unsafe impl Sync for ImageFormatProperties {}
impl Default for ImageFormatProperties {
    fn default() -> Self {
        Self {
            max_extent: Default::default(),
            max_mip_levels: Default::default(),
            max_array_layers: Default::default(),
            sample_counts: Default::default(),
            max_resource_size: Default::default(),
        }
    }
}
impl ImageFormatProperties {
    #[inline]
    pub fn max_extent(mut self, value: Extent3D) -> Self {
        self.max_extent = value;
        self
    }
    #[inline]
    pub fn max_mip_levels(mut self, value: u32) -> Self {
        self.max_mip_levels = value;
        self
    }
    #[inline]
    pub fn max_array_layers(mut self, value: u32) -> Self {
        self.max_array_layers = value;
        self
    }
    #[inline]
    pub fn sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.sample_counts = value;
        self
    }
    #[inline]
    pub fn max_resource_size(mut self, value: DeviceSize) -> Self {
        self.max_resource_size = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html>"]
#[doc(alias = "VkInstanceCreateInfo")]
pub struct InstanceCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: InstanceCreateFlags,
    pub p_application_info: *const ApplicationInfo<'a>,
    pub(crate) enabled_layer_count: u32,
    pub(crate) pp_enabled_layer_names: *const *const c_char,
    pub(crate) enabled_extension_count: u32,
    pub(crate) pp_enabled_extension_names: *const InstanceExtensionName,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for InstanceCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::InstanceCreateInfo;
}
unsafe impl<'a> Send for InstanceCreateInfo<'a> {}
unsafe impl<'a> Sync for InstanceCreateInfo<'a> {}
impl<'a> Default for InstanceCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            p_application_info: ptr::null(),
            enabled_layer_count: Default::default(),
            pp_enabled_layer_names: ptr::null(),
            enabled_extension_count: Default::default(),
            pp_enabled_extension_names: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> InstanceCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: InstanceCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn application_info(mut self, value: Option<&'a ApplicationInfo<'a>>) -> Self {
        self.p_application_info = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn enabled_layer(
        mut self,
        pp_enabled_layer_names: impl AsSlice<'a, *const c_char>,
    ) -> Self {
        self.pp_enabled_layer_names = pp_enabled_layer_names.as_slice().as_ptr().cast();
        self.enabled_layer_count = pp_enabled_layer_names.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn enabled_extension(
        mut self,
        pp_enabled_extension_names: impl AsSlice<'a, InstanceExtensionName>,
    ) -> Self {
        self.pp_enabled_extension_names = pp_enabled_extension_names.as_slice().as_ptr().cast();
        self.enabled_extension_count = pp_enabled_extension_names.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHeap.html>"]
#[doc(alias = "VkMemoryHeap")]
pub struct MemoryHeap {
    pub size: DeviceSize,
    pub flags: MemoryHeapFlags,
}
unsafe impl Send for MemoryHeap {}
unsafe impl Sync for MemoryHeap {}
impl Default for MemoryHeap {
    fn default() -> Self {
        Self {
            size: Default::default(),
            flags: Default::default(),
        }
    }
}
impl MemoryHeap {
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: MemoryHeapFlags) -> Self {
        self.flags = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryType.html>"]
#[doc(alias = "VkMemoryType")]
pub struct MemoryType {
    pub property_flags: MemoryPropertyFlags,
    pub heap_index: u32,
}
unsafe impl Send for MemoryType {}
unsafe impl Sync for MemoryType {}
impl Default for MemoryType {
    fn default() -> Self {
        Self {
            property_flags: Default::default(),
            heap_index: Default::default(),
        }
    }
}
impl MemoryType {
    #[inline]
    pub fn property_flags(mut self, value: MemoryPropertyFlags) -> Self {
        self.property_flags = value;
        self
    }
    #[inline]
    pub fn heap_index(mut self, value: u32) -> Self {
        self.heap_index = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceFeatures")]
pub struct PhysicalDeviceFeatures {
    pub robust_buffer_access: Bool32,
    pub full_draw_index_uint32: Bool32,
    pub image_cube_array: Bool32,
    pub independent_blend: Bool32,
    pub geometry_shader: Bool32,
    pub tessellation_shader: Bool32,
    pub sample_rate_shading: Bool32,
    pub dual_src_blend: Bool32,
    pub logic_op: Bool32,
    pub multi_draw_indirect: Bool32,
    pub draw_indirect_first_instance: Bool32,
    pub depth_clamp: Bool32,
    pub depth_bias_clamp: Bool32,
    pub fill_mode_non_solid: Bool32,
    pub depth_bounds: Bool32,
    pub wide_lines: Bool32,
    pub large_points: Bool32,
    pub alpha_to_one: Bool32,
    pub multi_viewport: Bool32,
    pub sampler_anisotropy: Bool32,
    pub texture_compression_etc2: Bool32,
    pub texture_compression_astc_ldr: Bool32,
    pub texture_compression_bc: Bool32,
    pub occlusion_query_precise: Bool32,
    pub pipeline_statistics_query: Bool32,
    pub vertex_pipeline_stores_and_atomics: Bool32,
    pub fragment_stores_and_atomics: Bool32,
    pub shader_tessellation_and_geometry_point_size: Bool32,
    pub shader_image_gather_extended: Bool32,
    pub shader_storage_image_extended_formats: Bool32,
    pub shader_storage_image_multisample: Bool32,
    pub shader_storage_image_read_without_format: Bool32,
    pub shader_storage_image_write_without_format: Bool32,
    pub shader_uniform_buffer_array_dynamic_indexing: Bool32,
    pub shader_sampled_image_array_dynamic_indexing: Bool32,
    pub shader_storage_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_image_array_dynamic_indexing: Bool32,
    pub shader_clip_distance: Bool32,
    pub shader_cull_distance: Bool32,
    pub shader_float64: Bool32,
    pub shader_int64: Bool32,
    pub shader_int16: Bool32,
    pub shader_resource_residency: Bool32,
    pub shader_resource_min_lod: Bool32,
    pub sparse_binding: Bool32,
    pub sparse_residency_buffer: Bool32,
    pub sparse_residency_image2_d: Bool32,
    pub sparse_residency_image3_d: Bool32,
    pub sparse_residency2_samples: Bool32,
    pub sparse_residency4_samples: Bool32,
    pub sparse_residency8_samples: Bool32,
    pub sparse_residency16_samples: Bool32,
    pub sparse_residency_aliased: Bool32,
    pub variable_multisample_rate: Bool32,
    pub inherited_queries: Bool32,
}
unsafe impl Send for PhysicalDeviceFeatures {}
unsafe impl Sync for PhysicalDeviceFeatures {}
impl Default for PhysicalDeviceFeatures {
    fn default() -> Self {
        Self {
            robust_buffer_access: Default::default(),
            full_draw_index_uint32: Default::default(),
            image_cube_array: Default::default(),
            independent_blend: Default::default(),
            geometry_shader: Default::default(),
            tessellation_shader: Default::default(),
            sample_rate_shading: Default::default(),
            dual_src_blend: Default::default(),
            logic_op: Default::default(),
            multi_draw_indirect: Default::default(),
            draw_indirect_first_instance: Default::default(),
            depth_clamp: Default::default(),
            depth_bias_clamp: Default::default(),
            fill_mode_non_solid: Default::default(),
            depth_bounds: Default::default(),
            wide_lines: Default::default(),
            large_points: Default::default(),
            alpha_to_one: Default::default(),
            multi_viewport: Default::default(),
            sampler_anisotropy: Default::default(),
            texture_compression_etc2: Default::default(),
            texture_compression_astc_ldr: Default::default(),
            texture_compression_bc: Default::default(),
            occlusion_query_precise: Default::default(),
            pipeline_statistics_query: Default::default(),
            vertex_pipeline_stores_and_atomics: Default::default(),
            fragment_stores_and_atomics: Default::default(),
            shader_tessellation_and_geometry_point_size: Default::default(),
            shader_image_gather_extended: Default::default(),
            shader_storage_image_extended_formats: Default::default(),
            shader_storage_image_multisample: Default::default(),
            shader_storage_image_read_without_format: Default::default(),
            shader_storage_image_write_without_format: Default::default(),
            shader_uniform_buffer_array_dynamic_indexing: Default::default(),
            shader_sampled_image_array_dynamic_indexing: Default::default(),
            shader_storage_buffer_array_dynamic_indexing: Default::default(),
            shader_storage_image_array_dynamic_indexing: Default::default(),
            shader_clip_distance: Default::default(),
            shader_cull_distance: Default::default(),
            shader_float64: Default::default(),
            shader_int64: Default::default(),
            shader_int16: Default::default(),
            shader_resource_residency: Default::default(),
            shader_resource_min_lod: Default::default(),
            sparse_binding: Default::default(),
            sparse_residency_buffer: Default::default(),
            sparse_residency_image2_d: Default::default(),
            sparse_residency_image3_d: Default::default(),
            sparse_residency2_samples: Default::default(),
            sparse_residency4_samples: Default::default(),
            sparse_residency8_samples: Default::default(),
            sparse_residency16_samples: Default::default(),
            sparse_residency_aliased: Default::default(),
            variable_multisample_rate: Default::default(),
            inherited_queries: Default::default(),
        }
    }
}
impl PhysicalDeviceFeatures {
    #[inline]
    pub fn robust_buffer_access(mut self, value: impl Into<Bool32>) -> Self {
        self.robust_buffer_access = value.into();
        self
    }
    #[inline]
    pub fn full_draw_index_uint32(mut self, value: impl Into<Bool32>) -> Self {
        self.full_draw_index_uint32 = value.into();
        self
    }
    #[inline]
    pub fn image_cube_array(mut self, value: impl Into<Bool32>) -> Self {
        self.image_cube_array = value.into();
        self
    }
    #[inline]
    pub fn independent_blend(mut self, value: impl Into<Bool32>) -> Self {
        self.independent_blend = value.into();
        self
    }
    #[inline]
    pub fn geometry_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.geometry_shader = value.into();
        self
    }
    #[inline]
    pub fn tessellation_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.tessellation_shader = value.into();
        self
    }
    #[inline]
    pub fn sample_rate_shading(mut self, value: impl Into<Bool32>) -> Self {
        self.sample_rate_shading = value.into();
        self
    }
    #[inline]
    pub fn dual_src_blend(mut self, value: impl Into<Bool32>) -> Self {
        self.dual_src_blend = value.into();
        self
    }
    #[inline]
    pub fn logic_op(mut self, value: impl Into<Bool32>) -> Self {
        self.logic_op = value.into();
        self
    }
    #[inline]
    pub fn multi_draw_indirect(mut self, value: impl Into<Bool32>) -> Self {
        self.multi_draw_indirect = value.into();
        self
    }
    #[inline]
    pub fn draw_indirect_first_instance(mut self, value: impl Into<Bool32>) -> Self {
        self.draw_indirect_first_instance = value.into();
        self
    }
    #[inline]
    pub fn depth_clamp(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_clamp = value.into();
        self
    }
    #[inline]
    pub fn depth_bias_clamp(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_bias_clamp = value.into();
        self
    }
    #[inline]
    pub fn fill_mode_non_solid(mut self, value: impl Into<Bool32>) -> Self {
        self.fill_mode_non_solid = value.into();
        self
    }
    #[inline]
    pub fn depth_bounds(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_bounds = value.into();
        self
    }
    #[inline]
    pub fn wide_lines(mut self, value: impl Into<Bool32>) -> Self {
        self.wide_lines = value.into();
        self
    }
    #[inline]
    pub fn large_points(mut self, value: impl Into<Bool32>) -> Self {
        self.large_points = value.into();
        self
    }
    #[inline]
    pub fn alpha_to_one(mut self, value: impl Into<Bool32>) -> Self {
        self.alpha_to_one = value.into();
        self
    }
    #[inline]
    pub fn multi_viewport(mut self, value: impl Into<Bool32>) -> Self {
        self.multi_viewport = value.into();
        self
    }
    #[inline]
    pub fn sampler_anisotropy(mut self, value: impl Into<Bool32>) -> Self {
        self.sampler_anisotropy = value.into();
        self
    }
    #[inline]
    pub fn texture_compression_etc2(mut self, value: impl Into<Bool32>) -> Self {
        self.texture_compression_etc2 = value.into();
        self
    }
    #[inline]
    pub fn texture_compression_astc_ldr(mut self, value: impl Into<Bool32>) -> Self {
        self.texture_compression_astc_ldr = value.into();
        self
    }
    #[inline]
    pub fn texture_compression_bc(mut self, value: impl Into<Bool32>) -> Self {
        self.texture_compression_bc = value.into();
        self
    }
    #[inline]
    pub fn occlusion_query_precise(mut self, value: impl Into<Bool32>) -> Self {
        self.occlusion_query_precise = value.into();
        self
    }
    #[inline]
    pub fn pipeline_statistics_query(mut self, value: impl Into<Bool32>) -> Self {
        self.pipeline_statistics_query = value.into();
        self
    }
    #[inline]
    pub fn vertex_pipeline_stores_and_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.vertex_pipeline_stores_and_atomics = value.into();
        self
    }
    #[inline]
    pub fn fragment_stores_and_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_stores_and_atomics = value.into();
        self
    }
    #[inline]
    pub fn shader_tessellation_and_geometry_point_size(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_tessellation_and_geometry_point_size = value.into();
        self
    }
    #[inline]
    pub fn shader_image_gather_extended(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_image_gather_extended = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_extended_formats(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_storage_image_extended_formats = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_multisample(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_storage_image_multisample = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_read_without_format(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_storage_image_read_without_format = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_write_without_format(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_storage_image_write_without_format = value.into();
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_dynamic_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_uniform_buffer_array_dynamic_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_dynamic_indexing(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_sampled_image_array_dynamic_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_dynamic_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_buffer_array_dynamic_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_dynamic_indexing(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_storage_image_array_dynamic_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_clip_distance(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_clip_distance = value.into();
        self
    }
    #[inline]
    pub fn shader_cull_distance(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_cull_distance = value.into();
        self
    }
    #[inline]
    pub fn shader_float64(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_float64 = value.into();
        self
    }
    #[inline]
    pub fn shader_int64(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_int64 = value.into();
        self
    }
    #[inline]
    pub fn shader_int16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_int16 = value.into();
        self
    }
    #[inline]
    pub fn shader_resource_residency(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_resource_residency = value.into();
        self
    }
    #[inline]
    pub fn shader_resource_min_lod(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_resource_min_lod = value.into();
        self
    }
    #[inline]
    pub fn sparse_binding(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_binding = value.into();
        self
    }
    #[inline]
    pub fn sparse_residency_buffer(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_residency_buffer = value.into();
        self
    }
    #[inline]
    pub fn sparse_residency_image2_d(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_residency_image2_d = value.into();
        self
    }
    #[inline]
    pub fn sparse_residency_image3_d(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_residency_image3_d = value.into();
        self
    }
    #[inline]
    pub fn sparse_residency2_samples(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_residency2_samples = value.into();
        self
    }
    #[inline]
    pub fn sparse_residency4_samples(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_residency4_samples = value.into();
        self
    }
    #[inline]
    pub fn sparse_residency8_samples(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_residency8_samples = value.into();
        self
    }
    #[inline]
    pub fn sparse_residency16_samples(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_residency16_samples = value.into();
        self
    }
    #[inline]
    pub fn sparse_residency_aliased(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_residency_aliased = value.into();
        self
    }
    #[inline]
    pub fn variable_multisample_rate(mut self, value: impl Into<Bool32>) -> Self {
        self.variable_multisample_rate = value.into();
        self
    }
    #[inline]
    pub fn inherited_queries(mut self, value: impl Into<Bool32>) -> Self {
        self.inherited_queries = value.into();
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLimits.html>"]
#[doc(alias = "VkPhysicalDeviceLimits")]
pub struct PhysicalDeviceLimits {
    pub max_image_dimension1_d: u32,
    pub max_image_dimension2_d: u32,
    pub max_image_dimension3_d: u32,
    pub max_image_dimension_cube: u32,
    pub max_image_array_layers: u32,
    pub max_texel_buffer_elements: u32,
    pub max_uniform_buffer_range: u32,
    pub max_storage_buffer_range: u32,
    pub max_push_constants_size: u32,
    pub max_memory_allocation_count: u32,
    pub max_sampler_allocation_count: u32,
    pub buffer_image_granularity: DeviceSize,
    pub sparse_address_space_size: DeviceSize,
    pub max_bound_descriptor_sets: u32,
    pub max_per_stage_descriptor_samplers: u32,
    pub max_per_stage_descriptor_uniform_buffers: u32,
    pub max_per_stage_descriptor_storage_buffers: u32,
    pub max_per_stage_descriptor_sampled_images: u32,
    pub max_per_stage_descriptor_storage_images: u32,
    pub max_per_stage_descriptor_input_attachments: u32,
    pub max_per_stage_resources: u32,
    pub max_descriptor_set_samplers: u32,
    pub max_descriptor_set_uniform_buffers: u32,
    pub max_descriptor_set_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_storage_buffers: u32,
    pub max_descriptor_set_storage_buffers_dynamic: u32,
    pub max_descriptor_set_sampled_images: u32,
    pub max_descriptor_set_storage_images: u32,
    pub max_descriptor_set_input_attachments: u32,
    pub max_vertex_input_attributes: u32,
    pub max_vertex_input_bindings: u32,
    pub max_vertex_input_attribute_offset: u32,
    pub max_vertex_input_binding_stride: u32,
    pub max_vertex_output_components: u32,
    pub max_tessellation_generation_level: u32,
    pub max_tessellation_patch_size: u32,
    pub max_tessellation_control_per_vertex_input_components: u32,
    pub max_tessellation_control_per_vertex_output_components: u32,
    pub max_tessellation_control_per_patch_output_components: u32,
    pub max_tessellation_control_total_output_components: u32,
    pub max_tessellation_evaluation_input_components: u32,
    pub max_tessellation_evaluation_output_components: u32,
    pub max_geometry_shader_invocations: u32,
    pub max_geometry_input_components: u32,
    pub max_geometry_output_components: u32,
    pub max_geometry_output_vertices: u32,
    pub max_geometry_total_output_components: u32,
    pub max_fragment_input_components: u32,
    pub max_fragment_output_attachments: u32,
    pub max_fragment_dual_src_attachments: u32,
    pub max_fragment_combined_output_resources: u32,
    pub max_compute_shared_memory_size: u32,
    pub max_compute_work_group_count: [u32; 3u16 as _],
    pub max_compute_work_group_invocations: u32,
    pub max_compute_work_group_size: [u32; 3u16 as _],
    pub sub_pixel_precision_bits: u32,
    pub sub_texel_precision_bits: u32,
    pub mipmap_precision_bits: u32,
    pub max_draw_indexed_index_value: u32,
    pub max_draw_indirect_count: u32,
    pub max_sampler_lod_bias: f32,
    pub max_sampler_anisotropy: f32,
    pub max_viewports: u32,
    pub max_viewport_dimensions: [u32; 2u16 as _],
    pub viewport_bounds_range: [f32; 2u16 as _],
    pub viewport_sub_pixel_bits: u32,
    pub min_memory_map_alignment: usize,
    pub min_texel_buffer_offset_alignment: DeviceSize,
    pub min_uniform_buffer_offset_alignment: DeviceSize,
    pub min_storage_buffer_offset_alignment: DeviceSize,
    pub min_texel_offset: i32,
    pub max_texel_offset: u32,
    pub min_texel_gather_offset: i32,
    pub max_texel_gather_offset: u32,
    pub min_interpolation_offset: f32,
    pub max_interpolation_offset: f32,
    pub sub_pixel_interpolation_offset_bits: u32,
    pub max_framebuffer_width: u32,
    pub max_framebuffer_height: u32,
    pub max_framebuffer_layers: u32,
    pub framebuffer_color_sample_counts: SampleCountFlags,
    pub framebuffer_depth_sample_counts: SampleCountFlags,
    pub framebuffer_stencil_sample_counts: SampleCountFlags,
    pub framebuffer_no_attachments_sample_counts: SampleCountFlags,
    pub max_color_attachments: u32,
    pub sampled_image_color_sample_counts: SampleCountFlags,
    pub sampled_image_integer_sample_counts: SampleCountFlags,
    pub sampled_image_depth_sample_counts: SampleCountFlags,
    pub sampled_image_stencil_sample_counts: SampleCountFlags,
    pub storage_image_sample_counts: SampleCountFlags,
    pub max_sample_mask_words: u32,
    pub timestamp_compute_and_graphics: Bool32,
    pub timestamp_period: f32,
    pub max_clip_distances: u32,
    pub max_cull_distances: u32,
    pub max_combined_clip_and_cull_distances: u32,
    pub discrete_queue_priorities: u32,
    pub point_size_range: [f32; 2u16 as _],
    pub line_width_range: [f32; 2u16 as _],
    pub point_size_granularity: f32,
    pub line_width_granularity: f32,
    pub strict_lines: Bool32,
    pub standard_sample_locations: Bool32,
    pub optimal_buffer_copy_offset_alignment: DeviceSize,
    pub optimal_buffer_copy_row_pitch_alignment: DeviceSize,
    pub non_coherent_atom_size: DeviceSize,
}
unsafe impl Send for PhysicalDeviceLimits {}
unsafe impl Sync for PhysicalDeviceLimits {}
impl Default for PhysicalDeviceLimits {
    fn default() -> Self {
        Self {
            max_image_dimension1_d: Default::default(),
            max_image_dimension2_d: Default::default(),
            max_image_dimension3_d: Default::default(),
            max_image_dimension_cube: Default::default(),
            max_image_array_layers: Default::default(),
            max_texel_buffer_elements: Default::default(),
            max_uniform_buffer_range: Default::default(),
            max_storage_buffer_range: Default::default(),
            max_push_constants_size: Default::default(),
            max_memory_allocation_count: Default::default(),
            max_sampler_allocation_count: Default::default(),
            buffer_image_granularity: Default::default(),
            sparse_address_space_size: Default::default(),
            max_bound_descriptor_sets: Default::default(),
            max_per_stage_descriptor_samplers: Default::default(),
            max_per_stage_descriptor_uniform_buffers: Default::default(),
            max_per_stage_descriptor_storage_buffers: Default::default(),
            max_per_stage_descriptor_sampled_images: Default::default(),
            max_per_stage_descriptor_storage_images: Default::default(),
            max_per_stage_descriptor_input_attachments: Default::default(),
            max_per_stage_resources: Default::default(),
            max_descriptor_set_samplers: Default::default(),
            max_descriptor_set_uniform_buffers: Default::default(),
            max_descriptor_set_uniform_buffers_dynamic: Default::default(),
            max_descriptor_set_storage_buffers: Default::default(),
            max_descriptor_set_storage_buffers_dynamic: Default::default(),
            max_descriptor_set_sampled_images: Default::default(),
            max_descriptor_set_storage_images: Default::default(),
            max_descriptor_set_input_attachments: Default::default(),
            max_vertex_input_attributes: Default::default(),
            max_vertex_input_bindings: Default::default(),
            max_vertex_input_attribute_offset: Default::default(),
            max_vertex_input_binding_stride: Default::default(),
            max_vertex_output_components: Default::default(),
            max_tessellation_generation_level: Default::default(),
            max_tessellation_patch_size: Default::default(),
            max_tessellation_control_per_vertex_input_components: Default::default(),
            max_tessellation_control_per_vertex_output_components: Default::default(),
            max_tessellation_control_per_patch_output_components: Default::default(),
            max_tessellation_control_total_output_components: Default::default(),
            max_tessellation_evaluation_input_components: Default::default(),
            max_tessellation_evaluation_output_components: Default::default(),
            max_geometry_shader_invocations: Default::default(),
            max_geometry_input_components: Default::default(),
            max_geometry_output_components: Default::default(),
            max_geometry_output_vertices: Default::default(),
            max_geometry_total_output_components: Default::default(),
            max_fragment_input_components: Default::default(),
            max_fragment_output_attachments: Default::default(),
            max_fragment_dual_src_attachments: Default::default(),
            max_fragment_combined_output_resources: Default::default(),
            max_compute_shared_memory_size: Default::default(),
            max_compute_work_group_count: array::from_fn(|_| Default::default()),
            max_compute_work_group_invocations: Default::default(),
            max_compute_work_group_size: array::from_fn(|_| Default::default()),
            sub_pixel_precision_bits: Default::default(),
            sub_texel_precision_bits: Default::default(),
            mipmap_precision_bits: Default::default(),
            max_draw_indexed_index_value: Default::default(),
            max_draw_indirect_count: Default::default(),
            max_sampler_lod_bias: Default::default(),
            max_sampler_anisotropy: Default::default(),
            max_viewports: Default::default(),
            max_viewport_dimensions: array::from_fn(|_| Default::default()),
            viewport_bounds_range: array::from_fn(|_| Default::default()),
            viewport_sub_pixel_bits: Default::default(),
            min_memory_map_alignment: Default::default(),
            min_texel_buffer_offset_alignment: Default::default(),
            min_uniform_buffer_offset_alignment: Default::default(),
            min_storage_buffer_offset_alignment: Default::default(),
            min_texel_offset: Default::default(),
            max_texel_offset: Default::default(),
            min_texel_gather_offset: Default::default(),
            max_texel_gather_offset: Default::default(),
            min_interpolation_offset: Default::default(),
            max_interpolation_offset: Default::default(),
            sub_pixel_interpolation_offset_bits: Default::default(),
            max_framebuffer_width: Default::default(),
            max_framebuffer_height: Default::default(),
            max_framebuffer_layers: Default::default(),
            framebuffer_color_sample_counts: Default::default(),
            framebuffer_depth_sample_counts: Default::default(),
            framebuffer_stencil_sample_counts: Default::default(),
            framebuffer_no_attachments_sample_counts: Default::default(),
            max_color_attachments: Default::default(),
            sampled_image_color_sample_counts: Default::default(),
            sampled_image_integer_sample_counts: Default::default(),
            sampled_image_depth_sample_counts: Default::default(),
            sampled_image_stencil_sample_counts: Default::default(),
            storage_image_sample_counts: Default::default(),
            max_sample_mask_words: Default::default(),
            timestamp_compute_and_graphics: Default::default(),
            timestamp_period: Default::default(),
            max_clip_distances: Default::default(),
            max_cull_distances: Default::default(),
            max_combined_clip_and_cull_distances: Default::default(),
            discrete_queue_priorities: Default::default(),
            point_size_range: array::from_fn(|_| Default::default()),
            line_width_range: array::from_fn(|_| Default::default()),
            point_size_granularity: Default::default(),
            line_width_granularity: Default::default(),
            strict_lines: Default::default(),
            standard_sample_locations: Default::default(),
            optimal_buffer_copy_offset_alignment: Default::default(),
            optimal_buffer_copy_row_pitch_alignment: Default::default(),
            non_coherent_atom_size: Default::default(),
        }
    }
}
impl PhysicalDeviceLimits {
    #[inline]
    pub fn max_image_dimension1_d(mut self, value: u32) -> Self {
        self.max_image_dimension1_d = value;
        self
    }
    #[inline]
    pub fn max_image_dimension2_d(mut self, value: u32) -> Self {
        self.max_image_dimension2_d = value;
        self
    }
    #[inline]
    pub fn max_image_dimension3_d(mut self, value: u32) -> Self {
        self.max_image_dimension3_d = value;
        self
    }
    #[inline]
    pub fn max_image_dimension_cube(mut self, value: u32) -> Self {
        self.max_image_dimension_cube = value;
        self
    }
    #[inline]
    pub fn max_image_array_layers(mut self, value: u32) -> Self {
        self.max_image_array_layers = value;
        self
    }
    #[inline]
    pub fn max_texel_buffer_elements(mut self, value: u32) -> Self {
        self.max_texel_buffer_elements = value;
        self
    }
    #[inline]
    pub fn max_uniform_buffer_range(mut self, value: u32) -> Self {
        self.max_uniform_buffer_range = value;
        self
    }
    #[inline]
    pub fn max_storage_buffer_range(mut self, value: u32) -> Self {
        self.max_storage_buffer_range = value;
        self
    }
    #[inline]
    pub fn max_push_constants_size(mut self, value: u32) -> Self {
        self.max_push_constants_size = value;
        self
    }
    #[inline]
    pub fn max_memory_allocation_count(mut self, value: u32) -> Self {
        self.max_memory_allocation_count = value;
        self
    }
    #[inline]
    pub fn max_sampler_allocation_count(mut self, value: u32) -> Self {
        self.max_sampler_allocation_count = value;
        self
    }
    #[inline]
    pub fn buffer_image_granularity(mut self, value: DeviceSize) -> Self {
        self.buffer_image_granularity = value;
        self
    }
    #[inline]
    pub fn sparse_address_space_size(mut self, value: DeviceSize) -> Self {
        self.sparse_address_space_size = value;
        self
    }
    #[inline]
    pub fn max_bound_descriptor_sets(mut self, value: u32) -> Self {
        self.max_bound_descriptor_sets = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_samplers(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_samplers = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_uniform_buffers(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_uniform_buffers = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_storage_buffers(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_storage_buffers = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_sampled_images(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_sampled_images = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_storage_images(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_storage_images = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_input_attachments(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_input_attachments = value;
        self
    }
    #[inline]
    pub fn max_per_stage_resources(mut self, value: u32) -> Self {
        self.max_per_stage_resources = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_samplers(mut self, value: u32) -> Self {
        self.max_descriptor_set_samplers = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_uniform_buffers(mut self, value: u32) -> Self {
        self.max_descriptor_set_uniform_buffers = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_uniform_buffers_dynamic(mut self, value: u32) -> Self {
        self.max_descriptor_set_uniform_buffers_dynamic = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_storage_buffers(mut self, value: u32) -> Self {
        self.max_descriptor_set_storage_buffers = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_storage_buffers_dynamic(mut self, value: u32) -> Self {
        self.max_descriptor_set_storage_buffers_dynamic = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_sampled_images(mut self, value: u32) -> Self {
        self.max_descriptor_set_sampled_images = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_storage_images(mut self, value: u32) -> Self {
        self.max_descriptor_set_storage_images = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_input_attachments(mut self, value: u32) -> Self {
        self.max_descriptor_set_input_attachments = value;
        self
    }
    #[inline]
    pub fn max_vertex_input_attributes(mut self, value: u32) -> Self {
        self.max_vertex_input_attributes = value;
        self
    }
    #[inline]
    pub fn max_vertex_input_bindings(mut self, value: u32) -> Self {
        self.max_vertex_input_bindings = value;
        self
    }
    #[inline]
    pub fn max_vertex_input_attribute_offset(mut self, value: u32) -> Self {
        self.max_vertex_input_attribute_offset = value;
        self
    }
    #[inline]
    pub fn max_vertex_input_binding_stride(mut self, value: u32) -> Self {
        self.max_vertex_input_binding_stride = value;
        self
    }
    #[inline]
    pub fn max_vertex_output_components(mut self, value: u32) -> Self {
        self.max_vertex_output_components = value;
        self
    }
    #[inline]
    pub fn max_tessellation_generation_level(mut self, value: u32) -> Self {
        self.max_tessellation_generation_level = value;
        self
    }
    #[inline]
    pub fn max_tessellation_patch_size(mut self, value: u32) -> Self {
        self.max_tessellation_patch_size = value;
        self
    }
    #[inline]
    pub fn max_tessellation_control_per_vertex_input_components(mut self, value: u32) -> Self {
        self.max_tessellation_control_per_vertex_input_components = value;
        self
    }
    #[inline]
    pub fn max_tessellation_control_per_vertex_output_components(mut self, value: u32) -> Self {
        self.max_tessellation_control_per_vertex_output_components = value;
        self
    }
    #[inline]
    pub fn max_tessellation_control_per_patch_output_components(mut self, value: u32) -> Self {
        self.max_tessellation_control_per_patch_output_components = value;
        self
    }
    #[inline]
    pub fn max_tessellation_control_total_output_components(mut self, value: u32) -> Self {
        self.max_tessellation_control_total_output_components = value;
        self
    }
    #[inline]
    pub fn max_tessellation_evaluation_input_components(mut self, value: u32) -> Self {
        self.max_tessellation_evaluation_input_components = value;
        self
    }
    #[inline]
    pub fn max_tessellation_evaluation_output_components(mut self, value: u32) -> Self {
        self.max_tessellation_evaluation_output_components = value;
        self
    }
    #[inline]
    pub fn max_geometry_shader_invocations(mut self, value: u32) -> Self {
        self.max_geometry_shader_invocations = value;
        self
    }
    #[inline]
    pub fn max_geometry_input_components(mut self, value: u32) -> Self {
        self.max_geometry_input_components = value;
        self
    }
    #[inline]
    pub fn max_geometry_output_components(mut self, value: u32) -> Self {
        self.max_geometry_output_components = value;
        self
    }
    #[inline]
    pub fn max_geometry_output_vertices(mut self, value: u32) -> Self {
        self.max_geometry_output_vertices = value;
        self
    }
    #[inline]
    pub fn max_geometry_total_output_components(mut self, value: u32) -> Self {
        self.max_geometry_total_output_components = value;
        self
    }
    #[inline]
    pub fn max_fragment_input_components(mut self, value: u32) -> Self {
        self.max_fragment_input_components = value;
        self
    }
    #[inline]
    pub fn max_fragment_output_attachments(mut self, value: u32) -> Self {
        self.max_fragment_output_attachments = value;
        self
    }
    #[inline]
    pub fn max_fragment_dual_src_attachments(mut self, value: u32) -> Self {
        self.max_fragment_dual_src_attachments = value;
        self
    }
    #[inline]
    pub fn max_fragment_combined_output_resources(mut self, value: u32) -> Self {
        self.max_fragment_combined_output_resources = value;
        self
    }
    #[inline]
    pub fn max_compute_shared_memory_size(mut self, value: u32) -> Self {
        self.max_compute_shared_memory_size = value;
        self
    }
    #[inline]
    pub fn max_compute_work_group_count(mut self, value: [u32; 3u16 as _]) -> Self {
        self.max_compute_work_group_count = value;
        self
    }
    #[inline]
    pub fn max_compute_work_group_invocations(mut self, value: u32) -> Self {
        self.max_compute_work_group_invocations = value;
        self
    }
    #[inline]
    pub fn max_compute_work_group_size(mut self, value: [u32; 3u16 as _]) -> Self {
        self.max_compute_work_group_size = value;
        self
    }
    #[inline]
    pub fn sub_pixel_precision_bits(mut self, value: u32) -> Self {
        self.sub_pixel_precision_bits = value;
        self
    }
    #[inline]
    pub fn sub_texel_precision_bits(mut self, value: u32) -> Self {
        self.sub_texel_precision_bits = value;
        self
    }
    #[inline]
    pub fn mipmap_precision_bits(mut self, value: u32) -> Self {
        self.mipmap_precision_bits = value;
        self
    }
    #[inline]
    pub fn max_draw_indexed_index_value(mut self, value: u32) -> Self {
        self.max_draw_indexed_index_value = value;
        self
    }
    #[inline]
    pub fn max_draw_indirect_count(mut self, value: u32) -> Self {
        self.max_draw_indirect_count = value;
        self
    }
    #[inline]
    pub fn max_sampler_lod_bias(mut self, value: f32) -> Self {
        self.max_sampler_lod_bias = value;
        self
    }
    #[inline]
    pub fn max_sampler_anisotropy(mut self, value: f32) -> Self {
        self.max_sampler_anisotropy = value;
        self
    }
    #[inline]
    pub fn max_viewports(mut self, value: u32) -> Self {
        self.max_viewports = value;
        self
    }
    #[inline]
    pub fn max_viewport_dimensions(mut self, value: [u32; 2u16 as _]) -> Self {
        self.max_viewport_dimensions = value;
        self
    }
    #[inline]
    pub fn viewport_bounds_range(mut self, value: [f32; 2u16 as _]) -> Self {
        self.viewport_bounds_range = value;
        self
    }
    #[inline]
    pub fn viewport_sub_pixel_bits(mut self, value: u32) -> Self {
        self.viewport_sub_pixel_bits = value;
        self
    }
    #[inline]
    pub fn min_memory_map_alignment(mut self, value: usize) -> Self {
        self.min_memory_map_alignment = value;
        self
    }
    #[inline]
    pub fn min_texel_buffer_offset_alignment(mut self, value: DeviceSize) -> Self {
        self.min_texel_buffer_offset_alignment = value;
        self
    }
    #[inline]
    pub fn min_uniform_buffer_offset_alignment(mut self, value: DeviceSize) -> Self {
        self.min_uniform_buffer_offset_alignment = value;
        self
    }
    #[inline]
    pub fn min_storage_buffer_offset_alignment(mut self, value: DeviceSize) -> Self {
        self.min_storage_buffer_offset_alignment = value;
        self
    }
    #[inline]
    pub fn min_texel_offset(mut self, value: i32) -> Self {
        self.min_texel_offset = value;
        self
    }
    #[inline]
    pub fn max_texel_offset(mut self, value: u32) -> Self {
        self.max_texel_offset = value;
        self
    }
    #[inline]
    pub fn min_texel_gather_offset(mut self, value: i32) -> Self {
        self.min_texel_gather_offset = value;
        self
    }
    #[inline]
    pub fn max_texel_gather_offset(mut self, value: u32) -> Self {
        self.max_texel_gather_offset = value;
        self
    }
    #[inline]
    pub fn min_interpolation_offset(mut self, value: f32) -> Self {
        self.min_interpolation_offset = value;
        self
    }
    #[inline]
    pub fn max_interpolation_offset(mut self, value: f32) -> Self {
        self.max_interpolation_offset = value;
        self
    }
    #[inline]
    pub fn sub_pixel_interpolation_offset_bits(mut self, value: u32) -> Self {
        self.sub_pixel_interpolation_offset_bits = value;
        self
    }
    #[inline]
    pub fn max_framebuffer_width(mut self, value: u32) -> Self {
        self.max_framebuffer_width = value;
        self
    }
    #[inline]
    pub fn max_framebuffer_height(mut self, value: u32) -> Self {
        self.max_framebuffer_height = value;
        self
    }
    #[inline]
    pub fn max_framebuffer_layers(mut self, value: u32) -> Self {
        self.max_framebuffer_layers = value;
        self
    }
    #[inline]
    pub fn framebuffer_color_sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.framebuffer_color_sample_counts = value;
        self
    }
    #[inline]
    pub fn framebuffer_depth_sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.framebuffer_depth_sample_counts = value;
        self
    }
    #[inline]
    pub fn framebuffer_stencil_sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.framebuffer_stencil_sample_counts = value;
        self
    }
    #[inline]
    pub fn framebuffer_no_attachments_sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.framebuffer_no_attachments_sample_counts = value;
        self
    }
    #[inline]
    pub fn max_color_attachments(mut self, value: u32) -> Self {
        self.max_color_attachments = value;
        self
    }
    #[inline]
    pub fn sampled_image_color_sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.sampled_image_color_sample_counts = value;
        self
    }
    #[inline]
    pub fn sampled_image_integer_sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.sampled_image_integer_sample_counts = value;
        self
    }
    #[inline]
    pub fn sampled_image_depth_sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.sampled_image_depth_sample_counts = value;
        self
    }
    #[inline]
    pub fn sampled_image_stencil_sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.sampled_image_stencil_sample_counts = value;
        self
    }
    #[inline]
    pub fn storage_image_sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.storage_image_sample_counts = value;
        self
    }
    #[inline]
    pub fn max_sample_mask_words(mut self, value: u32) -> Self {
        self.max_sample_mask_words = value;
        self
    }
    #[inline]
    pub fn timestamp_compute_and_graphics(mut self, value: impl Into<Bool32>) -> Self {
        self.timestamp_compute_and_graphics = value.into();
        self
    }
    #[inline]
    pub fn timestamp_period(mut self, value: f32) -> Self {
        self.timestamp_period = value;
        self
    }
    #[inline]
    pub fn max_clip_distances(mut self, value: u32) -> Self {
        self.max_clip_distances = value;
        self
    }
    #[inline]
    pub fn max_cull_distances(mut self, value: u32) -> Self {
        self.max_cull_distances = value;
        self
    }
    #[inline]
    pub fn max_combined_clip_and_cull_distances(mut self, value: u32) -> Self {
        self.max_combined_clip_and_cull_distances = value;
        self
    }
    #[inline]
    pub fn discrete_queue_priorities(mut self, value: u32) -> Self {
        self.discrete_queue_priorities = value;
        self
    }
    #[inline]
    pub fn point_size_range(mut self, value: [f32; 2u16 as _]) -> Self {
        self.point_size_range = value;
        self
    }
    #[inline]
    pub fn line_width_range(mut self, value: [f32; 2u16 as _]) -> Self {
        self.line_width_range = value;
        self
    }
    #[inline]
    pub fn point_size_granularity(mut self, value: f32) -> Self {
        self.point_size_granularity = value;
        self
    }
    #[inline]
    pub fn line_width_granularity(mut self, value: f32) -> Self {
        self.line_width_granularity = value;
        self
    }
    #[inline]
    pub fn strict_lines(mut self, value: impl Into<Bool32>) -> Self {
        self.strict_lines = value.into();
        self
    }
    #[inline]
    pub fn standard_sample_locations(mut self, value: impl Into<Bool32>) -> Self {
        self.standard_sample_locations = value.into();
        self
    }
    #[inline]
    pub fn optimal_buffer_copy_offset_alignment(mut self, value: DeviceSize) -> Self {
        self.optimal_buffer_copy_offset_alignment = value;
        self
    }
    #[inline]
    pub fn optimal_buffer_copy_row_pitch_alignment(mut self, value: DeviceSize) -> Self {
        self.optimal_buffer_copy_row_pitch_alignment = value;
        self
    }
    #[inline]
    pub fn non_coherent_atom_size(mut self, value: DeviceSize) -> Self {
        self.non_coherent_atom_size = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties.html>"]
#[doc(alias = "VkPhysicalDeviceMemoryProperties")]
pub struct PhysicalDeviceMemoryProperties {
    pub(crate) memory_type_count: u32,
    pub(crate) memory_types: [MemoryType; MAX_MEMORY_TYPES as _],
    pub(crate) memory_heap_count: u32,
    pub(crate) memory_heaps: [MemoryHeap; MAX_MEMORY_HEAPS as _],
}
unsafe impl Send for PhysicalDeviceMemoryProperties {}
unsafe impl Sync for PhysicalDeviceMemoryProperties {}
impl Default for PhysicalDeviceMemoryProperties {
    fn default() -> Self {
        Self {
            memory_type_count: Default::default(),
            memory_types: array::from_fn(|_| Default::default()),
            memory_heap_count: Default::default(),
            memory_heaps: array::from_fn(|_| Default::default()),
        }
    }
}
impl PhysicalDeviceMemoryProperties {}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties.html>"]
#[doc(alias = "VkPhysicalDeviceProperties")]
pub struct PhysicalDeviceProperties {
    pub api_version: ApiVersion,
    pub driver_version: u32,
    pub vendor_id: u32,
    pub device_id: u32,
    pub device_type: PhysicalDeviceType,
    pub(crate) device_name: [c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE as _],
    pub pipeline_cache_uuid: [u8; UUID_SIZE as _],
    pub limits: PhysicalDeviceLimits,
    pub sparse_properties: PhysicalDeviceSparseProperties,
}
unsafe impl Send for PhysicalDeviceProperties {}
unsafe impl Sync for PhysicalDeviceProperties {}
impl Default for PhysicalDeviceProperties {
    fn default() -> Self {
        Self {
            api_version: Default::default(),
            driver_version: Default::default(),
            vendor_id: Default::default(),
            device_id: Default::default(),
            device_type: PhysicalDeviceType::Other,
            device_name: array::from_fn(|_| Default::default()),
            pipeline_cache_uuid: array::from_fn(|_| Default::default()),
            limits: Default::default(),
            sparse_properties: Default::default(),
        }
    }
}
impl PhysicalDeviceProperties {
    #[inline]
    pub fn api_version(mut self, value: ApiVersion) -> Self {
        self.api_version = value;
        self
    }
    #[inline]
    pub fn driver_version(mut self, value: u32) -> Self {
        self.driver_version = value;
        self
    }
    #[inline]
    pub fn vendor_id(mut self, value: u32) -> Self {
        self.vendor_id = value;
        self
    }
    #[inline]
    pub fn device_id(mut self, value: u32) -> Self {
        self.device_id = value;
        self
    }
    #[inline]
    pub fn device_type(mut self, value: PhysicalDeviceType) -> Self {
        self.device_type = value;
        self
    }
    #[inline]
    pub fn pipeline_cache_uuid(mut self, value: [u8; UUID_SIZE as _]) -> Self {
        self.pipeline_cache_uuid = value;
        self
    }
    #[inline]
    pub fn limits(mut self, value: PhysicalDeviceLimits) -> Self {
        self.limits = value;
        self
    }
    #[inline]
    pub fn sparse_properties(mut self, value: PhysicalDeviceSparseProperties) -> Self {
        self.sparse_properties = value;
        self
    }
    pub fn get_device_name(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe {
                mem::transmute::<_, &[u8; MAX_PHYSICAL_DEVICE_NAME_SIZE as _]>(&self.device_name)
            }
            .as_slice(),
        )
        .unwrap()
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSparseProperties.html>"]
#[doc(alias = "VkPhysicalDeviceSparseProperties")]
pub struct PhysicalDeviceSparseProperties {
    pub residency_standard2_dblock_shape: Bool32,
    pub residency_standard2_dmultisample_block_shape: Bool32,
    pub residency_standard3_dblock_shape: Bool32,
    pub residency_aligned_mip_size: Bool32,
    pub residency_non_resident_strict: Bool32,
}
unsafe impl Send for PhysicalDeviceSparseProperties {}
unsafe impl Sync for PhysicalDeviceSparseProperties {}
impl Default for PhysicalDeviceSparseProperties {
    fn default() -> Self {
        Self {
            residency_standard2_dblock_shape: Default::default(),
            residency_standard2_dmultisample_block_shape: Default::default(),
            residency_standard3_dblock_shape: Default::default(),
            residency_aligned_mip_size: Default::default(),
            residency_non_resident_strict: Default::default(),
        }
    }
}
impl PhysicalDeviceSparseProperties {
    #[inline]
    pub fn residency_standard2_dblock_shape(mut self, value: impl Into<Bool32>) -> Self {
        self.residency_standard2_dblock_shape = value.into();
        self
    }
    #[inline]
    pub fn residency_standard2_dmultisample_block_shape(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.residency_standard2_dmultisample_block_shape = value.into();
        self
    }
    #[inline]
    pub fn residency_standard3_dblock_shape(mut self, value: impl Into<Bool32>) -> Self {
        self.residency_standard3_dblock_shape = value.into();
        self
    }
    #[inline]
    pub fn residency_aligned_mip_size(mut self, value: impl Into<Bool32>) -> Self {
        self.residency_aligned_mip_size = value.into();
        self
    }
    #[inline]
    pub fn residency_non_resident_strict(mut self, value: impl Into<Bool32>) -> Self {
        self.residency_non_resident_strict = value.into();
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties.html>"]
#[doc(alias = "VkQueueFamilyProperties")]
pub struct QueueFamilyProperties {
    pub queue_flags: QueueFlags,
    pub queue_count: u32,
    pub timestamp_valid_bits: u32,
    pub min_image_transfer_granularity: Extent3D,
}
unsafe impl Send for QueueFamilyProperties {}
unsafe impl Sync for QueueFamilyProperties {}
impl Default for QueueFamilyProperties {
    fn default() -> Self {
        Self {
            queue_flags: Default::default(),
            queue_count: Default::default(),
            timestamp_valid_bits: Default::default(),
            min_image_transfer_granularity: Default::default(),
        }
    }
}
impl QueueFamilyProperties {
    #[inline]
    pub fn queue_flags(mut self, value: QueueFlags) -> Self {
        self.queue_flags = value;
        self
    }
    #[inline]
    pub fn queue_count(mut self, value: u32) -> Self {
        self.queue_count = value;
        self
    }
    #[inline]
    pub fn timestamp_valid_bits(mut self, value: u32) -> Self {
        self.timestamp_valid_bits = value;
        self
    }
    #[inline]
    pub fn min_image_transfer_granularity(mut self, value: Extent3D) -> Self {
        self.min_image_transfer_granularity = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html>"]
#[doc(alias = "VkDeviceCreateInfo")]
pub struct DeviceCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub(crate) queue_create_info_count: u32,
    pub(crate) p_queue_create_infos: *const DeviceQueueCreateInfo<'a>,
    pub(crate) enabled_layer_count: u32,
    pub(crate) pp_enabled_layer_names: *const *const c_char,
    pub(crate) enabled_extension_count: u32,
    pub(crate) pp_enabled_extension_names: *const DeviceExtensionName,
    pub p_enabled_features: *const PhysicalDeviceFeatures,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceCreateInfo;
}
unsafe impl<'a> Send for DeviceCreateInfo<'a> {}
unsafe impl<'a> Sync for DeviceCreateInfo<'a> {}
impl<'a> Default for DeviceCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            queue_create_info_count: Default::default(),
            p_queue_create_infos: ptr::null(),
            enabled_layer_count: Default::default(),
            pp_enabled_layer_names: ptr::null(),
            enabled_extension_count: Default::default(),
            pp_enabled_extension_names: ptr::null(),
            p_enabled_features: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn enabled_features(mut self, value: Option<&'a PhysicalDeviceFeatures>) -> Self {
        self.p_enabled_features = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn queue_create_infos(
        mut self,
        p_queue_create_infos: impl AsSlice<'a, DeviceQueueCreateInfo<'a>>,
    ) -> Self {
        self.p_queue_create_infos = p_queue_create_infos.as_slice().as_ptr().cast();
        self.queue_create_info_count = p_queue_create_infos.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn enabled_layer(
        mut self,
        pp_enabled_layer_names: impl AsSlice<'a, *const c_char>,
    ) -> Self {
        self.pp_enabled_layer_names = pp_enabled_layer_names.as_slice().as_ptr().cast();
        self.enabled_layer_count = pp_enabled_layer_names.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn enabled_extension(
        mut self,
        pp_enabled_extension_names: impl AsSlice<'a, DeviceExtensionName>,
    ) -> Self {
        self.pp_enabled_extension_names = pp_enabled_extension_names.as_slice().as_ptr().cast();
        self.enabled_extension_count = pp_enabled_extension_names.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html>"]
#[doc(alias = "VkDeviceQueueCreateInfo")]
pub struct DeviceQueueCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: DeviceQueueCreateFlags,
    pub queue_family_index: u32,
    pub(crate) queue_count: u32,
    pub(crate) p_queue_priorities: *const f32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceQueueCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceQueueCreateInfo;
}
unsafe impl<'a> Send for DeviceQueueCreateInfo<'a> {}
unsafe impl<'a> Sync for DeviceQueueCreateInfo<'a> {}
impl<'a> Default for DeviceQueueCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            queue_family_index: Default::default(),
            queue_count: Default::default(),
            p_queue_priorities: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceQueueCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: DeviceQueueCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn queue_family_index(mut self, value: u32) -> Self {
        self.queue_family_index = value;
        self
    }
    #[inline]
    pub fn queue_priorities(mut self, p_queue_priorities: impl AsSlice<'a, f32>) -> Self {
        self.p_queue_priorities = p_queue_priorities.as_slice().as_ptr().cast();
        self.queue_count = p_queue_priorities.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtensionProperties.html>"]
#[doc(alias = "VkExtensionProperties")]
pub struct ExtensionProperties {
    pub(crate) extension_name: [c_char; MAX_EXTENSION_NAME_SIZE as _],
    pub spec_version: u32,
}
unsafe impl Send for ExtensionProperties {}
unsafe impl Sync for ExtensionProperties {}
impl Default for ExtensionProperties {
    fn default() -> Self {
        Self {
            extension_name: array::from_fn(|_| Default::default()),
            spec_version: Default::default(),
        }
    }
}
impl ExtensionProperties {
    #[inline]
    pub fn spec_version(mut self, value: u32) -> Self {
        self.spec_version = value;
        self
    }
    pub fn get_extension_name(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe {
                mem::transmute::<_, &[u8; MAX_EXTENSION_NAME_SIZE as _]>(&self.extension_name)
            }
            .as_slice(),
        )
        .unwrap()
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLayerProperties.html>"]
#[doc(alias = "VkLayerProperties")]
pub struct LayerProperties {
    pub(crate) layer_name: [c_char; MAX_EXTENSION_NAME_SIZE as _],
    pub spec_version: u32,
    pub implementation_version: u32,
    pub(crate) description: [c_char; MAX_DESCRIPTION_SIZE as _],
}
unsafe impl Send for LayerProperties {}
unsafe impl Sync for LayerProperties {}
impl Default for LayerProperties {
    fn default() -> Self {
        Self {
            layer_name: array::from_fn(|_| Default::default()),
            spec_version: Default::default(),
            implementation_version: Default::default(),
            description: array::from_fn(|_| Default::default()),
        }
    }
}
impl LayerProperties {
    #[inline]
    pub fn spec_version(mut self, value: u32) -> Self {
        self.spec_version = value;
        self
    }
    #[inline]
    pub fn implementation_version(mut self, value: u32) -> Self {
        self.implementation_version = value;
        self
    }
    pub fn get_layer_name(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_EXTENSION_NAME_SIZE as _]>(&self.layer_name) }
                .as_slice(),
        )
        .unwrap()
    }
    pub fn get_description(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.description) }
                .as_slice(),
        )
        .unwrap()
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html>"]
#[doc(alias = "VkSubmitInfo")]
pub struct SubmitInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) wait_semaphore_count: u32,
    pub(crate) p_wait_semaphores: *const Semaphore,
    pub(crate) p_wait_dst_stage_mask: *const PipelineStageFlags,
    pub(crate) command_buffer_count: u32,
    pub(crate) p_command_buffers: *const CommandBuffer,
    pub(crate) signal_semaphore_count: u32,
    pub(crate) p_signal_semaphores: *const Semaphore,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SubmitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SubmitInfo;
}
unsafe impl<'a> Send for SubmitInfo<'a> {}
unsafe impl<'a> Sync for SubmitInfo<'a> {}
impl<'a> Default for SubmitInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            wait_semaphore_count: Default::default(),
            p_wait_semaphores: ptr::null(),
            p_wait_dst_stage_mask: ptr::null(),
            command_buffer_count: Default::default(),
            p_command_buffers: ptr::null(),
            signal_semaphore_count: Default::default(),
            p_signal_semaphores: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubmitInfo<'a> {
    #[inline]
    pub fn wait_semaphore<V0: Alias<raw::Semaphore> + 'a>(
        mut self,
        p_wait_semaphores: impl AsSlice<'a, V0>,
        p_wait_dst_stage_mask: Option<impl AsSlice<'a, PipelineStageFlags>>,
    ) -> Self {
        self.p_wait_semaphores = p_wait_semaphores.as_slice().as_ptr().cast();
        self.p_wait_dst_stage_mask = p_wait_dst_stage_mask
            .map(|p| p.as_slice().as_ptr().cast())
            .unwrap_or(ptr::null());
        self.wait_semaphore_count = p_wait_semaphores.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn command_buffers<V0: Alias<raw::CommandBuffer> + 'a>(
        mut self,
        p_command_buffers: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_command_buffers = p_command_buffers.as_slice().as_ptr().cast();
        self.command_buffer_count = p_command_buffers.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn signal_semaphores<V0: Alias<raw::Semaphore> + 'a>(
        mut self,
        p_signal_semaphores: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_signal_semaphores = p_signal_semaphores.as_slice().as_ptr().cast();
        self.signal_semaphore_count = p_signal_semaphores.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMappedMemoryRange.html>"]
#[doc(alias = "VkMappedMemoryRange")]
pub struct MappedMemoryRange<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory: Option<DeviceMemory>,
    pub offset: DeviceSize,
    pub size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MappedMemoryRange<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MappedMemoryRange;
}
unsafe impl<'a> Send for MappedMemoryRange<'a> {}
unsafe impl<'a> Sync for MappedMemoryRange<'a> {}
impl<'a> Default for MappedMemoryRange<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory: Default::default(),
            offset: Default::default(),
            size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MappedMemoryRange<'a> {
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn offset(mut self, value: DeviceSize) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateInfo.html>"]
#[doc(alias = "VkMemoryAllocateInfo")]
pub struct MemoryAllocateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub allocation_size: DeviceSize,
    pub memory_type_index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryAllocateInfo;
}
unsafe impl<'a> Send for MemoryAllocateInfo<'a> {}
unsafe impl<'a> Sync for MemoryAllocateInfo<'a> {}
impl<'a> Default for MemoryAllocateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            allocation_size: Default::default(),
            memory_type_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryAllocateInfo<'a> {
    #[inline]
    pub fn allocation_size(mut self, value: DeviceSize) -> Self {
        self.allocation_size = value;
        self
    }
    #[inline]
    pub fn memory_type_index(mut self, value: u32) -> Self {
        self.memory_type_index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements.html>"]
#[doc(alias = "VkMemoryRequirements")]
pub struct MemoryRequirements {
    pub size: DeviceSize,
    pub alignment: DeviceSize,
    pub memory_type_bits: u32,
}
unsafe impl Send for MemoryRequirements {}
unsafe impl Sync for MemoryRequirements {}
impl Default for MemoryRequirements {
    fn default() -> Self {
        Self {
            size: Default::default(),
            alignment: Default::default(),
            memory_type_bits: Default::default(),
        }
    }
}
impl MemoryRequirements {
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn alignment(mut self, value: DeviceSize) -> Self {
        self.alignment = value;
        self
    }
    #[inline]
    pub fn memory_type_bits(mut self, value: u32) -> Self {
        self.memory_type_bits = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindSparseInfo.html>"]
#[doc(alias = "VkBindSparseInfo")]
pub struct BindSparseInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) wait_semaphore_count: u32,
    pub(crate) p_wait_semaphores: *const Semaphore,
    pub(crate) buffer_bind_count: u32,
    pub(crate) p_buffer_binds: *const SparseBufferMemoryBindInfo<'a>,
    pub(crate) image_opaque_bind_count: u32,
    pub(crate) p_image_opaque_binds: *const SparseImageOpaqueMemoryBindInfo<'a>,
    pub(crate) image_bind_count: u32,
    pub(crate) p_image_binds: *const SparseImageMemoryBindInfo<'a>,
    pub(crate) signal_semaphore_count: u32,
    pub(crate) p_signal_semaphores: *const Semaphore,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BindSparseInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BindSparseInfo;
}
unsafe impl<'a> Send for BindSparseInfo<'a> {}
unsafe impl<'a> Sync for BindSparseInfo<'a> {}
impl<'a> Default for BindSparseInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            wait_semaphore_count: Default::default(),
            p_wait_semaphores: ptr::null(),
            buffer_bind_count: Default::default(),
            p_buffer_binds: ptr::null(),
            image_opaque_bind_count: Default::default(),
            p_image_opaque_binds: ptr::null(),
            image_bind_count: Default::default(),
            p_image_binds: ptr::null(),
            signal_semaphore_count: Default::default(),
            p_signal_semaphores: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BindSparseInfo<'a> {
    #[inline]
    pub fn wait_semaphores<V0: Alias<raw::Semaphore> + 'a>(
        mut self,
        p_wait_semaphores: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_wait_semaphores = p_wait_semaphores.as_slice().as_ptr().cast();
        self.wait_semaphore_count = p_wait_semaphores.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn buffer_binds(
        mut self,
        p_buffer_binds: impl AsSlice<'a, SparseBufferMemoryBindInfo<'a>>,
    ) -> Self {
        self.p_buffer_binds = p_buffer_binds.as_slice().as_ptr().cast();
        self.buffer_bind_count = p_buffer_binds.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn image_opaque_binds(
        mut self,
        p_image_opaque_binds: impl AsSlice<'a, SparseImageOpaqueMemoryBindInfo<'a>>,
    ) -> Self {
        self.p_image_opaque_binds = p_image_opaque_binds.as_slice().as_ptr().cast();
        self.image_opaque_bind_count = p_image_opaque_binds.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn image_binds(
        mut self,
        p_image_binds: impl AsSlice<'a, SparseImageMemoryBindInfo<'a>>,
    ) -> Self {
        self.p_image_binds = p_image_binds.as_slice().as_ptr().cast();
        self.image_bind_count = p_image_binds.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn signal_semaphores<V0: Alias<raw::Semaphore> + 'a>(
        mut self,
        p_signal_semaphores: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_signal_semaphores = p_signal_semaphores.as_slice().as_ptr().cast();
        self.signal_semaphore_count = p_signal_semaphores.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresource.html>"]
#[doc(alias = "VkImageSubresource")]
pub struct ImageSubresource {
    pub aspect_mask: ImageAspectFlags,
    pub mip_level: u32,
    pub array_layer: u32,
}
unsafe impl Send for ImageSubresource {}
unsafe impl Sync for ImageSubresource {}
impl Default for ImageSubresource {
    fn default() -> Self {
        Self {
            aspect_mask: Default::default(),
            mip_level: Default::default(),
            array_layer: Default::default(),
        }
    }
}
impl ImageSubresource {
    #[inline]
    pub fn aspect_mask(mut self, value: ImageAspectFlags) -> Self {
        self.aspect_mask = value;
        self
    }
    #[inline]
    pub fn mip_level(mut self, value: u32) -> Self {
        self.mip_level = value;
        self
    }
    #[inline]
    pub fn array_layer(mut self, value: u32) -> Self {
        self.array_layer = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseBufferMemoryBindInfo.html>"]
#[doc(alias = "VkSparseBufferMemoryBindInfo")]
pub struct SparseBufferMemoryBindInfo<'a> {
    pub buffer: Option<Buffer>,
    pub(crate) bind_count: u32,
    pub(crate) p_binds: *const SparseMemoryBind<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for SparseBufferMemoryBindInfo<'a> {}
unsafe impl<'a> Sync for SparseBufferMemoryBindInfo<'a> {}
impl<'a> Default for SparseBufferMemoryBindInfo<'a> {
    fn default() -> Self {
        Self {
            buffer: Default::default(),
            bind_count: Default::default(),
            p_binds: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SparseBufferMemoryBindInfo<'a> {
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn binds(mut self, p_binds: impl AsSlice<'a, SparseMemoryBind<'a>>) -> Self {
        self.p_binds = p_binds.as_slice().as_ptr().cast();
        self.bind_count = p_binds.as_slice().len() as _;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatProperties.html>"]
#[doc(alias = "VkSparseImageFormatProperties")]
pub struct SparseImageFormatProperties {
    pub aspect_mask: ImageAspectFlags,
    pub image_granularity: Extent3D,
    pub flags: SparseImageFormatFlags,
}
unsafe impl Send for SparseImageFormatProperties {}
unsafe impl Sync for SparseImageFormatProperties {}
impl Default for SparseImageFormatProperties {
    fn default() -> Self {
        Self {
            aspect_mask: Default::default(),
            image_granularity: Default::default(),
            flags: Default::default(),
        }
    }
}
impl SparseImageFormatProperties {
    #[inline]
    pub fn aspect_mask(mut self, value: ImageAspectFlags) -> Self {
        self.aspect_mask = value;
        self
    }
    #[inline]
    pub fn image_granularity(mut self, value: Extent3D) -> Self {
        self.image_granularity = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: SparseImageFormatFlags) -> Self {
        self.flags = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryBind.html>"]
#[doc(alias = "VkSparseImageMemoryBind")]
pub struct SparseImageMemoryBind<'a> {
    pub subresource: ImageSubresource,
    pub offset: Offset3D,
    pub extent: Extent3D,
    pub memory: Option<DeviceMemory>,
    pub memory_offset: DeviceSize,
    pub flags: SparseMemoryBindFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for SparseImageMemoryBind<'a> {}
unsafe impl<'a> Sync for SparseImageMemoryBind<'a> {}
impl<'a> Default for SparseImageMemoryBind<'a> {
    fn default() -> Self {
        Self {
            subresource: Default::default(),
            offset: Default::default(),
            extent: Default::default(),
            memory: Default::default(),
            memory_offset: Default::default(),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SparseImageMemoryBind<'a> {
    #[inline]
    pub fn subresource(mut self, value: ImageSubresource) -> Self {
        self.subresource = value;
        self
    }
    #[inline]
    pub fn offset(mut self, value: Offset3D) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn extent(mut self, value: Extent3D) -> Self {
        self.extent = value;
        self
    }
    #[inline]
    pub fn memory(mut self, value: Option<&'a DeviceMemory>) -> Self {
        self.memory = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn memory_offset(mut self, value: DeviceSize) -> Self {
        self.memory_offset = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: SparseMemoryBindFlags) -> Self {
        self.flags = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryBindInfo.html>"]
#[doc(alias = "VkSparseImageMemoryBindInfo")]
pub struct SparseImageMemoryBindInfo<'a> {
    pub image: Option<Image>,
    pub(crate) bind_count: u32,
    pub(crate) p_binds: *const SparseImageMemoryBind<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for SparseImageMemoryBindInfo<'a> {}
unsafe impl<'a> Sync for SparseImageMemoryBindInfo<'a> {}
impl<'a> Default for SparseImageMemoryBindInfo<'a> {
    fn default() -> Self {
        Self {
            image: Default::default(),
            bind_count: Default::default(),
            p_binds: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SparseImageMemoryBindInfo<'a> {
    #[inline]
    pub fn image(mut self, value: &'a Image) -> Self {
        self.image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn binds(mut self, p_binds: impl AsSlice<'a, SparseImageMemoryBind<'a>>) -> Self {
        self.p_binds = p_binds.as_slice().as_ptr().cast();
        self.bind_count = p_binds.as_slice().len() as _;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryRequirements.html>"]
#[doc(alias = "VkSparseImageMemoryRequirements")]
pub struct SparseImageMemoryRequirements {
    pub format_properties: SparseImageFormatProperties,
    pub image_mip_tail_first_lod: u32,
    pub image_mip_tail_size: DeviceSize,
    pub image_mip_tail_offset: DeviceSize,
    pub image_mip_tail_stride: DeviceSize,
}
unsafe impl Send for SparseImageMemoryRequirements {}
unsafe impl Sync for SparseImageMemoryRequirements {}
impl Default for SparseImageMemoryRequirements {
    fn default() -> Self {
        Self {
            format_properties: Default::default(),
            image_mip_tail_first_lod: Default::default(),
            image_mip_tail_size: Default::default(),
            image_mip_tail_offset: Default::default(),
            image_mip_tail_stride: Default::default(),
        }
    }
}
impl SparseImageMemoryRequirements {
    #[inline]
    pub fn format_properties(mut self, value: SparseImageFormatProperties) -> Self {
        self.format_properties = value;
        self
    }
    #[inline]
    pub fn image_mip_tail_first_lod(mut self, value: u32) -> Self {
        self.image_mip_tail_first_lod = value;
        self
    }
    #[inline]
    pub fn image_mip_tail_size(mut self, value: DeviceSize) -> Self {
        self.image_mip_tail_size = value;
        self
    }
    #[inline]
    pub fn image_mip_tail_offset(mut self, value: DeviceSize) -> Self {
        self.image_mip_tail_offset = value;
        self
    }
    #[inline]
    pub fn image_mip_tail_stride(mut self, value: DeviceSize) -> Self {
        self.image_mip_tail_stride = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageOpaqueMemoryBindInfo.html>"]
#[doc(alias = "VkSparseImageOpaqueMemoryBindInfo")]
pub struct SparseImageOpaqueMemoryBindInfo<'a> {
    pub image: Option<Image>,
    pub(crate) bind_count: u32,
    pub(crate) p_binds: *const SparseMemoryBind<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for SparseImageOpaqueMemoryBindInfo<'a> {}
unsafe impl<'a> Sync for SparseImageOpaqueMemoryBindInfo<'a> {}
impl<'a> Default for SparseImageOpaqueMemoryBindInfo<'a> {
    fn default() -> Self {
        Self {
            image: Default::default(),
            bind_count: Default::default(),
            p_binds: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SparseImageOpaqueMemoryBindInfo<'a> {
    #[inline]
    pub fn image(mut self, value: &'a Image) -> Self {
        self.image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn binds(mut self, p_binds: impl AsSlice<'a, SparseMemoryBind<'a>>) -> Self {
        self.p_binds = p_binds.as_slice().as_ptr().cast();
        self.bind_count = p_binds.as_slice().len() as _;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseMemoryBind.html>"]
#[doc(alias = "VkSparseMemoryBind")]
pub struct SparseMemoryBind<'a> {
    pub resource_offset: DeviceSize,
    pub size: DeviceSize,
    pub memory: Option<DeviceMemory>,
    pub memory_offset: DeviceSize,
    pub flags: SparseMemoryBindFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for SparseMemoryBind<'a> {}
unsafe impl<'a> Sync for SparseMemoryBind<'a> {}
impl<'a> Default for SparseMemoryBind<'a> {
    fn default() -> Self {
        Self {
            resource_offset: Default::default(),
            size: Default::default(),
            memory: Default::default(),
            memory_offset: Default::default(),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SparseMemoryBind<'a> {
    #[inline]
    pub fn resource_offset(mut self, value: DeviceSize) -> Self {
        self.resource_offset = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn memory(mut self, value: Option<&'a DeviceMemory>) -> Self {
        self.memory = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn memory_offset(mut self, value: DeviceSize) -> Self {
        self.memory_offset = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: SparseMemoryBindFlags) -> Self {
        self.flags = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html>"]
#[doc(alias = "VkFenceCreateInfo")]
pub struct FenceCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: FenceCreateFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for FenceCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FenceCreateInfo;
}
unsafe impl<'a> Send for FenceCreateInfo<'a> {}
unsafe impl<'a> Sync for FenceCreateInfo<'a> {}
impl<'a> Default for FenceCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> FenceCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: FenceCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateInfo.html>"]
#[doc(alias = "VkSemaphoreCreateInfo")]
pub struct SemaphoreCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SemaphoreCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SemaphoreCreateInfo;
}
unsafe impl<'a> Send for SemaphoreCreateInfo<'a> {}
unsafe impl<'a> Sync for SemaphoreCreateInfo<'a> {}
impl<'a> Default for SemaphoreCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SemaphoreCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEventCreateInfo.html>"]
#[doc(alias = "VkEventCreateInfo")]
pub struct EventCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: EventCreateFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for EventCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::EventCreateInfo;
}
unsafe impl<'a> Send for EventCreateInfo<'a> {}
unsafe impl<'a> Sync for EventCreateInfo<'a> {}
impl<'a> Default for EventCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> EventCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: EventCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolCreateInfo.html>"]
#[doc(alias = "VkQueryPoolCreateInfo")]
pub struct QueryPoolCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub query_type: QueryType,
    pub query_count: u32,
    pub pipeline_statistics: QueryPipelineStatisticFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for QueryPoolCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QueryPoolCreateInfo;
}
unsafe impl<'a> Send for QueryPoolCreateInfo<'a> {}
unsafe impl<'a> Sync for QueryPoolCreateInfo<'a> {}
impl<'a> Default for QueryPoolCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            query_type: QueryType::Occlusion,
            query_count: Default::default(),
            pipeline_statistics: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> QueryPoolCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn query_type(mut self, value: QueryType) -> Self {
        self.query_type = value;
        self
    }
    #[inline]
    pub fn query_count(mut self, value: u32) -> Self {
        self.query_count = value;
        self
    }
    #[inline]
    pub fn pipeline_statistics(mut self, value: QueryPipelineStatisticFlags) -> Self {
        self.pipeline_statistics = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCreateInfo.html>"]
#[doc(alias = "VkBufferCreateInfo")]
pub struct BufferCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: BufferCreateFlags,
    pub size: DeviceSize,
    pub usage: BufferUsageFlags,
    pub sharing_mode: SharingMode,
    pub(crate) queue_family_index_count: u32,
    pub(crate) p_queue_family_indices: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferCreateInfo;
}
unsafe impl<'a> Send for BufferCreateInfo<'a> {}
unsafe impl<'a> Sync for BufferCreateInfo<'a> {}
impl<'a> Default for BufferCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            size: Default::default(),
            usage: Default::default(),
            sharing_mode: SharingMode::Exclusive,
            queue_family_index_count: Default::default(),
            p_queue_family_indices: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: BufferCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn usage(mut self, value: BufferUsageFlags) -> Self {
        self.usage = value;
        self
    }
    #[inline]
    pub fn sharing_mode(mut self, value: SharingMode) -> Self {
        self.sharing_mode = value;
        self
    }
    #[inline]
    pub fn queue_family_indices(mut self, p_queue_family_indices: impl AsSlice<'a, u32>) -> Self {
        self.p_queue_family_indices = p_queue_family_indices.as_slice().as_ptr().cast();
        self.queue_family_index_count = p_queue_family_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferViewCreateInfo.html>"]
#[doc(alias = "VkBufferViewCreateInfo")]
pub struct BufferViewCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub buffer: Option<Buffer>,
    pub format: Format,
    pub offset: DeviceSize,
    pub range: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferViewCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferViewCreateInfo;
}
unsafe impl<'a> Send for BufferViewCreateInfo<'a> {}
unsafe impl<'a> Sync for BufferViewCreateInfo<'a> {}
impl<'a> Default for BufferViewCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            buffer: Default::default(),
            format: Format::Undefined,
            offset: Default::default(),
            range: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferViewCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn offset(mut self, value: DeviceSize) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn range(mut self, value: DeviceSize) -> Self {
        self.range = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCreateInfo.html>"]
#[doc(alias = "VkImageCreateInfo")]
pub struct ImageCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: ImageCreateFlags,
    pub image_type: ImageType,
    pub format: Format,
    pub extent: Extent3D,
    pub mip_levels: u32,
    pub array_layers: u32,
    pub samples: SampleCountFlags,
    pub tiling: ImageTiling,
    pub usage: ImageUsageFlags,
    pub sharing_mode: SharingMode,
    pub(crate) queue_family_index_count: u32,
    pub(crate) p_queue_family_indices: *const u32,
    pub initial_layout: ImageLayout,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageCreateInfo;
}
unsafe impl<'a> Send for ImageCreateInfo<'a> {}
unsafe impl<'a> Sync for ImageCreateInfo<'a> {}
impl<'a> Default for ImageCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            image_type: ImageType::Type1D,
            format: Format::Undefined,
            extent: Default::default(),
            mip_levels: Default::default(),
            array_layers: Default::default(),
            samples: Default::default(),
            tiling: ImageTiling::Optimal,
            usage: Default::default(),
            sharing_mode: SharingMode::Exclusive,
            queue_family_index_count: Default::default(),
            p_queue_family_indices: ptr::null(),
            initial_layout: ImageLayout::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: ImageCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn image_type(mut self, value: ImageType) -> Self {
        self.image_type = value;
        self
    }
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn extent(mut self, value: Extent3D) -> Self {
        self.extent = value;
        self
    }
    #[inline]
    pub fn mip_levels(mut self, value: u32) -> Self {
        self.mip_levels = value;
        self
    }
    #[inline]
    pub fn array_layers(mut self, value: u32) -> Self {
        self.array_layers = value;
        self
    }
    #[inline]
    pub fn samples(mut self, value: SampleCountFlags) -> Self {
        self.samples = value;
        self
    }
    #[inline]
    pub fn tiling(mut self, value: ImageTiling) -> Self {
        self.tiling = value;
        self
    }
    #[inline]
    pub fn usage(mut self, value: ImageUsageFlags) -> Self {
        self.usage = value;
        self
    }
    #[inline]
    pub fn sharing_mode(mut self, value: SharingMode) -> Self {
        self.sharing_mode = value;
        self
    }
    #[inline]
    pub fn initial_layout(mut self, value: ImageLayout) -> Self {
        self.initial_layout = value;
        self
    }
    #[inline]
    pub fn queue_family_indices(mut self, p_queue_family_indices: impl AsSlice<'a, u32>) -> Self {
        self.p_queue_family_indices = p_queue_family_indices.as_slice().as_ptr().cast();
        self.queue_family_index_count = p_queue_family_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubresourceLayout.html>"]
#[doc(alias = "VkSubresourceLayout")]
pub struct SubresourceLayout {
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub row_pitch: DeviceSize,
    pub array_pitch: DeviceSize,
    pub depth_pitch: DeviceSize,
}
unsafe impl Send for SubresourceLayout {}
unsafe impl Sync for SubresourceLayout {}
impl Default for SubresourceLayout {
    fn default() -> Self {
        Self {
            offset: Default::default(),
            size: Default::default(),
            row_pitch: Default::default(),
            array_pitch: Default::default(),
            depth_pitch: Default::default(),
        }
    }
}
impl SubresourceLayout {
    #[inline]
    pub fn offset(mut self, value: DeviceSize) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn row_pitch(mut self, value: DeviceSize) -> Self {
        self.row_pitch = value;
        self
    }
    #[inline]
    pub fn array_pitch(mut self, value: DeviceSize) -> Self {
        self.array_pitch = value;
        self
    }
    #[inline]
    pub fn depth_pitch(mut self, value: DeviceSize) -> Self {
        self.depth_pitch = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComponentMapping.html>"]
#[doc(alias = "VkComponentMapping")]
pub struct ComponentMapping {
    pub r: ComponentSwizzle,
    pub g: ComponentSwizzle,
    pub b: ComponentSwizzle,
    pub a: ComponentSwizzle,
}
unsafe impl Send for ComponentMapping {}
unsafe impl Sync for ComponentMapping {}
impl Default for ComponentMapping {
    fn default() -> Self {
        Self {
            r: ComponentSwizzle::Identity,
            g: ComponentSwizzle::Identity,
            b: ComponentSwizzle::Identity,
            a: ComponentSwizzle::Identity,
        }
    }
}
impl ComponentMapping {
    #[inline]
    pub fn r(mut self, value: ComponentSwizzle) -> Self {
        self.r = value;
        self
    }
    #[inline]
    pub fn g(mut self, value: ComponentSwizzle) -> Self {
        self.g = value;
        self
    }
    #[inline]
    pub fn b(mut self, value: ComponentSwizzle) -> Self {
        self.b = value;
        self
    }
    #[inline]
    pub fn a(mut self, value: ComponentSwizzle) -> Self {
        self.a = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html>"]
#[doc(alias = "VkImageSubresourceRange")]
pub struct ImageSubresourceRange {
    pub aspect_mask: ImageAspectFlags,
    pub base_mip_level: u32,
    pub level_count: u32,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
unsafe impl Send for ImageSubresourceRange {}
unsafe impl Sync for ImageSubresourceRange {}
impl Default for ImageSubresourceRange {
    fn default() -> Self {
        Self {
            aspect_mask: Default::default(),
            base_mip_level: Default::default(),
            level_count: Default::default(),
            base_array_layer: Default::default(),
            layer_count: Default::default(),
        }
    }
}
impl ImageSubresourceRange {
    #[inline]
    pub fn aspect_mask(mut self, value: ImageAspectFlags) -> Self {
        self.aspect_mask = value;
        self
    }
    #[inline]
    pub fn base_mip_level(mut self, value: u32) -> Self {
        self.base_mip_level = value;
        self
    }
    #[inline]
    pub fn level_count(mut self, value: u32) -> Self {
        self.level_count = value;
        self
    }
    #[inline]
    pub fn base_array_layer(mut self, value: u32) -> Self {
        self.base_array_layer = value;
        self
    }
    #[inline]
    pub fn layer_count(mut self, value: u32) -> Self {
        self.layer_count = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html>"]
#[doc(alias = "VkImageViewCreateInfo")]
pub struct ImageViewCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: ImageViewCreateFlags,
    pub image: Option<Image>,
    pub view_type: ImageViewType,
    pub format: Format,
    pub components: ComponentMapping,
    pub subresource_range: ImageSubresourceRange,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageViewCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageViewCreateInfo;
}
unsafe impl<'a> Send for ImageViewCreateInfo<'a> {}
unsafe impl<'a> Sync for ImageViewCreateInfo<'a> {}
impl<'a> Default for ImageViewCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            image: Default::default(),
            view_type: ImageViewType::Type1D,
            format: Format::Undefined,
            components: Default::default(),
            subresource_range: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageViewCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: ImageViewCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn image(mut self, value: &'a Image) -> Self {
        self.image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn view_type(mut self, value: ImageViewType) -> Self {
        self.view_type = value;
        self
    }
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn components(mut self, value: ComponentMapping) -> Self {
        self.components = value;
        self
    }
    #[inline]
    pub fn subresource_range(mut self, value: ImageSubresourceRange) -> Self {
        self.subresource_range = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html>"]
#[doc(alias = "VkShaderModuleCreateInfo")]
pub struct ShaderModuleCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub(crate) code_size: usize,
    pub(crate) p_code: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ShaderModuleCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ShaderModuleCreateInfo;
}
unsafe impl<'a> Send for ShaderModuleCreateInfo<'a> {}
unsafe impl<'a> Sync for ShaderModuleCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineShaderStageCreateInfo<'b>>
    for ShaderModuleCreateInfo<'a>
{
}
impl<'a> Default for ShaderModuleCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            code_size: Default::default(),
            p_code: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ShaderModuleCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn code(mut self, value: &'a [u32]) -> Self {
        self.p_code = value.as_ptr();
        self.code_size = value.len() * 4;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheCreateInfo.html>"]
#[doc(alias = "VkPipelineCacheCreateInfo")]
pub struct PipelineCacheCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: PipelineCacheCreateFlags,
    pub(crate) initial_data_size: usize,
    pub(crate) p_initial_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineCacheCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineCacheCreateInfo;
}
unsafe impl<'a> Send for PipelineCacheCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineCacheCreateInfo<'a> {}
impl<'a> Default for PipelineCacheCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            initial_data_size: Default::default(),
            p_initial_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineCacheCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: PipelineCacheCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn initial_data(mut self, p_initial_data: impl AsSlice<'a, u8>) -> Self {
        self.p_initial_data = p_initial_data.as_slice().as_ptr().cast();
        self.initial_data_size = p_initial_data.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComputePipelineCreateInfo.html>"]
#[doc(alias = "VkComputePipelineCreateInfo")]
pub struct ComputePipelineCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: PipelineCreateFlags,
    pub stage: PipelineShaderStageCreateInfo<'a>,
    pub layout: Option<PipelineLayout>,
    pub base_pipeline_handle: Option<Pipeline>,
    pub base_pipeline_index: i32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ComputePipelineCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ComputePipelineCreateInfo;
}
unsafe impl<'a> Send for ComputePipelineCreateInfo<'a> {}
unsafe impl<'a> Sync for ComputePipelineCreateInfo<'a> {}
impl<'a> Default for ComputePipelineCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            stage: Default::default(),
            layout: Default::default(),
            base_pipeline_handle: Default::default(),
            base_pipeline_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ComputePipelineCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: PipelineCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn stage(mut self, value: PipelineShaderStageCreateInfo<'a>) -> Self {
        self.stage = value;
        self
    }
    #[inline]
    pub fn layout(mut self, value: &'a PipelineLayout) -> Self {
        self.layout = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, value: Option<&'a Pipeline>) -> Self {
        self.base_pipeline_handle = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, value: i32) -> Self {
        self.base_pipeline_index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineCreateInfo.html>"]
#[doc(alias = "VkGraphicsPipelineCreateInfo")]
pub struct GraphicsPipelineCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    pub(crate) p_stages: *const PipelineShaderStageCreateInfo<'a>,
    pub p_vertex_input_state: *const PipelineVertexInputStateCreateInfo<'a>,
    pub p_input_assembly_state: *const PipelineInputAssemblyStateCreateInfo<'a>,
    pub p_tessellation_state: *const PipelineTessellationStateCreateInfo<'a>,
    pub p_viewport_state: *const PipelineViewportStateCreateInfo<'a>,
    pub p_rasterization_state: *const PipelineRasterizationStateCreateInfo<'a>,
    pub p_multisample_state: *const PipelineMultisampleStateCreateInfo<'a>,
    pub p_depth_stencil_state: *const PipelineDepthStencilStateCreateInfo<'a>,
    pub p_color_blend_state: *const PipelineColorBlendStateCreateInfo<'a>,
    pub p_dynamic_state: *const PipelineDynamicStateCreateInfo<'a>,
    pub layout: Option<PipelineLayout>,
    pub render_pass: Option<RenderPass>,
    pub subpass: u32,
    pub base_pipeline_handle: Option<Pipeline>,
    pub base_pipeline_index: i32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for GraphicsPipelineCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GraphicsPipelineCreateInfo;
}
unsafe impl<'a> Send for GraphicsPipelineCreateInfo<'a> {}
unsafe impl<'a> Sync for GraphicsPipelineCreateInfo<'a> {}
impl<'a> Default for GraphicsPipelineCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            stage_count: Default::default(),
            p_stages: ptr::null(),
            p_vertex_input_state: ptr::null(),
            p_input_assembly_state: ptr::null(),
            p_tessellation_state: ptr::null(),
            p_viewport_state: ptr::null(),
            p_rasterization_state: ptr::null(),
            p_multisample_state: ptr::null(),
            p_depth_stencil_state: ptr::null(),
            p_color_blend_state: ptr::null(),
            p_dynamic_state: ptr::null(),
            layout: Default::default(),
            render_pass: Default::default(),
            subpass: Default::default(),
            base_pipeline_handle: Default::default(),
            base_pipeline_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> GraphicsPipelineCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: PipelineCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn stage_count(mut self, value: u32) -> Self {
        self.stage_count = value;
        self
    }
    #[inline]
    pub fn vertex_input_state(
        mut self,
        value: Option<&'a PipelineVertexInputStateCreateInfo<'a>>,
    ) -> Self {
        self.p_vertex_input_state = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn input_assembly_state(
        mut self,
        value: Option<&'a PipelineInputAssemblyStateCreateInfo<'a>>,
    ) -> Self {
        self.p_input_assembly_state = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn tessellation_state(
        mut self,
        value: Option<&'a PipelineTessellationStateCreateInfo<'a>>,
    ) -> Self {
        self.p_tessellation_state = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn viewport_state(
        mut self,
        value: Option<&'a PipelineViewportStateCreateInfo<'a>>,
    ) -> Self {
        self.p_viewport_state = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn rasterization_state(
        mut self,
        value: Option<&'a PipelineRasterizationStateCreateInfo<'a>>,
    ) -> Self {
        self.p_rasterization_state = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn multisample_state(
        mut self,
        value: Option<&'a PipelineMultisampleStateCreateInfo<'a>>,
    ) -> Self {
        self.p_multisample_state = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn depth_stencil_state(
        mut self,
        value: Option<&'a PipelineDepthStencilStateCreateInfo<'a>>,
    ) -> Self {
        self.p_depth_stencil_state = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn color_blend_state(
        mut self,
        value: Option<&'a PipelineColorBlendStateCreateInfo<'a>>,
    ) -> Self {
        self.p_color_blend_state = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn dynamic_state(mut self, value: Option<&'a PipelineDynamicStateCreateInfo<'a>>) -> Self {
        self.p_dynamic_state = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn layout(mut self, value: Option<&'a PipelineLayout>) -> Self {
        self.layout = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn render_pass(mut self, value: Option<&'a RenderPass>) -> Self {
        self.render_pass = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn subpass(mut self, value: u32) -> Self {
        self.subpass = value;
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, value: Option<&'a Pipeline>) -> Self {
        self.base_pipeline_handle = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, value: i32) -> Self {
        self.base_pipeline_index = value;
        self
    }
    #[inline]
    pub fn stages(mut self, p_stages: impl AsSlice<'a, PipelineShaderStageCreateInfo<'a>>) -> Self {
        self.p_stages = p_stages.as_slice().as_ptr().cast();
        self.stage_count = p_stages.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendAttachmentState.html>"]
#[doc(alias = "VkPipelineColorBlendAttachmentState")]
pub struct PipelineColorBlendAttachmentState {
    pub blend_enable: Bool32,
    pub src_color_blend_factor: BlendFactor,
    pub dst_color_blend_factor: BlendFactor,
    pub color_blend_op: BlendOp,
    pub src_alpha_blend_factor: BlendFactor,
    pub dst_alpha_blend_factor: BlendFactor,
    pub alpha_blend_op: BlendOp,
    pub color_write_mask: ColorComponentFlags,
}
unsafe impl Send for PipelineColorBlendAttachmentState {}
unsafe impl Sync for PipelineColorBlendAttachmentState {}
impl Default for PipelineColorBlendAttachmentState {
    fn default() -> Self {
        Self {
            blend_enable: Default::default(),
            src_color_blend_factor: BlendFactor::Zero,
            dst_color_blend_factor: BlendFactor::Zero,
            color_blend_op: BlendOp::Add,
            src_alpha_blend_factor: BlendFactor::Zero,
            dst_alpha_blend_factor: BlendFactor::Zero,
            alpha_blend_op: BlendOp::Add,
            color_write_mask: Default::default(),
        }
    }
}
impl PipelineColorBlendAttachmentState {
    #[inline]
    pub fn blend_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.blend_enable = value.into();
        self
    }
    #[inline]
    pub fn src_color_blend_factor(mut self, value: BlendFactor) -> Self {
        self.src_color_blend_factor = value;
        self
    }
    #[inline]
    pub fn dst_color_blend_factor(mut self, value: BlendFactor) -> Self {
        self.dst_color_blend_factor = value;
        self
    }
    #[inline]
    pub fn color_blend_op(mut self, value: BlendOp) -> Self {
        self.color_blend_op = value;
        self
    }
    #[inline]
    pub fn src_alpha_blend_factor(mut self, value: BlendFactor) -> Self {
        self.src_alpha_blend_factor = value;
        self
    }
    #[inline]
    pub fn dst_alpha_blend_factor(mut self, value: BlendFactor) -> Self {
        self.dst_alpha_blend_factor = value;
        self
    }
    #[inline]
    pub fn alpha_blend_op(mut self, value: BlendOp) -> Self {
        self.alpha_blend_op = value;
        self
    }
    #[inline]
    pub fn color_write_mask(mut self, value: ColorComponentFlags) -> Self {
        self.color_write_mask = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateInfo.html>"]
#[doc(alias = "VkPipelineColorBlendStateCreateInfo")]
pub struct PipelineColorBlendStateCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: PipelineColorBlendStateCreateFlags,
    pub logic_op_enable: Bool32,
    pub logic_op: LogicOp,
    pub attachment_count: u32,
    pub(crate) p_attachments: *const PipelineColorBlendAttachmentState,
    pub blend_constants: [f32; 4u16 as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineColorBlendStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineColorBlendStateCreateInfo;
}
unsafe impl<'a> Send for PipelineColorBlendStateCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineColorBlendStateCreateInfo<'a> {}
impl<'a> Default for PipelineColorBlendStateCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            logic_op_enable: Default::default(),
            logic_op: LogicOp::Clear,
            attachment_count: Default::default(),
            p_attachments: ptr::null(),
            blend_constants: array::from_fn(|_| Default::default()),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineColorBlendStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: PipelineColorBlendStateCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn logic_op_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.logic_op_enable = value.into();
        self
    }
    #[inline]
    pub fn logic_op(mut self, value: LogicOp) -> Self {
        self.logic_op = value;
        self
    }
    #[inline]
    pub fn attachment_count(mut self, value: u32) -> Self {
        self.attachment_count = value;
        self
    }
    #[inline]
    pub fn blend_constants(mut self, value: [f32; 4u16 as _]) -> Self {
        self.blend_constants = value;
        self
    }
    #[inline]
    pub fn attachments(
        mut self,
        p_attachments: impl AsSlice<'a, PipelineColorBlendAttachmentState>,
    ) -> Self {
        self.p_attachments = p_attachments.as_slice().as_ptr().cast();
        self.attachment_count = p_attachments.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDepthStencilStateCreateInfo.html>"]
#[doc(alias = "VkPipelineDepthStencilStateCreateInfo")]
pub struct PipelineDepthStencilStateCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: PipelineDepthStencilStateCreateFlags,
    pub depth_test_enable: Bool32,
    pub depth_write_enable: Bool32,
    pub depth_compare_op: CompareOp,
    pub depth_bounds_test_enable: Bool32,
    pub stencil_test_enable: Bool32,
    pub front: StencilOpState,
    pub back: StencilOpState,
    pub min_depth_bounds: f32,
    pub max_depth_bounds: f32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineDepthStencilStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineDepthStencilStateCreateInfo;
}
unsafe impl<'a> Send for PipelineDepthStencilStateCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineDepthStencilStateCreateInfo<'a> {}
impl<'a> Default for PipelineDepthStencilStateCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            depth_test_enable: Default::default(),
            depth_write_enable: Default::default(),
            depth_compare_op: CompareOp::Never,
            depth_bounds_test_enable: Default::default(),
            stencil_test_enable: Default::default(),
            front: Default::default(),
            back: Default::default(),
            min_depth_bounds: Default::default(),
            max_depth_bounds: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineDepthStencilStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: PipelineDepthStencilStateCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn depth_test_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_test_enable = value.into();
        self
    }
    #[inline]
    pub fn depth_write_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_write_enable = value.into();
        self
    }
    #[inline]
    pub fn depth_compare_op(mut self, value: CompareOp) -> Self {
        self.depth_compare_op = value;
        self
    }
    #[inline]
    pub fn depth_bounds_test_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_bounds_test_enable = value.into();
        self
    }
    #[inline]
    pub fn stencil_test_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.stencil_test_enable = value.into();
        self
    }
    #[inline]
    pub fn front(mut self, value: StencilOpState) -> Self {
        self.front = value;
        self
    }
    #[inline]
    pub fn back(mut self, value: StencilOpState) -> Self {
        self.back = value;
        self
    }
    #[inline]
    pub fn min_depth_bounds(mut self, value: f32) -> Self {
        self.min_depth_bounds = value;
        self
    }
    #[inline]
    pub fn max_depth_bounds(mut self, value: f32) -> Self {
        self.max_depth_bounds = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateInfo.html>"]
#[doc(alias = "VkPipelineDynamicStateCreateInfo")]
pub struct PipelineDynamicStateCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub(crate) dynamic_state_count: u32,
    pub(crate) p_dynamic_states: *const DynamicState,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineDynamicStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineDynamicStateCreateInfo;
}
unsafe impl<'a> Send for PipelineDynamicStateCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineDynamicStateCreateInfo<'a> {}
impl<'a> Default for PipelineDynamicStateCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            dynamic_state_count: Default::default(),
            p_dynamic_states: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineDynamicStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn dynamic_states(mut self, p_dynamic_states: impl AsSlice<'a, DynamicState>) -> Self {
        self.p_dynamic_states = p_dynamic_states.as_slice().as_ptr().cast();
        self.dynamic_state_count = p_dynamic_states.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateInfo.html>"]
#[doc(alias = "VkPipelineInputAssemblyStateCreateInfo")]
pub struct PipelineInputAssemblyStateCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub topology: PrimitiveTopology,
    pub primitive_restart_enable: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineInputAssemblyStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineInputAssemblyStateCreateInfo;
}
unsafe impl<'a> Send for PipelineInputAssemblyStateCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineInputAssemblyStateCreateInfo<'a> {}
impl<'a> Default for PipelineInputAssemblyStateCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            topology: PrimitiveTopology::PointList,
            primitive_restart_enable: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineInputAssemblyStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn topology(mut self, value: PrimitiveTopology) -> Self {
        self.topology = value;
        self
    }
    #[inline]
    pub fn primitive_restart_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.primitive_restart_enable = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateInfo.html>"]
#[doc(alias = "VkPipelineMultisampleStateCreateInfo")]
pub struct PipelineMultisampleStateCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub(crate) rasterization_samples: SampleCountFlags,
    pub sample_shading_enable: Bool32,
    pub min_sample_shading: f32,
    pub(crate) p_sample_mask: *const SampleMask,
    pub alpha_to_coverage_enable: Bool32,
    pub alpha_to_one_enable: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineMultisampleStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineMultisampleStateCreateInfo;
}
unsafe impl<'a> Send for PipelineMultisampleStateCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineMultisampleStateCreateInfo<'a> {}
impl<'a> Default for PipelineMultisampleStateCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            rasterization_samples: Default::default(),
            sample_shading_enable: Default::default(),
            min_sample_shading: Default::default(),
            p_sample_mask: ptr::null(),
            alpha_to_coverage_enable: Default::default(),
            alpha_to_one_enable: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineMultisampleStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn sample_shading_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.sample_shading_enable = value.into();
        self
    }
    #[inline]
    pub fn min_sample_shading(mut self, value: f32) -> Self {
        self.min_sample_shading = value;
        self
    }
    #[inline]
    pub fn alpha_to_coverage_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.alpha_to_coverage_enable = value.into();
        self
    }
    #[inline]
    pub fn alpha_to_one_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.alpha_to_one_enable = value.into();
        self
    }
    #[inline]
    pub fn rasterization_samples_with_mask(
        mut self,
        samples: SampleCountFlags,
        mask: Option<&'a [u32]>,
    ) -> Self {
        let count = samples.bits();
        assert!(count.is_power_of_two());
        assert!(mask.is_none() || mask.is_some_and(|arr| arr.len() as u32 == (count + 31) / 32));
        self.rasterization_samples = samples;
        self.p_sample_mask = mask.map(|arr| arr.as_ptr()).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html>"]
#[doc(alias = "VkPipelineRasterizationStateCreateInfo")]
pub struct PipelineRasterizationStateCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub depth_clamp_enable: Bool32,
    pub rasterizer_discard_enable: Bool32,
    pub polygon_mode: PolygonMode,
    pub cull_mode: CullModeFlags,
    pub front_face: FrontFace,
    pub depth_bias_enable: Bool32,
    pub depth_bias_constant_factor: f32,
    pub depth_bias_clamp: f32,
    pub depth_bias_slope_factor: f32,
    pub line_width: f32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineRasterizationStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineRasterizationStateCreateInfo;
}
unsafe impl<'a> Send for PipelineRasterizationStateCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineRasterizationStateCreateInfo<'a> {}
impl<'a> Default for PipelineRasterizationStateCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            depth_clamp_enable: Default::default(),
            rasterizer_discard_enable: Default::default(),
            polygon_mode: PolygonMode::Fill,
            cull_mode: Default::default(),
            front_face: FrontFace::CounterClockwise,
            depth_bias_enable: Default::default(),
            depth_bias_constant_factor: Default::default(),
            depth_bias_clamp: Default::default(),
            depth_bias_slope_factor: Default::default(),
            line_width: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineRasterizationStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn depth_clamp_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_clamp_enable = value.into();
        self
    }
    #[inline]
    pub fn rasterizer_discard_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.rasterizer_discard_enable = value.into();
        self
    }
    #[inline]
    pub fn polygon_mode(mut self, value: PolygonMode) -> Self {
        self.polygon_mode = value;
        self
    }
    #[inline]
    pub fn cull_mode(mut self, value: CullModeFlags) -> Self {
        self.cull_mode = value;
        self
    }
    #[inline]
    pub fn front_face(mut self, value: FrontFace) -> Self {
        self.front_face = value;
        self
    }
    #[inline]
    pub fn depth_bias_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_bias_enable = value.into();
        self
    }
    #[inline]
    pub fn depth_bias_constant_factor(mut self, value: f32) -> Self {
        self.depth_bias_constant_factor = value;
        self
    }
    #[inline]
    pub fn depth_bias_clamp(mut self, value: f32) -> Self {
        self.depth_bias_clamp = value;
        self
    }
    #[inline]
    pub fn depth_bias_slope_factor(mut self, value: f32) -> Self {
        self.depth_bias_slope_factor = value;
        self
    }
    #[inline]
    pub fn line_width(mut self, value: f32) -> Self {
        self.line_width = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html>"]
#[doc(alias = "VkPipelineShaderStageCreateInfo")]
pub struct PipelineShaderStageCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: PipelineShaderStageCreateFlags,
    pub stage: ShaderStageFlags,
    pub module: Option<ShaderModule>,
    pub p_name: *const c_char,
    pub p_specialization_info: *const SpecializationInfo<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineShaderStageCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineShaderStageCreateInfo;
}
unsafe impl<'a> Send for PipelineShaderStageCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineShaderStageCreateInfo<'a> {}
impl<'a> Default for PipelineShaderStageCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            stage: Default::default(),
            module: Default::default(),
            p_name: ptr::null(),
            p_specialization_info: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineShaderStageCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: PipelineShaderStageCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn stage(mut self, value: ShaderStageFlags) -> Self {
        self.stage = value;
        self
    }
    #[inline]
    pub fn module(mut self, value: Option<&'a ShaderModule>) -> Self {
        self.module = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn name(mut self, value: &'a CStr) -> Self {
        self.p_name = value.as_ptr();
        self
    }
    #[inline]
    pub fn specialization_info(mut self, value: Option<&'a SpecializationInfo<'a>>) -> Self {
        self.p_specialization_info = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationStateCreateInfo.html>"]
#[doc(alias = "VkPipelineTessellationStateCreateInfo")]
pub struct PipelineTessellationStateCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub patch_control_points: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineTessellationStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineTessellationStateCreateInfo;
}
unsafe impl<'a> Send for PipelineTessellationStateCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineTessellationStateCreateInfo<'a> {}
impl<'a> Default for PipelineTessellationStateCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            patch_control_points: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineTessellationStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn patch_control_points(mut self, value: u32) -> Self {
        self.patch_control_points = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputStateCreateInfo.html>"]
#[doc(alias = "VkPipelineVertexInputStateCreateInfo")]
pub struct PipelineVertexInputStateCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub(crate) vertex_binding_description_count: u32,
    pub(crate) p_vertex_binding_descriptions: *const VertexInputBindingDescription,
    pub(crate) vertex_attribute_description_count: u32,
    pub(crate) p_vertex_attribute_descriptions: *const VertexInputAttributeDescription,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineVertexInputStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineVertexInputStateCreateInfo;
}
unsafe impl<'a> Send for PipelineVertexInputStateCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineVertexInputStateCreateInfo<'a> {}
impl<'a> Default for PipelineVertexInputStateCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            vertex_binding_description_count: Default::default(),
            p_vertex_binding_descriptions: ptr::null(),
            vertex_attribute_description_count: Default::default(),
            p_vertex_attribute_descriptions: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineVertexInputStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn vertex_binding_descriptions(
        mut self,
        p_vertex_binding_descriptions: impl AsSlice<'a, VertexInputBindingDescription>,
    ) -> Self {
        self.p_vertex_binding_descriptions =
            p_vertex_binding_descriptions.as_slice().as_ptr().cast();
        self.vertex_binding_description_count = p_vertex_binding_descriptions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn vertex_attribute_descriptions(
        mut self,
        p_vertex_attribute_descriptions: impl AsSlice<'a, VertexInputAttributeDescription>,
    ) -> Self {
        self.p_vertex_attribute_descriptions =
            p_vertex_attribute_descriptions.as_slice().as_ptr().cast();
        self.vertex_attribute_description_count =
            p_vertex_attribute_descriptions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateInfo.html>"]
#[doc(alias = "VkPipelineViewportStateCreateInfo")]
pub struct PipelineViewportStateCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub viewport_count: u32,
    pub(crate) p_viewports: *const Viewport,
    pub scissor_count: u32,
    pub(crate) p_scissors: *const Rect2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineViewportStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineViewportStateCreateInfo;
}
unsafe impl<'a> Send for PipelineViewportStateCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineViewportStateCreateInfo<'a> {}
impl<'a> Default for PipelineViewportStateCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            viewport_count: Default::default(),
            p_viewports: ptr::null(),
            scissor_count: Default::default(),
            p_scissors: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineViewportStateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn viewport_count(mut self, value: u32) -> Self {
        self.viewport_count = value;
        self
    }
    #[inline]
    pub fn scissor_count(mut self, value: u32) -> Self {
        self.scissor_count = value;
        self
    }
    #[inline]
    pub fn viewports(mut self, p_viewports: impl AsSlice<'a, Viewport>) -> Self {
        self.p_viewports = p_viewports.as_slice().as_ptr().cast();
        self.viewport_count = p_viewports.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn scissors(mut self, p_scissors: impl AsSlice<'a, Rect2D>) -> Self {
        self.p_scissors = p_scissors.as_slice().as_ptr().cast();
        self.scissor_count = p_scissors.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleMask.html>"]
#[doc(alias = "VkSampleMask")]
pub type SampleMask = u32;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSpecializationInfo.html>"]
#[doc(alias = "VkSpecializationInfo")]
pub struct SpecializationInfo<'a> {
    pub(crate) map_entry_count: u32,
    pub(crate) p_map_entries: *const SpecializationMapEntry,
    pub(crate) data_size: usize,
    pub(crate) p_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for SpecializationInfo<'a> {}
unsafe impl<'a> Sync for SpecializationInfo<'a> {}
impl<'a> Default for SpecializationInfo<'a> {
    fn default() -> Self {
        Self {
            map_entry_count: Default::default(),
            p_map_entries: ptr::null(),
            data_size: Default::default(),
            p_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SpecializationInfo<'a> {
    #[inline]
    pub fn map_entries(mut self, p_map_entries: impl AsSlice<'a, SpecializationMapEntry>) -> Self {
        self.p_map_entries = p_map_entries.as_slice().as_ptr().cast();
        self.map_entry_count = p_map_entries.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn data(mut self, p_data: impl AsSlice<'a, u8>) -> Self {
        self.p_data = p_data.as_slice().as_ptr().cast();
        self.data_size = p_data.as_slice().len() as _;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSpecializationMapEntry.html>"]
#[doc(alias = "VkSpecializationMapEntry")]
pub struct SpecializationMapEntry {
    pub constant_id: u32,
    pub offset: u32,
    pub size: usize,
}
unsafe impl Send for SpecializationMapEntry {}
unsafe impl Sync for SpecializationMapEntry {}
impl Default for SpecializationMapEntry {
    fn default() -> Self {
        Self {
            constant_id: Default::default(),
            offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl SpecializationMapEntry {
    #[inline]
    pub fn constant_id(mut self, value: u32) -> Self {
        self.constant_id = value;
        self
    }
    #[inline]
    pub fn offset(mut self, value: u32) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: usize) -> Self {
        self.size = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilOpState.html>"]
#[doc(alias = "VkStencilOpState")]
pub struct StencilOpState {
    pub fail_op: StencilOp,
    pub pass_op: StencilOp,
    pub depth_fail_op: StencilOp,
    pub compare_op: CompareOp,
    pub compare_mask: u32,
    pub write_mask: u32,
    pub reference: u32,
}
unsafe impl Send for StencilOpState {}
unsafe impl Sync for StencilOpState {}
impl Default for StencilOpState {
    fn default() -> Self {
        Self {
            fail_op: StencilOp::Keep,
            pass_op: StencilOp::Keep,
            depth_fail_op: StencilOp::Keep,
            compare_op: CompareOp::Never,
            compare_mask: Default::default(),
            write_mask: Default::default(),
            reference: Default::default(),
        }
    }
}
impl StencilOpState {
    #[inline]
    pub fn fail_op(mut self, value: StencilOp) -> Self {
        self.fail_op = value;
        self
    }
    #[inline]
    pub fn pass_op(mut self, value: StencilOp) -> Self {
        self.pass_op = value;
        self
    }
    #[inline]
    pub fn depth_fail_op(mut self, value: StencilOp) -> Self {
        self.depth_fail_op = value;
        self
    }
    #[inline]
    pub fn compare_op(mut self, value: CompareOp) -> Self {
        self.compare_op = value;
        self
    }
    #[inline]
    pub fn compare_mask(mut self, value: u32) -> Self {
        self.compare_mask = value;
        self
    }
    #[inline]
    pub fn write_mask(mut self, value: u32) -> Self {
        self.write_mask = value;
        self
    }
    #[inline]
    pub fn reference(mut self, value: u32) -> Self {
        self.reference = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription.html>"]
#[doc(alias = "VkVertexInputAttributeDescription")]
pub struct VertexInputAttributeDescription {
    pub location: u32,
    pub binding: u32,
    pub format: Format,
    pub offset: u32,
}
unsafe impl Send for VertexInputAttributeDescription {}
unsafe impl Sync for VertexInputAttributeDescription {}
impl Default for VertexInputAttributeDescription {
    fn default() -> Self {
        Self {
            location: Default::default(),
            binding: Default::default(),
            format: Format::Undefined,
            offset: Default::default(),
        }
    }
}
impl VertexInputAttributeDescription {
    #[inline]
    pub fn location(mut self, value: u32) -> Self {
        self.location = value;
        self
    }
    #[inline]
    pub fn binding(mut self, value: u32) -> Self {
        self.binding = value;
        self
    }
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn offset(mut self, value: u32) -> Self {
        self.offset = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDescription.html>"]
#[doc(alias = "VkVertexInputBindingDescription")]
pub struct VertexInputBindingDescription {
    pub binding: u32,
    pub stride: u32,
    pub input_rate: VertexInputRate,
}
unsafe impl Send for VertexInputBindingDescription {}
unsafe impl Sync for VertexInputBindingDescription {}
impl Default for VertexInputBindingDescription {
    fn default() -> Self {
        Self {
            binding: Default::default(),
            stride: Default::default(),
            input_rate: VertexInputRate::Vertex,
        }
    }
}
impl VertexInputBindingDescription {
    #[inline]
    pub fn binding(mut self, value: u32) -> Self {
        self.binding = value;
        self
    }
    #[inline]
    pub fn stride(mut self, value: u32) -> Self {
        self.stride = value;
        self
    }
    #[inline]
    pub fn input_rate(mut self, value: VertexInputRate) -> Self {
        self.input_rate = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViewport.html>"]
#[doc(alias = "VkViewport")]
pub struct Viewport {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub min_depth: f32,
    pub max_depth: f32,
}
unsafe impl Send for Viewport {}
unsafe impl Sync for Viewport {}
impl Default for Viewport {
    fn default() -> Self {
        Self {
            x: Default::default(),
            y: Default::default(),
            width: Default::default(),
            height: Default::default(),
            min_depth: Default::default(),
            max_depth: Default::default(),
        }
    }
}
impl Viewport {
    #[inline]
    pub fn x(mut self, value: f32) -> Self {
        self.x = value;
        self
    }
    #[inline]
    pub fn y(mut self, value: f32) -> Self {
        self.y = value;
        self
    }
    #[inline]
    pub fn width(mut self, value: f32) -> Self {
        self.width = value;
        self
    }
    #[inline]
    pub fn height(mut self, value: f32) -> Self {
        self.height = value;
        self
    }
    #[inline]
    pub fn min_depth(mut self, value: f32) -> Self {
        self.min_depth = value;
        self
    }
    #[inline]
    pub fn max_depth(mut self, value: f32) -> Self {
        self.max_depth = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateInfo.html>"]
#[doc(alias = "VkPipelineLayoutCreateInfo")]
pub struct PipelineLayoutCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: PipelineLayoutCreateFlags,
    pub set_layout_count: u32,
    pub(crate) p_set_layouts: *const DescriptorSetLayout,
    pub(crate) push_constant_range_count: u32,
    pub(crate) p_push_constant_ranges: *const PushConstantRange,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineLayoutCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineLayoutCreateInfo;
}
unsafe impl<'a> Send for PipelineLayoutCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineLayoutCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BindDescriptorSetsInfoKHR<'b>>
    for PipelineLayoutCreateInfo<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<PushConstantsInfoKHR<'b>> for PipelineLayoutCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PushDescriptorSetInfoKHR<'b>>
    for PipelineLayoutCreateInfo<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<PushDescriptorSetWithTemplateInfoKHR<'b>>
    for PipelineLayoutCreateInfo<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<SetDescriptorBufferOffsetsInfoEXT<'b>>
    for PipelineLayoutCreateInfo<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<BindDescriptorBufferEmbeddedSamplersInfoEXT<'b>>
    for PipelineLayoutCreateInfo<'a>
{
}
impl<'a> Default for PipelineLayoutCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            set_layout_count: Default::default(),
            p_set_layouts: ptr::null(),
            push_constant_range_count: Default::default(),
            p_push_constant_ranges: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineLayoutCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: PipelineLayoutCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn set_layout_count(mut self, value: u32) -> Self {
        self.set_layout_count = value;
        self
    }
    #[inline]
    pub fn set_layouts<V0: Alias<raw::DescriptorSetLayout> + 'a>(
        mut self,
        p_set_layouts: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_set_layouts = p_set_layouts.as_slice().as_ptr().cast();
        self.set_layout_count = p_set_layouts.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_constant_ranges(
        mut self,
        p_push_constant_ranges: impl AsSlice<'a, PushConstantRange>,
    ) -> Self {
        self.p_push_constant_ranges = p_push_constant_ranges.as_slice().as_ptr().cast();
        self.push_constant_range_count = p_push_constant_ranges.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPushConstantRange.html>"]
#[doc(alias = "VkPushConstantRange")]
pub struct PushConstantRange {
    pub stage_flags: ShaderStageFlags,
    pub offset: u32,
    pub size: u32,
}
unsafe impl Send for PushConstantRange {}
unsafe impl Sync for PushConstantRange {}
impl Default for PushConstantRange {
    fn default() -> Self {
        Self {
            stage_flags: Default::default(),
            offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl PushConstantRange {
    #[inline]
    pub fn stage_flags(mut self, value: ShaderStageFlags) -> Self {
        self.stage_flags = value;
        self
    }
    #[inline]
    pub fn offset(mut self, value: u32) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: u32) -> Self {
        self.size = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCreateInfo.html>"]
#[doc(alias = "VkSamplerCreateInfo")]
pub struct SamplerCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: SamplerCreateFlags,
    pub mag_filter: Filter,
    pub min_filter: Filter,
    pub mipmap_mode: SamplerMipmapMode,
    pub address_mode_u: SamplerAddressMode,
    pub address_mode_v: SamplerAddressMode,
    pub address_mode_w: SamplerAddressMode,
    pub mip_lod_bias: f32,
    pub anisotropy_enable: Bool32,
    pub max_anisotropy: f32,
    pub compare_enable: Bool32,
    pub compare_op: CompareOp,
    pub min_lod: f32,
    pub max_lod: f32,
    pub border_color: BorderColor,
    pub unnormalized_coordinates: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SamplerCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SamplerCreateInfo;
}
unsafe impl<'a> Send for SamplerCreateInfo<'a> {}
unsafe impl<'a> Sync for SamplerCreateInfo<'a> {}
impl<'a> Default for SamplerCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            mag_filter: Filter::Nearest,
            min_filter: Filter::Nearest,
            mipmap_mode: SamplerMipmapMode::Nearest,
            address_mode_u: SamplerAddressMode::Repeat,
            address_mode_v: SamplerAddressMode::Repeat,
            address_mode_w: SamplerAddressMode::Repeat,
            mip_lod_bias: Default::default(),
            anisotropy_enable: Default::default(),
            max_anisotropy: Default::default(),
            compare_enable: Default::default(),
            compare_op: CompareOp::Never,
            min_lod: Default::default(),
            max_lod: Default::default(),
            border_color: BorderColor::FloatTransparentBlack,
            unnormalized_coordinates: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SamplerCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: SamplerCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn mag_filter(mut self, value: Filter) -> Self {
        self.mag_filter = value;
        self
    }
    #[inline]
    pub fn min_filter(mut self, value: Filter) -> Self {
        self.min_filter = value;
        self
    }
    #[inline]
    pub fn mipmap_mode(mut self, value: SamplerMipmapMode) -> Self {
        self.mipmap_mode = value;
        self
    }
    #[inline]
    pub fn address_mode_u(mut self, value: SamplerAddressMode) -> Self {
        self.address_mode_u = value;
        self
    }
    #[inline]
    pub fn address_mode_v(mut self, value: SamplerAddressMode) -> Self {
        self.address_mode_v = value;
        self
    }
    #[inline]
    pub fn address_mode_w(mut self, value: SamplerAddressMode) -> Self {
        self.address_mode_w = value;
        self
    }
    #[inline]
    pub fn mip_lod_bias(mut self, value: f32) -> Self {
        self.mip_lod_bias = value;
        self
    }
    #[inline]
    pub fn anisotropy_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.anisotropy_enable = value.into();
        self
    }
    #[inline]
    pub fn max_anisotropy(mut self, value: f32) -> Self {
        self.max_anisotropy = value;
        self
    }
    #[inline]
    pub fn compare_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.compare_enable = value.into();
        self
    }
    #[inline]
    pub fn compare_op(mut self, value: CompareOp) -> Self {
        self.compare_op = value;
        self
    }
    #[inline]
    pub fn min_lod(mut self, value: f32) -> Self {
        self.min_lod = value;
        self
    }
    #[inline]
    pub fn max_lod(mut self, value: f32) -> Self {
        self.max_lod = value;
        self
    }
    #[inline]
    pub fn border_color(mut self, value: BorderColor) -> Self {
        self.border_color = value;
        self
    }
    #[inline]
    pub fn unnormalized_coordinates(mut self, value: impl Into<Bool32>) -> Self {
        self.unnormalized_coordinates = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyDescriptorSet.html>"]
#[doc(alias = "VkCopyDescriptorSet")]
pub struct CopyDescriptorSet<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_set: Option<DescriptorSet>,
    pub src_binding: u32,
    pub src_array_element: u32,
    pub dst_set: Option<DescriptorSet>,
    pub dst_binding: u32,
    pub dst_array_element: u32,
    pub descriptor_count: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyDescriptorSet<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyDescriptorSet;
}
unsafe impl<'a> Send for CopyDescriptorSet<'a> {}
unsafe impl<'a> Sync for CopyDescriptorSet<'a> {}
impl<'a> Default for CopyDescriptorSet<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_set: Default::default(),
            src_binding: Default::default(),
            src_array_element: Default::default(),
            dst_set: Default::default(),
            dst_binding: Default::default(),
            dst_array_element: Default::default(),
            descriptor_count: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyDescriptorSet<'a> {
    #[inline]
    pub fn src_set(mut self, value: &'a DescriptorSet) -> Self {
        self.src_set = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn src_binding(mut self, value: u32) -> Self {
        self.src_binding = value;
        self
    }
    #[inline]
    pub fn src_array_element(mut self, value: u32) -> Self {
        self.src_array_element = value;
        self
    }
    #[inline]
    pub fn dst_set(mut self, value: &'a DescriptorSet) -> Self {
        self.dst_set = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst_binding(mut self, value: u32) -> Self {
        self.dst_binding = value;
        self
    }
    #[inline]
    pub fn dst_array_element(mut self, value: u32) -> Self {
        self.dst_array_element = value;
        self
    }
    #[inline]
    pub fn descriptor_count(mut self, value: u32) -> Self {
        self.descriptor_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBufferInfo.html>"]
#[doc(alias = "VkDescriptorBufferInfo")]
pub struct DescriptorBufferInfo<'a> {
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
    pub range: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for DescriptorBufferInfo<'a> {}
unsafe impl<'a> Sync for DescriptorBufferInfo<'a> {}
impl<'a> Default for DescriptorBufferInfo<'a> {
    fn default() -> Self {
        Self {
            buffer: Default::default(),
            offset: Default::default(),
            range: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorBufferInfo<'a> {
    #[inline]
    pub fn buffer(mut self, value: Option<&'a Buffer>) -> Self {
        self.buffer = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn offset(mut self, value: DeviceSize) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn range(mut self, value: DeviceSize) -> Self {
        self.range = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorImageInfo.html>"]
#[doc(alias = "VkDescriptorImageInfo")]
pub struct DescriptorImageInfo<'a> {
    pub sampler: Option<Sampler>,
    pub image_view: Option<ImageView>,
    pub image_layout: ImageLayout,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for DescriptorImageInfo<'a> {}
unsafe impl<'a> Sync for DescriptorImageInfo<'a> {}
impl<'a> Default for DescriptorImageInfo<'a> {
    fn default() -> Self {
        Self {
            sampler: Default::default(),
            image_view: Default::default(),
            image_layout: ImageLayout::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorImageInfo<'a> {
    #[inline]
    pub fn sampler(mut self, value: &'a Sampler) -> Self {
        self.sampler = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn image_view(mut self, value: &'a ImageView) -> Self {
        self.image_view = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn image_layout(mut self, value: ImageLayout) -> Self {
        self.image_layout = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateInfo.html>"]
#[doc(alias = "VkDescriptorPoolCreateInfo")]
pub struct DescriptorPoolCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: DescriptorPoolCreateFlags,
    pub max_sets: u32,
    pub(crate) pool_size_count: u32,
    pub(crate) p_pool_sizes: *const DescriptorPoolSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorPoolCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DescriptorPoolCreateInfo;
}
unsafe impl<'a> Send for DescriptorPoolCreateInfo<'a> {}
unsafe impl<'a> Sync for DescriptorPoolCreateInfo<'a> {}
impl<'a> Default for DescriptorPoolCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            max_sets: Default::default(),
            pool_size_count: Default::default(),
            p_pool_sizes: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorPoolCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: DescriptorPoolCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn max_sets(mut self, value: u32) -> Self {
        self.max_sets = value;
        self
    }
    #[inline]
    pub fn pool_sizes(mut self, p_pool_sizes: impl AsSlice<'a, DescriptorPoolSize>) -> Self {
        self.p_pool_sizes = p_pool_sizes.as_slice().as_ptr().cast();
        self.pool_size_count = p_pool_sizes.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolSize.html>"]
#[doc(alias = "VkDescriptorPoolSize")]
pub struct DescriptorPoolSize {
    pub ty: DescriptorType,
    pub descriptor_count: u32,
}
unsafe impl Send for DescriptorPoolSize {}
unsafe impl Sync for DescriptorPoolSize {}
impl Default for DescriptorPoolSize {
    fn default() -> Self {
        Self {
            ty: DescriptorType::Sampler,
            descriptor_count: Default::default(),
        }
    }
}
impl DescriptorPoolSize {
    #[inline]
    pub fn ty(mut self, value: DescriptorType) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn descriptor_count(mut self, value: u32) -> Self {
        self.descriptor_count = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetAllocateInfo.html>"]
#[doc(alias = "VkDescriptorSetAllocateInfo")]
pub struct DescriptorSetAllocateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub descriptor_pool: Option<DescriptorPool>,
    pub(crate) descriptor_set_count: u32,
    pub(crate) p_set_layouts: *const DescriptorSetLayout,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorSetAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DescriptorSetAllocateInfo;
}
unsafe impl<'a> Send for DescriptorSetAllocateInfo<'a> {}
unsafe impl<'a> Sync for DescriptorSetAllocateInfo<'a> {}
impl<'a> Default for DescriptorSetAllocateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            descriptor_pool: Default::default(),
            descriptor_set_count: Default::default(),
            p_set_layouts: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorSetAllocateInfo<'a> {
    #[inline]
    pub fn descriptor_pool(mut self, value: &'a DescriptorPool) -> Self {
        self.descriptor_pool = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn set_layouts<V0: Alias<raw::DescriptorSetLayout> + 'a>(
        mut self,
        p_set_layouts: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_set_layouts = p_set_layouts.as_slice().as_ptr().cast();
        self.descriptor_set_count = p_set_layouts.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBinding.html>"]
#[doc(alias = "VkDescriptorSetLayoutBinding")]
pub struct DescriptorSetLayoutBinding<'a> {
    pub binding: u32,
    pub descriptor_type: DescriptorType,
    pub descriptor_count: u32,
    pub stage_flags: ShaderStageFlags,
    pub(crate) p_immutable_samplers: *const Sampler,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for DescriptorSetLayoutBinding<'a> {}
unsafe impl<'a> Sync for DescriptorSetLayoutBinding<'a> {}
impl<'a> Default for DescriptorSetLayoutBinding<'a> {
    fn default() -> Self {
        Self {
            binding: Default::default(),
            descriptor_type: DescriptorType::Sampler,
            descriptor_count: Default::default(),
            stage_flags: Default::default(),
            p_immutable_samplers: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorSetLayoutBinding<'a> {
    #[inline]
    pub fn binding(mut self, value: u32) -> Self {
        self.binding = value;
        self
    }
    #[inline]
    pub fn descriptor_type(mut self, value: DescriptorType) -> Self {
        self.descriptor_type = value;
        self
    }
    #[inline]
    pub fn descriptor_count(mut self, value: u32) -> Self {
        self.descriptor_count = value;
        self
    }
    #[inline]
    pub fn stage_flags(mut self, value: ShaderStageFlags) -> Self {
        self.stage_flags = value;
        self
    }
    #[inline]
    pub fn immutable_samplers<V0: Alias<raw::Sampler> + 'a>(
        mut self,
        p_immutable_samplers: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_immutable_samplers = p_immutable_samplers.as_slice().as_ptr().cast();
        self.descriptor_count = p_immutable_samplers.as_slice().len() as _;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutCreateInfo.html>"]
#[doc(alias = "VkDescriptorSetLayoutCreateInfo")]
pub struct DescriptorSetLayoutCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: DescriptorSetLayoutCreateFlags,
    pub(crate) binding_count: u32,
    pub(crate) p_bindings: *const DescriptorSetLayoutBinding<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorSetLayoutCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DescriptorSetLayoutCreateInfo;
}
unsafe impl<'a> Send for DescriptorSetLayoutCreateInfo<'a> {}
unsafe impl<'a> Sync for DescriptorSetLayoutCreateInfo<'a> {}
impl<'a> Default for DescriptorSetLayoutCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            binding_count: Default::default(),
            p_bindings: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorSetLayoutCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: DescriptorSetLayoutCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn bindings(
        mut self,
        p_bindings: impl AsSlice<'a, DescriptorSetLayoutBinding<'a>>,
    ) -> Self {
        self.p_bindings = p_bindings.as_slice().as_ptr().cast();
        self.binding_count = p_bindings.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSet.html>"]
#[doc(alias = "VkWriteDescriptorSet")]
pub struct WriteDescriptorSet<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub dst_set: Option<DescriptorSet>,
    pub dst_binding: u32,
    pub dst_array_element: u32,
    pub(crate) descriptor_count: u32,
    pub descriptor_type: DescriptorType,
    pub(crate) p_image_info: *const DescriptorImageInfo<'a>,
    pub(crate) p_buffer_info: *const DescriptorBufferInfo<'a>,
    pub(crate) p_texel_buffer_view: *const BufferView,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for WriteDescriptorSet<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::WriteDescriptorSet;
}
unsafe impl<'a> Send for WriteDescriptorSet<'a> {}
unsafe impl<'a> Sync for WriteDescriptorSet<'a> {}
impl<'a> Default for WriteDescriptorSet<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            dst_set: Default::default(),
            dst_binding: Default::default(),
            dst_array_element: Default::default(),
            descriptor_count: Default::default(),
            descriptor_type: DescriptorType::Sampler,
            p_image_info: ptr::null(),
            p_buffer_info: ptr::null(),
            p_texel_buffer_view: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> WriteDescriptorSet<'a> {
    #[inline]
    pub fn dst_set(mut self, value: &'a DescriptorSet) -> Self {
        self.dst_set = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst_binding(mut self, value: u32) -> Self {
        self.dst_binding = value;
        self
    }
    #[inline]
    pub fn dst_array_element(mut self, value: u32) -> Self {
        self.dst_array_element = value;
        self
    }
    #[inline]
    pub fn descriptor_type(mut self, value: DescriptorType) -> Self {
        self.descriptor_type = value;
        self
    }
    #[inline]
    pub fn descriptor<V2: Alias<raw::BufferView> + 'a>(
        mut self,
        p_image_info: impl AsSlice<'a, DescriptorImageInfo<'a>>,
        p_buffer_info: impl AsSlice<'a, DescriptorBufferInfo<'a>>,
        p_texel_buffer_view: impl AsSlice<'a, V2>,
    ) -> Self {
        self.p_image_info = p_image_info.as_slice().as_ptr().cast();
        self.p_buffer_info = p_buffer_info.as_slice().as_ptr().cast();
        self.p_texel_buffer_view = p_texel_buffer_view.as_slice().as_ptr().cast();
        self.descriptor_count = p_image_info.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription.html>"]
#[doc(alias = "VkAttachmentDescription")]
pub struct AttachmentDescription {
    pub flags: AttachmentDescriptionFlags,
    pub format: Format,
    pub samples: SampleCountFlags,
    pub load_op: AttachmentLoadOp,
    pub store_op: AttachmentStoreOp,
    pub stencil_load_op: AttachmentLoadOp,
    pub stencil_store_op: AttachmentStoreOp,
    pub initial_layout: ImageLayout,
    pub final_layout: ImageLayout,
}
unsafe impl Send for AttachmentDescription {}
unsafe impl Sync for AttachmentDescription {}
impl Default for AttachmentDescription {
    fn default() -> Self {
        Self {
            flags: Default::default(),
            format: Format::Undefined,
            samples: Default::default(),
            load_op: AttachmentLoadOp::Load,
            store_op: AttachmentStoreOp::Store,
            stencil_load_op: AttachmentLoadOp::Load,
            stencil_store_op: AttachmentStoreOp::Store,
            initial_layout: ImageLayout::Undefined,
            final_layout: ImageLayout::Undefined,
        }
    }
}
impl AttachmentDescription {
    #[inline]
    pub fn flags(mut self, value: AttachmentDescriptionFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn samples(mut self, value: SampleCountFlags) -> Self {
        self.samples = value;
        self
    }
    #[inline]
    pub fn load_op(mut self, value: AttachmentLoadOp) -> Self {
        self.load_op = value;
        self
    }
    #[inline]
    pub fn store_op(mut self, value: AttachmentStoreOp) -> Self {
        self.store_op = value;
        self
    }
    #[inline]
    pub fn stencil_load_op(mut self, value: AttachmentLoadOp) -> Self {
        self.stencil_load_op = value;
        self
    }
    #[inline]
    pub fn stencil_store_op(mut self, value: AttachmentStoreOp) -> Self {
        self.stencil_store_op = value;
        self
    }
    #[inline]
    pub fn initial_layout(mut self, value: ImageLayout) -> Self {
        self.initial_layout = value;
        self
    }
    #[inline]
    pub fn final_layout(mut self, value: ImageLayout) -> Self {
        self.final_layout = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference.html>"]
#[doc(alias = "VkAttachmentReference")]
pub struct AttachmentReference {
    pub attachment: u32,
    pub layout: ImageLayout,
}
unsafe impl Send for AttachmentReference {}
unsafe impl Sync for AttachmentReference {}
impl Default for AttachmentReference {
    fn default() -> Self {
        Self {
            attachment: Default::default(),
            layout: ImageLayout::Undefined,
        }
    }
}
impl AttachmentReference {
    #[inline]
    pub fn attachment(mut self, value: u32) -> Self {
        self.attachment = value;
        self
    }
    #[inline]
    pub fn layout(mut self, value: ImageLayout) -> Self {
        self.layout = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateInfo.html>"]
#[doc(alias = "VkFramebufferCreateInfo")]
pub struct FramebufferCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: FramebufferCreateFlags,
    pub render_pass: Option<RenderPass>,
    pub(crate) attachment_count: u32,
    pub(crate) p_attachments: *const ImageView,
    pub width: u32,
    pub height: u32,
    pub layers: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for FramebufferCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FramebufferCreateInfo;
}
unsafe impl<'a> Send for FramebufferCreateInfo<'a> {}
unsafe impl<'a> Sync for FramebufferCreateInfo<'a> {}
impl<'a> Default for FramebufferCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            render_pass: Default::default(),
            attachment_count: Default::default(),
            p_attachments: ptr::null(),
            width: Default::default(),
            height: Default::default(),
            layers: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> FramebufferCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: FramebufferCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn render_pass(mut self, value: &'a RenderPass) -> Self {
        self.render_pass = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn width(mut self, value: u32) -> Self {
        self.width = value;
        self
    }
    #[inline]
    pub fn height(mut self, value: u32) -> Self {
        self.height = value;
        self
    }
    #[inline]
    pub fn layers(mut self, value: u32) -> Self {
        self.layers = value;
        self
    }
    #[inline]
    pub fn attachments<V0: Alias<raw::ImageView> + 'a>(
        mut self,
        p_attachments: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_attachments = p_attachments.as_slice().as_ptr().cast();
        self.attachment_count = p_attachments.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo.html>"]
#[doc(alias = "VkRenderPassCreateInfo")]
pub struct RenderPassCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: RenderPassCreateFlags,
    pub(crate) attachment_count: u32,
    pub(crate) p_attachments: *const AttachmentDescription,
    pub(crate) subpass_count: u32,
    pub(crate) p_subpasses: *const SubpassDescription<'a>,
    pub(crate) dependency_count: u32,
    pub(crate) p_dependencies: *const SubpassDependency,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassCreateInfo;
}
unsafe impl<'a> Send for RenderPassCreateInfo<'a> {}
unsafe impl<'a> Sync for RenderPassCreateInfo<'a> {}
impl<'a> Default for RenderPassCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            attachment_count: Default::default(),
            p_attachments: ptr::null(),
            subpass_count: Default::default(),
            p_subpasses: ptr::null(),
            dependency_count: Default::default(),
            p_dependencies: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: RenderPassCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn attachments(mut self, p_attachments: impl AsSlice<'a, AttachmentDescription>) -> Self {
        self.p_attachments = p_attachments.as_slice().as_ptr().cast();
        self.attachment_count = p_attachments.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn subpasses(mut self, p_subpasses: impl AsSlice<'a, SubpassDescription<'a>>) -> Self {
        self.p_subpasses = p_subpasses.as_slice().as_ptr().cast();
        self.subpass_count = p_subpasses.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn dependencies(mut self, p_dependencies: impl AsSlice<'a, SubpassDependency>) -> Self {
        self.p_dependencies = p_dependencies.as_slice().as_ptr().cast();
        self.dependency_count = p_dependencies.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency.html>"]
#[doc(alias = "VkSubpassDependency")]
pub struct SubpassDependency {
    pub src_subpass: u32,
    pub dst_subpass: u32,
    pub src_stage_mask: PipelineStageFlags,
    pub dst_stage_mask: PipelineStageFlags,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub dependency_flags: DependencyFlags,
}
unsafe impl Send for SubpassDependency {}
unsafe impl Sync for SubpassDependency {}
impl Default for SubpassDependency {
    fn default() -> Self {
        Self {
            src_subpass: Default::default(),
            dst_subpass: Default::default(),
            src_stage_mask: Default::default(),
            dst_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
            dependency_flags: Default::default(),
        }
    }
}
impl SubpassDependency {
    #[inline]
    pub fn src_subpass(mut self, value: u32) -> Self {
        self.src_subpass = value;
        self
    }
    #[inline]
    pub fn dst_subpass(mut self, value: u32) -> Self {
        self.dst_subpass = value;
        self
    }
    #[inline]
    pub fn src_stage_mask(mut self, value: PipelineStageFlags) -> Self {
        self.src_stage_mask = value;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, value: PipelineStageFlags) -> Self {
        self.dst_stage_mask = value;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, value: AccessFlags) -> Self {
        self.src_access_mask = value;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, value: AccessFlags) -> Self {
        self.dst_access_mask = value;
        self
    }
    #[inline]
    pub fn dependency_flags(mut self, value: DependencyFlags) -> Self {
        self.dependency_flags = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription.html>"]
#[doc(alias = "VkSubpassDescription")]
pub struct SubpassDescription<'a> {
    pub flags: SubpassDescriptionFlags,
    pub pipeline_bind_point: PipelineBindPoint,
    pub(crate) input_attachment_count: u32,
    pub(crate) p_input_attachments: *const AttachmentReference,
    pub(crate) color_attachment_count: u32,
    pub(crate) p_color_attachments: *const AttachmentReference,
    pub(crate) p_resolve_attachments: *const AttachmentReference,
    pub p_depth_stencil_attachment: *const AttachmentReference,
    pub(crate) preserve_attachment_count: u32,
    pub(crate) p_preserve_attachments: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for SubpassDescription<'a> {}
unsafe impl<'a> Sync for SubpassDescription<'a> {}
impl<'a> Default for SubpassDescription<'a> {
    fn default() -> Self {
        Self {
            flags: Default::default(),
            pipeline_bind_point: PipelineBindPoint::Graphics,
            input_attachment_count: Default::default(),
            p_input_attachments: ptr::null(),
            color_attachment_count: Default::default(),
            p_color_attachments: ptr::null(),
            p_resolve_attachments: ptr::null(),
            p_depth_stencil_attachment: ptr::null(),
            preserve_attachment_count: Default::default(),
            p_preserve_attachments: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubpassDescription<'a> {
    #[inline]
    pub fn flags(mut self, value: SubpassDescriptionFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn pipeline_bind_point(mut self, value: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = value;
        self
    }
    #[inline]
    pub fn depth_stencil_attachment(mut self, value: Option<&'a AttachmentReference>) -> Self {
        self.p_depth_stencil_attachment = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn input_attachments(
        mut self,
        p_input_attachments: impl AsSlice<'a, AttachmentReference>,
    ) -> Self {
        self.p_input_attachments = p_input_attachments.as_slice().as_ptr().cast();
        self.input_attachment_count = p_input_attachments.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn color_attachment(
        mut self,
        p_color_attachments: impl AsSlice<'a, AttachmentReference>,
        p_resolve_attachments: Option<impl AsSlice<'a, AttachmentReference>>,
    ) -> Self {
        self.p_color_attachments = p_color_attachments.as_slice().as_ptr().cast();
        self.p_resolve_attachments = p_resolve_attachments
            .map(|p| p.as_slice().as_ptr().cast())
            .unwrap_or(ptr::null());
        self.color_attachment_count = p_color_attachments.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn preserve_attachments(mut self, p_preserve_attachments: impl AsSlice<'a, u32>) -> Self {
        self.p_preserve_attachments = p_preserve_attachments.as_slice().as_ptr().cast();
        self.preserve_attachment_count = p_preserve_attachments.as_slice().len() as _;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateInfo.html>"]
#[doc(alias = "VkCommandPoolCreateInfo")]
pub struct CommandPoolCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: CommandPoolCreateFlags,
    pub queue_family_index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CommandPoolCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CommandPoolCreateInfo;
}
unsafe impl<'a> Send for CommandPoolCreateInfo<'a> {}
unsafe impl<'a> Sync for CommandPoolCreateInfo<'a> {}
impl<'a> Default for CommandPoolCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            queue_family_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CommandPoolCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: CommandPoolCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn queue_family_index(mut self, value: u32) -> Self {
        self.queue_family_index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferAllocateInfo.html>"]
#[doc(alias = "VkCommandBufferAllocateInfo")]
pub struct CommandBufferAllocateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub command_pool: Option<CommandPool>,
    pub level: CommandBufferLevel,
    pub command_buffer_count: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CommandBufferAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CommandBufferAllocateInfo;
}
unsafe impl<'a> Send for CommandBufferAllocateInfo<'a> {}
unsafe impl<'a> Sync for CommandBufferAllocateInfo<'a> {}
impl<'a> Default for CommandBufferAllocateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            command_pool: Default::default(),
            level: CommandBufferLevel::Primary,
            command_buffer_count: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CommandBufferAllocateInfo<'a> {
    #[inline]
    pub fn command_pool(mut self, value: &'a CommandPool) -> Self {
        self.command_pool = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn level(mut self, value: CommandBufferLevel) -> Self {
        self.level = value;
        self
    }
    #[inline]
    pub fn command_buffer_count(mut self, value: u32) -> Self {
        self.command_buffer_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferBeginInfo.html>"]
#[doc(alias = "VkCommandBufferBeginInfo")]
pub struct CommandBufferBeginInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: CommandBufferUsageFlags,
    pub p_inheritance_info: *const CommandBufferInheritanceInfo<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CommandBufferBeginInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CommandBufferBeginInfo;
}
unsafe impl<'a> Send for CommandBufferBeginInfo<'a> {}
unsafe impl<'a> Sync for CommandBufferBeginInfo<'a> {}
impl<'a> Default for CommandBufferBeginInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            p_inheritance_info: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CommandBufferBeginInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: CommandBufferUsageFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn inheritance_info(mut self, value: Option<&'a CommandBufferInheritanceInfo<'a>>) -> Self {
        self.p_inheritance_info = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceInfo.html>"]
#[doc(alias = "VkCommandBufferInheritanceInfo")]
pub struct CommandBufferInheritanceInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub render_pass: Option<RenderPass>,
    pub subpass: u32,
    pub framebuffer: Option<Framebuffer>,
    pub occlusion_query_enable: Bool32,
    pub query_flags: QueryControlFlags,
    pub pipeline_statistics: QueryPipelineStatisticFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CommandBufferInheritanceInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CommandBufferInheritanceInfo;
}
unsafe impl<'a> Send for CommandBufferInheritanceInfo<'a> {}
unsafe impl<'a> Sync for CommandBufferInheritanceInfo<'a> {}
impl<'a> Default for CommandBufferInheritanceInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            render_pass: Default::default(),
            subpass: Default::default(),
            framebuffer: Default::default(),
            occlusion_query_enable: Default::default(),
            query_flags: Default::default(),
            pipeline_statistics: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CommandBufferInheritanceInfo<'a> {
    #[inline]
    pub fn render_pass(mut self, value: Option<&'a RenderPass>) -> Self {
        self.render_pass = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn subpass(mut self, value: u32) -> Self {
        self.subpass = value;
        self
    }
    #[inline]
    pub fn framebuffer(mut self, value: Option<&'a Framebuffer>) -> Self {
        self.framebuffer = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn occlusion_query_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.occlusion_query_enable = value.into();
        self
    }
    #[inline]
    pub fn query_flags(mut self, value: QueryControlFlags) -> Self {
        self.query_flags = value;
        self
    }
    #[inline]
    pub fn pipeline_statistics(mut self, value: QueryPipelineStatisticFlags) -> Self {
        self.pipeline_statistics = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy.html>"]
#[doc(alias = "VkBufferCopy")]
pub struct BufferCopy {
    pub src_offset: DeviceSize,
    pub dst_offset: DeviceSize,
    pub size: DeviceSize,
}
unsafe impl Send for BufferCopy {}
unsafe impl Sync for BufferCopy {}
impl Default for BufferCopy {
    fn default() -> Self {
        Self {
            src_offset: Default::default(),
            dst_offset: Default::default(),
            size: Default::default(),
        }
    }
}
impl BufferCopy {
    #[inline]
    pub fn src_offset(mut self, value: DeviceSize) -> Self {
        self.src_offset = value;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, value: DeviceSize) -> Self {
        self.dst_offset = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy.html>"]
#[doc(alias = "VkBufferImageCopy")]
pub struct BufferImageCopy {
    pub buffer_offset: DeviceSize,
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    pub image_offset: Offset3D,
    pub image_extent: Extent3D,
}
unsafe impl Send for BufferImageCopy {}
unsafe impl Sync for BufferImageCopy {}
impl Default for BufferImageCopy {
    fn default() -> Self {
        Self {
            buffer_offset: Default::default(),
            buffer_row_length: Default::default(),
            buffer_image_height: Default::default(),
            image_subresource: Default::default(),
            image_offset: Default::default(),
            image_extent: Default::default(),
        }
    }
}
impl BufferImageCopy {
    #[inline]
    pub fn buffer_offset(mut self, value: DeviceSize) -> Self {
        self.buffer_offset = value;
        self
    }
    #[inline]
    pub fn buffer_row_length(mut self, value: u32) -> Self {
        self.buffer_row_length = value;
        self
    }
    #[inline]
    pub fn buffer_image_height(mut self, value: u32) -> Self {
        self.buffer_image_height = value;
        self
    }
    #[inline]
    pub fn image_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.image_subresource = value;
        self
    }
    #[inline]
    pub fn image_offset(mut self, value: Offset3D) -> Self {
        self.image_offset = value;
        self
    }
    #[inline]
    pub fn image_extent(mut self, value: Extent3D) -> Self {
        self.image_extent = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearAttachment.html>"]
#[doc(alias = "VkClearAttachment")]
pub struct ClearAttachment {
    pub aspect_mask: ImageAspectFlags,
    pub color_attachment: u32,
    pub clear_value: ClearValue,
}
unsafe impl Send for ClearAttachment {}
unsafe impl Sync for ClearAttachment {}
impl Default for ClearAttachment {
    fn default() -> Self {
        Self {
            aspect_mask: Default::default(),
            color_attachment: Default::default(),
            clear_value: Default::default(),
        }
    }
}
impl ClearAttachment {
    #[inline]
    pub fn aspect_mask(mut self, value: ImageAspectFlags) -> Self {
        self.aspect_mask = value;
        self
    }
    #[inline]
    pub fn color_attachment(mut self, value: u32) -> Self {
        self.color_attachment = value;
        self
    }
    #[inline]
    pub fn clear_value(mut self, value: ClearValue) -> Self {
        self.clear_value = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearColorValue.html>"]
#[doc(alias = "VkClearColorValue")]
pub union ClearColorValue {
    pub float32: [f32; 4u16 as _],
    pub int32: [i32; 4u16 as _],
    pub uint32: [u32; 4u16 as _],
}
impl Default for ClearColorValue {
    fn default() -> Self {
        Self {
            float32: array::from_fn(|_| Default::default()),
        }
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearDepthStencilValue.html>"]
#[doc(alias = "VkClearDepthStencilValue")]
pub struct ClearDepthStencilValue {
    pub depth: f32,
    pub stencil: u32,
}
unsafe impl Send for ClearDepthStencilValue {}
unsafe impl Sync for ClearDepthStencilValue {}
impl Default for ClearDepthStencilValue {
    fn default() -> Self {
        Self {
            depth: Default::default(),
            stencil: Default::default(),
        }
    }
}
impl ClearDepthStencilValue {
    #[inline]
    pub fn depth(mut self, value: f32) -> Self {
        self.depth = value;
        self
    }
    #[inline]
    pub fn stencil(mut self, value: u32) -> Self {
        self.stencil = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearRect.html>"]
#[doc(alias = "VkClearRect")]
pub struct ClearRect {
    pub rect: Rect2D,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
unsafe impl Send for ClearRect {}
unsafe impl Sync for ClearRect {}
impl Default for ClearRect {
    fn default() -> Self {
        Self {
            rect: Default::default(),
            base_array_layer: Default::default(),
            layer_count: Default::default(),
        }
    }
}
impl ClearRect {
    #[inline]
    pub fn rect(mut self, value: Rect2D) -> Self {
        self.rect = value;
        self
    }
    #[inline]
    pub fn base_array_layer(mut self, value: u32) -> Self {
        self.base_array_layer = value;
        self
    }
    #[inline]
    pub fn layer_count(mut self, value: u32) -> Self {
        self.layer_count = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearValue.html>"]
#[doc(alias = "VkClearValue")]
pub union ClearValue {
    pub color: ClearColorValue,
    pub depth_stencil: ClearDepthStencilValue,
}
impl Default for ClearValue {
    fn default() -> Self {
        Self {
            color: Default::default(),
        }
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit.html>"]
#[doc(alias = "VkImageBlit")]
pub struct ImageBlit {
    pub src_subresource: ImageSubresourceLayers,
    pub src_offsets: [Offset3D; 2u16 as _],
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offsets: [Offset3D; 2u16 as _],
}
unsafe impl Send for ImageBlit {}
unsafe impl Sync for ImageBlit {}
impl Default for ImageBlit {
    fn default() -> Self {
        Self {
            src_subresource: Default::default(),
            src_offsets: array::from_fn(|_| Default::default()),
            dst_subresource: Default::default(),
            dst_offsets: array::from_fn(|_| Default::default()),
        }
    }
}
impl ImageBlit {
    #[inline]
    pub fn src_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.src_subresource = value;
        self
    }
    #[inline]
    pub fn src_offsets(mut self, value: [Offset3D; 2u16 as _]) -> Self {
        self.src_offsets = value;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.dst_subresource = value;
        self
    }
    #[inline]
    pub fn dst_offsets(mut self, value: [Offset3D; 2u16 as _]) -> Self {
        self.dst_offsets = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy.html>"]
#[doc(alias = "VkImageCopy")]
pub struct ImageCopy {
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
unsafe impl Send for ImageCopy {}
unsafe impl Sync for ImageCopy {}
impl Default for ImageCopy {
    fn default() -> Self {
        Self {
            src_subresource: Default::default(),
            src_offset: Default::default(),
            dst_subresource: Default::default(),
            dst_offset: Default::default(),
            extent: Default::default(),
        }
    }
}
impl ImageCopy {
    #[inline]
    pub fn src_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.src_subresource = value;
        self
    }
    #[inline]
    pub fn src_offset(mut self, value: Offset3D) -> Self {
        self.src_offset = value;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.dst_subresource = value;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, value: Offset3D) -> Self {
        self.dst_offset = value;
        self
    }
    #[inline]
    pub fn extent(mut self, value: Extent3D) -> Self {
        self.extent = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve.html>"]
#[doc(alias = "VkImageResolve")]
pub struct ImageResolve {
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
unsafe impl Send for ImageResolve {}
unsafe impl Sync for ImageResolve {}
impl Default for ImageResolve {
    fn default() -> Self {
        Self {
            src_subresource: Default::default(),
            src_offset: Default::default(),
            dst_subresource: Default::default(),
            dst_offset: Default::default(),
            extent: Default::default(),
        }
    }
}
impl ImageResolve {
    #[inline]
    pub fn src_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.src_subresource = value;
        self
    }
    #[inline]
    pub fn src_offset(mut self, value: Offset3D) -> Self {
        self.src_offset = value;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.dst_subresource = value;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, value: Offset3D) -> Self {
        self.dst_offset = value;
        self
    }
    #[inline]
    pub fn extent(mut self, value: Extent3D) -> Self {
        self.extent = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceLayers.html>"]
#[doc(alias = "VkImageSubresourceLayers")]
pub struct ImageSubresourceLayers {
    pub aspect_mask: ImageAspectFlags,
    pub mip_level: u32,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
unsafe impl Send for ImageSubresourceLayers {}
unsafe impl Sync for ImageSubresourceLayers {}
impl Default for ImageSubresourceLayers {
    fn default() -> Self {
        Self {
            aspect_mask: Default::default(),
            mip_level: Default::default(),
            base_array_layer: Default::default(),
            layer_count: Default::default(),
        }
    }
}
impl ImageSubresourceLayers {
    #[inline]
    pub fn aspect_mask(mut self, value: ImageAspectFlags) -> Self {
        self.aspect_mask = value;
        self
    }
    #[inline]
    pub fn mip_level(mut self, value: u32) -> Self {
        self.mip_level = value;
        self
    }
    #[inline]
    pub fn base_array_layer(mut self, value: u32) -> Self {
        self.base_array_layer = value;
        self
    }
    #[inline]
    pub fn layer_count(mut self, value: u32) -> Self {
        self.layer_count = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassBeginInfo.html>"]
#[doc(alias = "VkRenderPassBeginInfo")]
pub struct RenderPassBeginInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub render_pass: Option<RenderPass>,
    pub framebuffer: Option<Framebuffer>,
    pub render_area: Rect2D,
    pub(crate) clear_value_count: u32,
    pub(crate) p_clear_values: *const ClearValue,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassBeginInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassBeginInfo;
}
unsafe impl<'a> Send for RenderPassBeginInfo<'a> {}
unsafe impl<'a> Sync for RenderPassBeginInfo<'a> {}
impl<'a> Default for RenderPassBeginInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            render_pass: Default::default(),
            framebuffer: Default::default(),
            render_area: Default::default(),
            clear_value_count: Default::default(),
            p_clear_values: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassBeginInfo<'a> {
    #[inline]
    pub fn render_pass(mut self, value: &'a RenderPass) -> Self {
        self.render_pass = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn framebuffer(mut self, value: &'a Framebuffer) -> Self {
        self.framebuffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn render_area(mut self, value: Rect2D) -> Self {
        self.render_area = value;
        self
    }
    #[inline]
    pub fn clear_values(mut self, p_clear_values: impl AsSlice<'a, ClearValue>) -> Self {
        self.p_clear_values = p_clear_values.as_slice().as_ptr().cast();
        self.clear_value_count = p_clear_values.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupProperties.html>"]
#[doc(alias = "VkPhysicalDeviceSubgroupProperties")]
pub struct PhysicalDeviceSubgroupProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub subgroup_size: u32,
    pub supported_stages: ShaderStageFlags,
    pub supported_operations: SubgroupFeatureFlags,
    pub quad_operations_in_all_stages: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSubgroupProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceSubgroupProperties;
}
unsafe impl<'a> Send for PhysicalDeviceSubgroupProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSubgroupProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceSubgroupProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceSubgroupProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            subgroup_size: Default::default(),
            supported_stages: Default::default(),
            supported_operations: Default::default(),
            quad_operations_in_all_stages: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSubgroupProperties<'a> {
    #[inline]
    pub fn subgroup_size(mut self, value: u32) -> Self {
        self.subgroup_size = value;
        self
    }
    #[inline]
    pub fn supported_stages(mut self, value: ShaderStageFlags) -> Self {
        self.supported_stages = value;
        self
    }
    #[inline]
    pub fn supported_operations(mut self, value: SubgroupFeatureFlags) -> Self {
        self.supported_operations = value;
        self
    }
    #[inline]
    pub fn quad_operations_in_all_stages(mut self, value: impl Into<Bool32>) -> Self {
        self.quad_operations_in_all_stages = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindBufferMemoryInfo.html>"]
#[doc(alias = "VkBindBufferMemoryInfo")]
pub struct BindBufferMemoryInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub buffer: Option<Buffer>,
    pub memory: Option<DeviceMemory>,
    pub memory_offset: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BindBufferMemoryInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BindBufferMemoryInfo;
}
unsafe impl<'a> Send for BindBufferMemoryInfo<'a> {}
unsafe impl<'a> Sync for BindBufferMemoryInfo<'a> {}
impl<'a> Default for BindBufferMemoryInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            buffer: Default::default(),
            memory: Default::default(),
            memory_offset: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BindBufferMemoryInfo<'a> {
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn memory_offset(mut self, value: DeviceSize) -> Self {
        self.memory_offset = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type BindBufferMemoryInfoKHR<'a> = BindBufferMemoryInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemoryInfo.html>"]
#[doc(alias = "VkBindImageMemoryInfo")]
pub struct BindImageMemoryInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image: Option<Image>,
    pub memory: Option<DeviceMemory>,
    pub memory_offset: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BindImageMemoryInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BindImageMemoryInfo;
}
unsafe impl<'a> Send for BindImageMemoryInfo<'a> {}
unsafe impl<'a> Sync for BindImageMemoryInfo<'a> {}
impl<'a> Default for BindImageMemoryInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image: Default::default(),
            memory: Default::default(),
            memory_offset: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BindImageMemoryInfo<'a> {
    #[inline]
    pub fn image(mut self, value: &'a Image) -> Self {
        self.image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn memory_offset(mut self, value: DeviceSize) -> Self {
        self.memory_offset = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type BindImageMemoryInfoKHR<'a> = BindImageMemoryInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice16BitStorageFeatures.html>"]
#[doc(alias = "VkPhysicalDevice16BitStorageFeatures")]
pub struct PhysicalDevice16BitStorageFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub storage_buffer16_bit_access: Bool32,
    pub uniform_and_storage_buffer16_bit_access: Bool32,
    pub storage_push_constant16: Bool32,
    pub storage_input_output16: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevice16BitStorageFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDevice16BitStorageFeatures;
}
unsafe impl<'a> Send for PhysicalDevice16BitStorageFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDevice16BitStorageFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevice16BitStorageFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevice16BitStorageFeatures<'a>
{
}
impl<'a> Default for PhysicalDevice16BitStorageFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            storage_buffer16_bit_access: Default::default(),
            uniform_and_storage_buffer16_bit_access: Default::default(),
            storage_push_constant16: Default::default(),
            storage_input_output16: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevice16BitStorageFeatures<'a> {
    #[inline]
    pub fn storage_buffer16_bit_access(mut self, value: impl Into<Bool32>) -> Self {
        self.storage_buffer16_bit_access = value.into();
        self
    }
    #[inline]
    pub fn uniform_and_storage_buffer16_bit_access(mut self, value: impl Into<Bool32>) -> Self {
        self.uniform_and_storage_buffer16_bit_access = value.into();
        self
    }
    #[inline]
    pub fn storage_push_constant16(mut self, value: impl Into<Bool32>) -> Self {
        self.storage_push_constant16 = value.into();
        self
    }
    #[inline]
    pub fn storage_input_output16(mut self, value: impl Into<Bool32>) -> Self {
        self.storage_input_output16 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDevice16BitStorageFeaturesKHR<'a> = PhysicalDevice16BitStorageFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryDedicatedRequirements.html>"]
#[doc(alias = "VkMemoryDedicatedRequirements")]
pub struct MemoryDedicatedRequirements<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub prefers_dedicated_allocation: Bool32,
    pub requires_dedicated_allocation: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryDedicatedRequirements<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryDedicatedRequirements;
}
unsafe impl<'a> Send for MemoryDedicatedRequirements<'a> {}
unsafe impl<'a> Sync for MemoryDedicatedRequirements<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryRequirements2<'b>>
    for MemoryDedicatedRequirements<'a>
{
}
impl<'a> Default for MemoryDedicatedRequirements<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            prefers_dedicated_allocation: Default::default(),
            requires_dedicated_allocation: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryDedicatedRequirements<'a> {
    #[inline]
    pub fn prefers_dedicated_allocation(mut self, value: impl Into<Bool32>) -> Self {
        self.prefers_dedicated_allocation = value.into();
        self
    }
    #[inline]
    pub fn requires_dedicated_allocation(mut self, value: impl Into<Bool32>) -> Self {
        self.requires_dedicated_allocation = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type MemoryDedicatedRequirementsKHR<'a> = MemoryDedicatedRequirements<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryDedicatedAllocateInfo.html>"]
#[doc(alias = "VkMemoryDedicatedAllocateInfo")]
pub struct MemoryDedicatedAllocateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image: Option<Image>,
    pub buffer: Option<Buffer>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryDedicatedAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryDedicatedAllocateInfo;
}
unsafe impl<'a> Send for MemoryDedicatedAllocateInfo<'a> {}
unsafe impl<'a> Sync for MemoryDedicatedAllocateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>> for MemoryDedicatedAllocateInfo<'a> {}
impl<'a> Default for MemoryDedicatedAllocateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image: Default::default(),
            buffer: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryDedicatedAllocateInfo<'a> {
    #[inline]
    pub fn image(mut self, value: Option<&'a Image>) -> Self {
        self.image = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn buffer(mut self, value: Option<&'a Buffer>) -> Self {
        self.buffer = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type MemoryDedicatedAllocateInfoKHR<'a> = MemoryDedicatedAllocateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateFlagsInfo.html>"]
#[doc(alias = "VkMemoryAllocateFlagsInfo")]
pub struct MemoryAllocateFlagsInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: MemoryAllocateFlags,
    pub device_mask: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryAllocateFlagsInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryAllocateFlagsInfo;
}
unsafe impl<'a> Send for MemoryAllocateFlagsInfo<'a> {}
unsafe impl<'a> Sync for MemoryAllocateFlagsInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>> for MemoryAllocateFlagsInfo<'a> {}
impl<'a> Default for MemoryAllocateFlagsInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            device_mask: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryAllocateFlagsInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: MemoryAllocateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn device_mask(mut self, value: u32) -> Self {
        self.device_mask = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type MemoryAllocateFlagsInfoKHR<'a> = MemoryAllocateFlagsInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupRenderPassBeginInfo.html>"]
#[doc(alias = "VkDeviceGroupRenderPassBeginInfo")]
pub struct DeviceGroupRenderPassBeginInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_mask: u32,
    pub(crate) device_render_area_count: u32,
    pub(crate) p_device_render_areas: *const Rect2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceGroupRenderPassBeginInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceGroupRenderPassBeginInfo;
}
unsafe impl<'a> Send for DeviceGroupRenderPassBeginInfo<'a> {}
unsafe impl<'a> Sync for DeviceGroupRenderPassBeginInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderPassBeginInfo<'b>>
    for DeviceGroupRenderPassBeginInfo<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<RenderingInfo<'b>> for DeviceGroupRenderPassBeginInfo<'a> {}
impl<'a> Default for DeviceGroupRenderPassBeginInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_mask: Default::default(),
            device_render_area_count: Default::default(),
            p_device_render_areas: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceGroupRenderPassBeginInfo<'a> {
    #[inline]
    pub fn device_mask(mut self, value: u32) -> Self {
        self.device_mask = value;
        self
    }
    #[inline]
    pub fn device_render_areas(mut self, p_device_render_areas: impl AsSlice<'a, Rect2D>) -> Self {
        self.p_device_render_areas = p_device_render_areas.as_slice().as_ptr().cast();
        self.device_render_area_count = p_device_render_areas.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DeviceGroupRenderPassBeginInfoKHR<'a> = DeviceGroupRenderPassBeginInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupCommandBufferBeginInfo.html>"]
#[doc(alias = "VkDeviceGroupCommandBufferBeginInfo")]
pub struct DeviceGroupCommandBufferBeginInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_mask: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceGroupCommandBufferBeginInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceGroupCommandBufferBeginInfo;
}
unsafe impl<'a> Send for DeviceGroupCommandBufferBeginInfo<'a> {}
unsafe impl<'a> Sync for DeviceGroupCommandBufferBeginInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<CommandBufferBeginInfo<'b>>
    for DeviceGroupCommandBufferBeginInfo<'a>
{
}
impl<'a> Default for DeviceGroupCommandBufferBeginInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_mask: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceGroupCommandBufferBeginInfo<'a> {
    #[inline]
    pub fn device_mask(mut self, value: u32) -> Self {
        self.device_mask = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DeviceGroupCommandBufferBeginInfoKHR<'a> = DeviceGroupCommandBufferBeginInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupSubmitInfo.html>"]
#[doc(alias = "VkDeviceGroupSubmitInfo")]
pub struct DeviceGroupSubmitInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) wait_semaphore_count: u32,
    pub(crate) p_wait_semaphore_device_indices: *const u32,
    pub(crate) command_buffer_count: u32,
    pub(crate) p_command_buffer_device_masks: *const u32,
    pub(crate) signal_semaphore_count: u32,
    pub(crate) p_signal_semaphore_device_indices: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceGroupSubmitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceGroupSubmitInfo;
}
unsafe impl<'a> Send for DeviceGroupSubmitInfo<'a> {}
unsafe impl<'a> Sync for DeviceGroupSubmitInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo<'b>> for DeviceGroupSubmitInfo<'a> {}
impl<'a> Default for DeviceGroupSubmitInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            wait_semaphore_count: Default::default(),
            p_wait_semaphore_device_indices: ptr::null(),
            command_buffer_count: Default::default(),
            p_command_buffer_device_masks: ptr::null(),
            signal_semaphore_count: Default::default(),
            p_signal_semaphore_device_indices: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceGroupSubmitInfo<'a> {
    #[inline]
    pub fn wait_semaphore_device_indices(
        mut self,
        p_wait_semaphore_device_indices: impl AsSlice<'a, u32>,
    ) -> Self {
        self.p_wait_semaphore_device_indices =
            p_wait_semaphore_device_indices.as_slice().as_ptr().cast();
        self.wait_semaphore_count = p_wait_semaphore_device_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn command_buffer_device_masks(
        mut self,
        p_command_buffer_device_masks: impl AsSlice<'a, u32>,
    ) -> Self {
        self.p_command_buffer_device_masks =
            p_command_buffer_device_masks.as_slice().as_ptr().cast();
        self.command_buffer_count = p_command_buffer_device_masks.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn signal_semaphore_device_indices(
        mut self,
        p_signal_semaphore_device_indices: impl AsSlice<'a, u32>,
    ) -> Self {
        self.p_signal_semaphore_device_indices =
            p_signal_semaphore_device_indices.as_slice().as_ptr().cast();
        self.signal_semaphore_count = p_signal_semaphore_device_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DeviceGroupSubmitInfoKHR<'a> = DeviceGroupSubmitInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupBindSparseInfo.html>"]
#[doc(alias = "VkDeviceGroupBindSparseInfo")]
pub struct DeviceGroupBindSparseInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub resource_device_index: u32,
    pub memory_device_index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceGroupBindSparseInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceGroupBindSparseInfo;
}
unsafe impl<'a> Send for DeviceGroupBindSparseInfo<'a> {}
unsafe impl<'a> Sync for DeviceGroupBindSparseInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BindSparseInfo<'b>> for DeviceGroupBindSparseInfo<'a> {}
impl<'a> Default for DeviceGroupBindSparseInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            resource_device_index: Default::default(),
            memory_device_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceGroupBindSparseInfo<'a> {
    #[inline]
    pub fn resource_device_index(mut self, value: u32) -> Self {
        self.resource_device_index = value;
        self
    }
    #[inline]
    pub fn memory_device_index(mut self, value: u32) -> Self {
        self.memory_device_index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DeviceGroupBindSparseInfoKHR<'a> = DeviceGroupBindSparseInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindBufferMemoryDeviceGroupInfo.html>"]
#[doc(alias = "VkBindBufferMemoryDeviceGroupInfo")]
pub struct BindBufferMemoryDeviceGroupInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) device_index_count: u32,
    pub(crate) p_device_indices: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BindBufferMemoryDeviceGroupInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BindBufferMemoryDeviceGroupInfo;
}
unsafe impl<'a> Send for BindBufferMemoryDeviceGroupInfo<'a> {}
unsafe impl<'a> Sync for BindBufferMemoryDeviceGroupInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BindBufferMemoryInfo<'b>>
    for BindBufferMemoryDeviceGroupInfo<'a>
{
}
impl<'a> Default for BindBufferMemoryDeviceGroupInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_index_count: Default::default(),
            p_device_indices: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BindBufferMemoryDeviceGroupInfo<'a> {
    #[inline]
    pub fn device_indices(mut self, p_device_indices: impl AsSlice<'a, u32>) -> Self {
        self.p_device_indices = p_device_indices.as_slice().as_ptr().cast();
        self.device_index_count = p_device_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type BindBufferMemoryDeviceGroupInfoKHR<'a> = BindBufferMemoryDeviceGroupInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemoryDeviceGroupInfo.html>"]
#[doc(alias = "VkBindImageMemoryDeviceGroupInfo")]
pub struct BindImageMemoryDeviceGroupInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) device_index_count: u32,
    pub(crate) p_device_indices: *const u32,
    pub(crate) split_instance_bind_region_count: u32,
    pub(crate) p_split_instance_bind_regions: *const Rect2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BindImageMemoryDeviceGroupInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BindImageMemoryDeviceGroupInfo;
}
unsafe impl<'a> Send for BindImageMemoryDeviceGroupInfo<'a> {}
unsafe impl<'a> Sync for BindImageMemoryDeviceGroupInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BindImageMemoryInfo<'b>>
    for BindImageMemoryDeviceGroupInfo<'a>
{
}
impl<'a> Default for BindImageMemoryDeviceGroupInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_index_count: Default::default(),
            p_device_indices: ptr::null(),
            split_instance_bind_region_count: Default::default(),
            p_split_instance_bind_regions: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BindImageMemoryDeviceGroupInfo<'a> {
    #[inline]
    pub fn device_indices(mut self, p_device_indices: impl AsSlice<'a, u32>) -> Self {
        self.p_device_indices = p_device_indices.as_slice().as_ptr().cast();
        self.device_index_count = p_device_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn split_instance_bind_regions(
        mut self,
        p_split_instance_bind_regions: impl AsSlice<'a, Rect2D>,
    ) -> Self {
        self.p_split_instance_bind_regions =
            p_split_instance_bind_regions.as_slice().as_ptr().cast();
        self.split_instance_bind_region_count = p_split_instance_bind_regions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type BindImageMemoryDeviceGroupInfoKHR<'a> = BindImageMemoryDeviceGroupInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGroupProperties.html>"]
#[doc(alias = "VkPhysicalDeviceGroupProperties")]
pub struct PhysicalDeviceGroupProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) physical_device_count: u32,
    pub(crate) physical_devices: [Option<PhysicalDevice>; MAX_DEVICE_GROUP_SIZE as _],
    pub subset_allocation: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceGroupProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceGroupProperties;
}
unsafe impl<'a> Send for PhysicalDeviceGroupProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceGroupProperties<'a> {}
impl<'a> Default for PhysicalDeviceGroupProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            physical_device_count: Default::default(),
            physical_devices: Default::default(),
            subset_allocation: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceGroupProperties<'a> {
    #[inline]
    pub fn subset_allocation(mut self, value: impl Into<Bool32>) -> Self {
        self.subset_allocation = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceGroupPropertiesKHR<'a> = PhysicalDeviceGroupProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupDeviceCreateInfo.html>"]
#[doc(alias = "VkDeviceGroupDeviceCreateInfo")]
pub struct DeviceGroupDeviceCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) physical_device_count: u32,
    pub(crate) p_physical_devices: *const PhysicalDevice,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceGroupDeviceCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceGroupDeviceCreateInfo;
}
unsafe impl<'a> Send for DeviceGroupDeviceCreateInfo<'a> {}
unsafe impl<'a> Sync for DeviceGroupDeviceCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>> for DeviceGroupDeviceCreateInfo<'a> {}
impl<'a> Default for DeviceGroupDeviceCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            physical_device_count: Default::default(),
            p_physical_devices: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceGroupDeviceCreateInfo<'a> {
    #[inline]
    pub fn physical_devices<V0: Alias<raw::PhysicalDevice> + 'a>(
        mut self,
        p_physical_devices: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_physical_devices = p_physical_devices.as_slice().as_ptr().cast();
        self.physical_device_count = p_physical_devices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DeviceGroupDeviceCreateInfoKHR<'a> = DeviceGroupDeviceCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryRequirementsInfo2.html>"]
#[doc(alias = "VkBufferMemoryRequirementsInfo2")]
pub struct BufferMemoryRequirementsInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub buffer: Option<Buffer>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferMemoryRequirementsInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferMemoryRequirementsInfo2;
}
unsafe impl<'a> Send for BufferMemoryRequirementsInfo2<'a> {}
unsafe impl<'a> Sync for BufferMemoryRequirementsInfo2<'a> {}
impl<'a> Default for BufferMemoryRequirementsInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            buffer: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferMemoryRequirementsInfo2<'a> {
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type BufferMemoryRequirementsInfo2KHR<'a> = BufferMemoryRequirementsInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryRequirementsInfo2.html>"]
#[doc(alias = "VkImageMemoryRequirementsInfo2")]
pub struct ImageMemoryRequirementsInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image: Option<Image>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageMemoryRequirementsInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageMemoryRequirementsInfo2;
}
unsafe impl<'a> Send for ImageMemoryRequirementsInfo2<'a> {}
unsafe impl<'a> Sync for ImageMemoryRequirementsInfo2<'a> {}
impl<'a> Default for ImageMemoryRequirementsInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageMemoryRequirementsInfo2<'a> {
    #[inline]
    pub fn image(mut self, value: &'a Image) -> Self {
        self.image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ImageMemoryRequirementsInfo2KHR<'a> = ImageMemoryRequirementsInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSparseMemoryRequirementsInfo2.html>"]
#[doc(alias = "VkImageSparseMemoryRequirementsInfo2")]
pub struct ImageSparseMemoryRequirementsInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image: Option<Image>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageSparseMemoryRequirementsInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageSparseMemoryRequirementsInfo2;
}
unsafe impl<'a> Send for ImageSparseMemoryRequirementsInfo2<'a> {}
unsafe impl<'a> Sync for ImageSparseMemoryRequirementsInfo2<'a> {}
impl<'a> Default for ImageSparseMemoryRequirementsInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageSparseMemoryRequirementsInfo2<'a> {
    #[inline]
    pub fn image(mut self, value: &'a Image) -> Self {
        self.image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ImageSparseMemoryRequirementsInfo2KHR<'a> = ImageSparseMemoryRequirementsInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements2.html>"]
#[doc(alias = "VkMemoryRequirements2")]
pub struct MemoryRequirements2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory_requirements: MemoryRequirements,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryRequirements2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryRequirements2;
}
unsafe impl<'a> Send for MemoryRequirements2<'a> {}
unsafe impl<'a> Sync for MemoryRequirements2<'a> {}
impl<'a> Default for MemoryRequirements2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory_requirements: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryRequirements2<'a> {
    #[inline]
    pub fn memory_requirements(mut self, value: MemoryRequirements) -> Self {
        self.memory_requirements = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type MemoryRequirements2KHR<'a> = MemoryRequirements2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryRequirements2.html>"]
#[doc(alias = "VkSparseImageMemoryRequirements2")]
pub struct SparseImageMemoryRequirements2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory_requirements: SparseImageMemoryRequirements,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SparseImageMemoryRequirements2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SparseImageMemoryRequirements2;
}
unsafe impl<'a> Send for SparseImageMemoryRequirements2<'a> {}
unsafe impl<'a> Sync for SparseImageMemoryRequirements2<'a> {}
impl<'a> Default for SparseImageMemoryRequirements2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory_requirements: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SparseImageMemoryRequirements2<'a> {
    #[inline]
    pub fn memory_requirements(mut self, value: SparseImageMemoryRequirements) -> Self {
        self.memory_requirements = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SparseImageMemoryRequirements2KHR<'a> = SparseImageMemoryRequirements2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures2.html>"]
#[doc(alias = "VkPhysicalDeviceFeatures2")]
pub struct PhysicalDeviceFeatures2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub features: PhysicalDeviceFeatures,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFeatures2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceFeatures2;
}
unsafe impl<'a> Send for PhysicalDeviceFeatures2<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFeatures2<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>> for PhysicalDeviceFeatures2<'a> {}
impl<'a> Default for PhysicalDeviceFeatures2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            features: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFeatures2<'a> {
    #[inline]
    pub fn features(mut self, value: PhysicalDeviceFeatures) -> Self {
        self.features = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceFeatures2KHR<'a> = PhysicalDeviceFeatures2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties2.html>"]
#[doc(alias = "VkPhysicalDeviceProperties2")]
pub struct PhysicalDeviceProperties2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub properties: PhysicalDeviceProperties,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceProperties2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceProperties2;
}
unsafe impl<'a> Send for PhysicalDeviceProperties2<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceProperties2<'a> {}
impl<'a> Default for PhysicalDeviceProperties2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceProperties2<'a> {
    #[inline]
    pub fn properties(mut self, value: PhysicalDeviceProperties) -> Self {
        self.properties = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceProperties2KHR<'a> = PhysicalDeviceProperties2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties2.html>"]
#[doc(alias = "VkFormatProperties2")]
pub struct FormatProperties2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub format_properties: FormatProperties,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for FormatProperties2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FormatProperties2;
}
unsafe impl<'a> Send for FormatProperties2<'a> {}
unsafe impl<'a> Sync for FormatProperties2<'a> {}
impl<'a> Default for FormatProperties2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            format_properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> FormatProperties2<'a> {
    #[inline]
    pub fn format_properties(mut self, value: FormatProperties) -> Self {
        self.format_properties = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type FormatProperties2KHR<'a> = FormatProperties2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatProperties2.html>"]
#[doc(alias = "VkImageFormatProperties2")]
pub struct ImageFormatProperties2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_format_properties: ImageFormatProperties,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageFormatProperties2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageFormatProperties2;
}
unsafe impl<'a> Send for ImageFormatProperties2<'a> {}
unsafe impl<'a> Sync for ImageFormatProperties2<'a> {}
impl<'a> Default for ImageFormatProperties2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_format_properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageFormatProperties2<'a> {
    #[inline]
    pub fn image_format_properties(mut self, value: ImageFormatProperties) -> Self {
        self.image_format_properties = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ImageFormatProperties2KHR<'a> = ImageFormatProperties2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageFormatInfo2.html>"]
#[doc(alias = "VkPhysicalDeviceImageFormatInfo2")]
pub struct PhysicalDeviceImageFormatInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub format: Format,
    pub ty: ImageType,
    pub tiling: ImageTiling,
    pub usage: ImageUsageFlags,
    pub flags: ImageCreateFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageFormatInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceImageFormatInfo2;
}
unsafe impl<'a> Send for PhysicalDeviceImageFormatInfo2<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageFormatInfo2<'a> {}
impl<'a> Default for PhysicalDeviceImageFormatInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            format: Format::Undefined,
            ty: ImageType::Type1D,
            tiling: ImageTiling::Optimal,
            usage: Default::default(),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageFormatInfo2<'a> {
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn ty(mut self, value: ImageType) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn tiling(mut self, value: ImageTiling) -> Self {
        self.tiling = value;
        self
    }
    #[inline]
    pub fn usage(mut self, value: ImageUsageFlags) -> Self {
        self.usage = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: ImageCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceImageFormatInfo2KHR<'a> = PhysicalDeviceImageFormatInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties2.html>"]
#[doc(alias = "VkQueueFamilyProperties2")]
pub struct QueueFamilyProperties2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub queue_family_properties: QueueFamilyProperties,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for QueueFamilyProperties2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QueueFamilyProperties2;
}
unsafe impl<'a> Send for QueueFamilyProperties2<'a> {}
unsafe impl<'a> Sync for QueueFamilyProperties2<'a> {}
impl<'a> Default for QueueFamilyProperties2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            queue_family_properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> QueueFamilyProperties2<'a> {
    #[inline]
    pub fn queue_family_properties(mut self, value: QueueFamilyProperties) -> Self {
        self.queue_family_properties = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type QueueFamilyProperties2KHR<'a> = QueueFamilyProperties2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties2.html>"]
#[doc(alias = "VkPhysicalDeviceMemoryProperties2")]
pub struct PhysicalDeviceMemoryProperties2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory_properties: PhysicalDeviceMemoryProperties,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMemoryProperties2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMemoryProperties2;
}
unsafe impl<'a> Send for PhysicalDeviceMemoryProperties2<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMemoryProperties2<'a> {}
impl<'a> Default for PhysicalDeviceMemoryProperties2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory_properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMemoryProperties2<'a> {
    #[inline]
    pub fn memory_properties(mut self, value: PhysicalDeviceMemoryProperties) -> Self {
        self.memory_properties = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceMemoryProperties2KHR<'a> = PhysicalDeviceMemoryProperties2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatProperties2.html>"]
#[doc(alias = "VkSparseImageFormatProperties2")]
pub struct SparseImageFormatProperties2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub properties: SparseImageFormatProperties,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SparseImageFormatProperties2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SparseImageFormatProperties2;
}
unsafe impl<'a> Send for SparseImageFormatProperties2<'a> {}
unsafe impl<'a> Sync for SparseImageFormatProperties2<'a> {}
impl<'a> Default for SparseImageFormatProperties2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SparseImageFormatProperties2<'a> {
    #[inline]
    pub fn properties(mut self, value: SparseImageFormatProperties) -> Self {
        self.properties = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SparseImageFormatProperties2KHR<'a> = SparseImageFormatProperties2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSparseImageFormatInfo2.html>"]
#[doc(alias = "VkPhysicalDeviceSparseImageFormatInfo2")]
pub struct PhysicalDeviceSparseImageFormatInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub format: Format,
    pub ty: ImageType,
    pub samples: SampleCountFlags,
    pub usage: ImageUsageFlags,
    pub tiling: ImageTiling,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSparseImageFormatInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceSparseImageFormatInfo2;
}
unsafe impl<'a> Send for PhysicalDeviceSparseImageFormatInfo2<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSparseImageFormatInfo2<'a> {}
impl<'a> Default for PhysicalDeviceSparseImageFormatInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            format: Format::Undefined,
            ty: ImageType::Type1D,
            samples: Default::default(),
            usage: Default::default(),
            tiling: ImageTiling::Optimal,
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSparseImageFormatInfo2<'a> {
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn ty(mut self, value: ImageType) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn samples(mut self, value: SampleCountFlags) -> Self {
        self.samples = value;
        self
    }
    #[inline]
    pub fn usage(mut self, value: ImageUsageFlags) -> Self {
        self.usage = value;
        self
    }
    #[inline]
    pub fn tiling(mut self, value: ImageTiling) -> Self {
        self.tiling = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceSparseImageFormatInfo2KHR<'a> = PhysicalDeviceSparseImageFormatInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePointClippingProperties.html>"]
#[doc(alias = "VkPhysicalDevicePointClippingProperties")]
pub struct PhysicalDevicePointClippingProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub point_clipping_behavior: PointClippingBehavior,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePointClippingProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDevicePointClippingProperties;
}
unsafe impl<'a> Send for PhysicalDevicePointClippingProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePointClippingProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDevicePointClippingProperties<'a>
{
}
impl<'a> Default for PhysicalDevicePointClippingProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            point_clipping_behavior: PointClippingBehavior::AllClipPlanes,
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePointClippingProperties<'a> {
    #[inline]
    pub fn point_clipping_behavior(mut self, value: PointClippingBehavior) -> Self {
        self.point_clipping_behavior = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDevicePointClippingPropertiesKHR<'a> = PhysicalDevicePointClippingProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassInputAttachmentAspectCreateInfo.html>"]
#[doc(alias = "VkRenderPassInputAttachmentAspectCreateInfo")]
pub struct RenderPassInputAttachmentAspectCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) aspect_reference_count: u32,
    pub(crate) p_aspect_references: *const InputAttachmentAspectReference,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassInputAttachmentAspectCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassInputAttachmentAspectCreateInfo;
}
unsafe impl<'a> Send for RenderPassInputAttachmentAspectCreateInfo<'a> {}
unsafe impl<'a> Sync for RenderPassInputAttachmentAspectCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderPassCreateInfo<'b>>
    for RenderPassInputAttachmentAspectCreateInfo<'a>
{
}
impl<'a> Default for RenderPassInputAttachmentAspectCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            aspect_reference_count: Default::default(),
            p_aspect_references: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassInputAttachmentAspectCreateInfo<'a> {
    #[inline]
    pub fn aspect_references(
        mut self,
        p_aspect_references: impl AsSlice<'a, InputAttachmentAspectReference>,
    ) -> Self {
        self.p_aspect_references = p_aspect_references.as_slice().as_ptr().cast();
        self.aspect_reference_count = p_aspect_references.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type RenderPassInputAttachmentAspectCreateInfoKHR<'a> =
    RenderPassInputAttachmentAspectCreateInfo<'a>;
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInputAttachmentAspectReference.html>"]
#[doc(alias = "VkInputAttachmentAspectReference")]
pub struct InputAttachmentAspectReference {
    pub subpass: u32,
    pub input_attachment_index: u32,
    pub aspect_mask: ImageAspectFlags,
}
unsafe impl Send for InputAttachmentAspectReference {}
unsafe impl Sync for InputAttachmentAspectReference {}
impl Default for InputAttachmentAspectReference {
    fn default() -> Self {
        Self {
            subpass: Default::default(),
            input_attachment_index: Default::default(),
            aspect_mask: Default::default(),
        }
    }
}
impl InputAttachmentAspectReference {
    #[inline]
    pub fn subpass(mut self, value: u32) -> Self {
        self.subpass = value;
        self
    }
    #[inline]
    pub fn input_attachment_index(mut self, value: u32) -> Self {
        self.input_attachment_index = value;
        self
    }
    #[inline]
    pub fn aspect_mask(mut self, value: ImageAspectFlags) -> Self {
        self.aspect_mask = value;
        self
    }
}
pub type InputAttachmentAspectReferenceKHR = InputAttachmentAspectReference;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewUsageCreateInfo.html>"]
#[doc(alias = "VkImageViewUsageCreateInfo")]
pub struct ImageViewUsageCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub usage: ImageUsageFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageViewUsageCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageViewUsageCreateInfo;
}
unsafe impl<'a> Send for ImageViewUsageCreateInfo<'a> {}
unsafe impl<'a> Sync for ImageViewUsageCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageViewCreateInfo<'b>> for ImageViewUsageCreateInfo<'a> {}
impl<'a> Default for ImageViewUsageCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            usage: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageViewUsageCreateInfo<'a> {
    #[inline]
    pub fn usage(mut self, value: ImageUsageFlags) -> Self {
        self.usage = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ImageViewUsageCreateInfoKHR<'a> = ImageViewUsageCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationDomainOriginStateCreateInfo.html>"]
#[doc(alias = "VkPipelineTessellationDomainOriginStateCreateInfo")]
pub struct PipelineTessellationDomainOriginStateCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub domain_origin: TessellationDomainOrigin,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineTessellationDomainOriginStateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineTessellationDomainOriginStateCreateInfo;
}
unsafe impl<'a> Send for PipelineTessellationDomainOriginStateCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineTessellationDomainOriginStateCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineTessellationStateCreateInfo<'b>>
    for PipelineTessellationDomainOriginStateCreateInfo<'a>
{
}
impl<'a> Default for PipelineTessellationDomainOriginStateCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            domain_origin: TessellationDomainOrigin::UpperLeft,
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineTessellationDomainOriginStateCreateInfo<'a> {
    #[inline]
    pub fn domain_origin(mut self, value: TessellationDomainOrigin) -> Self {
        self.domain_origin = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PipelineTessellationDomainOriginStateCreateInfoKHR<'a> =
    PipelineTessellationDomainOriginStateCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassMultiviewCreateInfo.html>"]
#[doc(alias = "VkRenderPassMultiviewCreateInfo")]
pub struct RenderPassMultiviewCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) subpass_count: u32,
    pub(crate) p_view_masks: *const u32,
    pub(crate) dependency_count: u32,
    pub(crate) p_view_offsets: *const i32,
    pub(crate) correlation_mask_count: u32,
    pub(crate) p_correlation_masks: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassMultiviewCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassMultiviewCreateInfo;
}
unsafe impl<'a> Send for RenderPassMultiviewCreateInfo<'a> {}
unsafe impl<'a> Sync for RenderPassMultiviewCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderPassCreateInfo<'b>>
    for RenderPassMultiviewCreateInfo<'a>
{
}
impl<'a> Default for RenderPassMultiviewCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            subpass_count: Default::default(),
            p_view_masks: ptr::null(),
            dependency_count: Default::default(),
            p_view_offsets: ptr::null(),
            correlation_mask_count: Default::default(),
            p_correlation_masks: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassMultiviewCreateInfo<'a> {
    #[inline]
    pub fn view_masks(mut self, p_view_masks: impl AsSlice<'a, u32>) -> Self {
        self.p_view_masks = p_view_masks.as_slice().as_ptr().cast();
        self.subpass_count = p_view_masks.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn view_offsets(mut self, p_view_offsets: impl AsSlice<'a, i32>) -> Self {
        self.p_view_offsets = p_view_offsets.as_slice().as_ptr().cast();
        self.dependency_count = p_view_offsets.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn correlation_masks(mut self, p_correlation_masks: impl AsSlice<'a, u32>) -> Self {
        self.p_correlation_masks = p_correlation_masks.as_slice().as_ptr().cast();
        self.correlation_mask_count = p_correlation_masks.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type RenderPassMultiviewCreateInfoKHR<'a> = RenderPassMultiviewCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceMultiviewFeatures")]
pub struct PhysicalDeviceMultiviewFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub multiview: Bool32,
    pub multiview_geometry_shader: Bool32,
    pub multiview_tessellation_shader: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMultiviewFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMultiviewFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceMultiviewFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMultiviewFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMultiviewFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMultiviewFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceMultiviewFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            multiview: Default::default(),
            multiview_geometry_shader: Default::default(),
            multiview_tessellation_shader: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMultiviewFeatures<'a> {
    #[inline]
    pub fn multiview(mut self, value: impl Into<Bool32>) -> Self {
        self.multiview = value.into();
        self
    }
    #[inline]
    pub fn multiview_geometry_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.multiview_geometry_shader = value.into();
        self
    }
    #[inline]
    pub fn multiview_tessellation_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.multiview_tessellation_shader = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceMultiviewFeaturesKHR<'a> = PhysicalDeviceMultiviewFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewProperties.html>"]
#[doc(alias = "VkPhysicalDeviceMultiviewProperties")]
pub struct PhysicalDeviceMultiviewProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_multiview_view_count: u32,
    pub max_multiview_instance_index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMultiviewProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMultiviewProperties;
}
unsafe impl<'a> Send for PhysicalDeviceMultiviewProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMultiviewProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceMultiviewProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceMultiviewProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_multiview_view_count: Default::default(),
            max_multiview_instance_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMultiviewProperties<'a> {
    #[inline]
    pub fn max_multiview_view_count(mut self, value: u32) -> Self {
        self.max_multiview_view_count = value;
        self
    }
    #[inline]
    pub fn max_multiview_instance_index(mut self, value: u32) -> Self {
        self.max_multiview_instance_index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceMultiviewPropertiesKHR<'a> = PhysicalDeviceMultiviewProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVariablePointersFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceVariablePointersFeatures")]
pub struct PhysicalDeviceVariablePointersFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub variable_pointers_storage_buffer: Bool32,
    pub variable_pointers: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceVariablePointersFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceVariablePointersFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceVariablePointersFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceVariablePointersFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceVariablePointersFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceVariablePointersFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceVariablePointersFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            variable_pointers_storage_buffer: Default::default(),
            variable_pointers: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceVariablePointersFeatures<'a> {
    #[inline]
    pub fn variable_pointers_storage_buffer(mut self, value: impl Into<Bool32>) -> Self {
        self.variable_pointers_storage_buffer = value.into();
        self
    }
    #[inline]
    pub fn variable_pointers(mut self, value: impl Into<Bool32>) -> Self {
        self.variable_pointers = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceVariablePointersFeaturesKHR<'a> = PhysicalDeviceVariablePointersFeatures<'a>;
pub type PhysicalDeviceVariablePointerFeaturesKHR<'a> = PhysicalDeviceVariablePointersFeatures<'a>;
pub type PhysicalDeviceVariablePointerFeatures<'a> = PhysicalDeviceVariablePointersFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProtectedMemoryFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceProtectedMemoryFeatures")]
pub struct PhysicalDeviceProtectedMemoryFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub protected_memory: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceProtectedMemoryFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceProtectedMemoryFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceProtectedMemoryFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceProtectedMemoryFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceProtectedMemoryFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceProtectedMemoryFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceProtectedMemoryFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            protected_memory: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceProtectedMemoryFeatures<'a> {
    #[inline]
    pub fn protected_memory(mut self, value: impl Into<Bool32>) -> Self {
        self.protected_memory = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProtectedMemoryProperties.html>"]
#[doc(alias = "VkPhysicalDeviceProtectedMemoryProperties")]
pub struct PhysicalDeviceProtectedMemoryProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub protected_no_fault: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceProtectedMemoryProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceProtectedMemoryProperties;
}
unsafe impl<'a> Send for PhysicalDeviceProtectedMemoryProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceProtectedMemoryProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceProtectedMemoryProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceProtectedMemoryProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            protected_no_fault: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceProtectedMemoryProperties<'a> {
    #[inline]
    pub fn protected_no_fault(mut self, value: impl Into<Bool32>) -> Self {
        self.protected_no_fault = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueInfo2.html>"]
#[doc(alias = "VkDeviceQueueInfo2")]
pub struct DeviceQueueInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: DeviceQueueCreateFlags,
    pub queue_family_index: u32,
    pub queue_index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceQueueInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceQueueInfo2;
}
unsafe impl<'a> Send for DeviceQueueInfo2<'a> {}
unsafe impl<'a> Sync for DeviceQueueInfo2<'a> {}
impl<'a> Default for DeviceQueueInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            queue_family_index: Default::default(),
            queue_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceQueueInfo2<'a> {
    #[inline]
    pub fn flags(mut self, value: DeviceQueueCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn queue_family_index(mut self, value: u32) -> Self {
        self.queue_family_index = value;
        self
    }
    #[inline]
    pub fn queue_index(mut self, value: u32) -> Self {
        self.queue_index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkProtectedSubmitInfo.html>"]
#[doc(alias = "VkProtectedSubmitInfo")]
pub struct ProtectedSubmitInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub protected_submit: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ProtectedSubmitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ProtectedSubmitInfo;
}
unsafe impl<'a> Send for ProtectedSubmitInfo<'a> {}
unsafe impl<'a> Sync for ProtectedSubmitInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo<'b>> for ProtectedSubmitInfo<'a> {}
impl<'a> Default for ProtectedSubmitInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            protected_submit: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ProtectedSubmitInfo<'a> {
    #[inline]
    pub fn protected_submit(mut self, value: impl Into<Bool32>) -> Self {
        self.protected_submit = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionCreateInfo.html>"]
#[doc(alias = "VkSamplerYcbcrConversionCreateInfo")]
pub struct SamplerYcbcrConversionCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub format: Format,
    pub ycbcr_model: SamplerYcbcrModelConversion,
    pub ycbcr_range: SamplerYcbcrRange,
    pub components: ComponentMapping,
    pub x_chroma_offset: ChromaLocation,
    pub y_chroma_offset: ChromaLocation,
    pub chroma_filter: Filter,
    pub force_explicit_reconstruction: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SamplerYcbcrConversionCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SamplerYcbcrConversionCreateInfo;
}
unsafe impl<'a> Send for SamplerYcbcrConversionCreateInfo<'a> {}
unsafe impl<'a> Sync for SamplerYcbcrConversionCreateInfo<'a> {}
impl<'a> Default for SamplerYcbcrConversionCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            format: Format::Undefined,
            ycbcr_model: SamplerYcbcrModelConversion::RgbIdentity,
            ycbcr_range: SamplerYcbcrRange::ItuFull,
            components: Default::default(),
            x_chroma_offset: ChromaLocation::CositedEven,
            y_chroma_offset: ChromaLocation::CositedEven,
            chroma_filter: Filter::Nearest,
            force_explicit_reconstruction: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SamplerYcbcrConversionCreateInfo<'a> {
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn ycbcr_model(mut self, value: SamplerYcbcrModelConversion) -> Self {
        self.ycbcr_model = value;
        self
    }
    #[inline]
    pub fn ycbcr_range(mut self, value: SamplerYcbcrRange) -> Self {
        self.ycbcr_range = value;
        self
    }
    #[inline]
    pub fn components(mut self, value: ComponentMapping) -> Self {
        self.components = value;
        self
    }
    #[inline]
    pub fn x_chroma_offset(mut self, value: ChromaLocation) -> Self {
        self.x_chroma_offset = value;
        self
    }
    #[inline]
    pub fn y_chroma_offset(mut self, value: ChromaLocation) -> Self {
        self.y_chroma_offset = value;
        self
    }
    #[inline]
    pub fn chroma_filter(mut self, value: Filter) -> Self {
        self.chroma_filter = value;
        self
    }
    #[inline]
    pub fn force_explicit_reconstruction(mut self, value: impl Into<Bool32>) -> Self {
        self.force_explicit_reconstruction = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SamplerYcbcrConversionCreateInfoKHR<'a> = SamplerYcbcrConversionCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionInfo.html>"]
#[doc(alias = "VkSamplerYcbcrConversionInfo")]
pub struct SamplerYcbcrConversionInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub conversion: Option<SamplerYcbcrConversion>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SamplerYcbcrConversionInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SamplerYcbcrConversionInfo;
}
unsafe impl<'a> Send for SamplerYcbcrConversionInfo<'a> {}
unsafe impl<'a> Sync for SamplerYcbcrConversionInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SamplerCreateInfo<'b>> for SamplerYcbcrConversionInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageViewCreateInfo<'b>> for SamplerYcbcrConversionInfo<'a> {}
impl<'a> Default for SamplerYcbcrConversionInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            conversion: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SamplerYcbcrConversionInfo<'a> {
    #[inline]
    pub fn conversion(mut self, value: &'a SamplerYcbcrConversion) -> Self {
        self.conversion = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SamplerYcbcrConversionInfoKHR<'a> = SamplerYcbcrConversionInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImagePlaneMemoryInfo.html>"]
#[doc(alias = "VkBindImagePlaneMemoryInfo")]
pub struct BindImagePlaneMemoryInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub plane_aspect: ImageAspectFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BindImagePlaneMemoryInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BindImagePlaneMemoryInfo;
}
unsafe impl<'a> Send for BindImagePlaneMemoryInfo<'a> {}
unsafe impl<'a> Sync for BindImagePlaneMemoryInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BindImageMemoryInfo<'b>> for BindImagePlaneMemoryInfo<'a> {}
impl<'a> Default for BindImagePlaneMemoryInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            plane_aspect: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BindImagePlaneMemoryInfo<'a> {
    #[inline]
    pub fn plane_aspect(mut self, value: ImageAspectFlags) -> Self {
        self.plane_aspect = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type BindImagePlaneMemoryInfoKHR<'a> = BindImagePlaneMemoryInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImagePlaneMemoryRequirementsInfo.html>"]
#[doc(alias = "VkImagePlaneMemoryRequirementsInfo")]
pub struct ImagePlaneMemoryRequirementsInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub plane_aspect: ImageAspectFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImagePlaneMemoryRequirementsInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImagePlaneMemoryRequirementsInfo;
}
unsafe impl<'a> Send for ImagePlaneMemoryRequirementsInfo<'a> {}
unsafe impl<'a> Sync for ImagePlaneMemoryRequirementsInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageMemoryRequirementsInfo2<'b>>
    for ImagePlaneMemoryRequirementsInfo<'a>
{
}
impl<'a> Default for ImagePlaneMemoryRequirementsInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            plane_aspect: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImagePlaneMemoryRequirementsInfo<'a> {
    #[inline]
    pub fn plane_aspect(mut self, value: ImageAspectFlags) -> Self {
        self.plane_aspect = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ImagePlaneMemoryRequirementsInfoKHR<'a> = ImagePlaneMemoryRequirementsInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSamplerYcbcrConversionFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceSamplerYcbcrConversionFeatures")]
pub struct PhysicalDeviceSamplerYcbcrConversionFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub sampler_ycbcr_conversion: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSamplerYcbcrConversionFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceSamplerYcbcrConversionFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceSamplerYcbcrConversionFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSamplerYcbcrConversionFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceSamplerYcbcrConversionFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceSamplerYcbcrConversionFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceSamplerYcbcrConversionFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            sampler_ycbcr_conversion: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSamplerYcbcrConversionFeatures<'a> {
    #[inline]
    pub fn sampler_ycbcr_conversion(mut self, value: impl Into<Bool32>) -> Self {
        self.sampler_ycbcr_conversion = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceSamplerYcbcrConversionFeaturesKHR<'a> =
    PhysicalDeviceSamplerYcbcrConversionFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionImageFormatProperties.html>"]
#[doc(alias = "VkSamplerYcbcrConversionImageFormatProperties")]
pub struct SamplerYcbcrConversionImageFormatProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub combined_image_sampler_descriptor_count: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SamplerYcbcrConversionImageFormatProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SamplerYcbcrConversionImageFormatProperties;
}
unsafe impl<'a> Send for SamplerYcbcrConversionImageFormatProperties<'a> {}
unsafe impl<'a> Sync for SamplerYcbcrConversionImageFormatProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageFormatProperties2<'b>>
    for SamplerYcbcrConversionImageFormatProperties<'a>
{
}
impl<'a> Default for SamplerYcbcrConversionImageFormatProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            combined_image_sampler_descriptor_count: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SamplerYcbcrConversionImageFormatProperties<'a> {
    #[inline]
    pub fn combined_image_sampler_descriptor_count(mut self, value: u32) -> Self {
        self.combined_image_sampler_descriptor_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SamplerYcbcrConversionImageFormatPropertiesKHR<'a> =
    SamplerYcbcrConversionImageFormatProperties<'a>;
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateEntry.html>"]
#[doc(alias = "VkDescriptorUpdateTemplateEntry")]
pub struct DescriptorUpdateTemplateEntry {
    pub dst_binding: u32,
    pub dst_array_element: u32,
    pub descriptor_count: u32,
    pub descriptor_type: DescriptorType,
    pub offset: usize,
    pub stride: usize,
}
unsafe impl Send for DescriptorUpdateTemplateEntry {}
unsafe impl Sync for DescriptorUpdateTemplateEntry {}
impl Default for DescriptorUpdateTemplateEntry {
    fn default() -> Self {
        Self {
            dst_binding: Default::default(),
            dst_array_element: Default::default(),
            descriptor_count: Default::default(),
            descriptor_type: DescriptorType::Sampler,
            offset: Default::default(),
            stride: Default::default(),
        }
    }
}
impl DescriptorUpdateTemplateEntry {
    #[inline]
    pub fn dst_binding(mut self, value: u32) -> Self {
        self.dst_binding = value;
        self
    }
    #[inline]
    pub fn dst_array_element(mut self, value: u32) -> Self {
        self.dst_array_element = value;
        self
    }
    #[inline]
    pub fn descriptor_count(mut self, value: u32) -> Self {
        self.descriptor_count = value;
        self
    }
    #[inline]
    pub fn descriptor_type(mut self, value: DescriptorType) -> Self {
        self.descriptor_type = value;
        self
    }
    #[inline]
    pub fn offset(mut self, value: usize) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn stride(mut self, value: usize) -> Self {
        self.stride = value;
        self
    }
}
pub type DescriptorUpdateTemplateEntryKHR = DescriptorUpdateTemplateEntry;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateCreateInfo.html>"]
#[doc(alias = "VkDescriptorUpdateTemplateCreateInfo")]
pub struct DescriptorUpdateTemplateCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub(crate) descriptor_update_entry_count: u32,
    pub(crate) p_descriptor_update_entries: *const DescriptorUpdateTemplateEntry,
    pub template_type: DescriptorUpdateTemplateType,
    pub descriptor_set_layout: Option<DescriptorSetLayout>,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline_layout: Option<PipelineLayout>,
    pub set: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorUpdateTemplateCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DescriptorUpdateTemplateCreateInfo;
}
unsafe impl<'a> Send for DescriptorUpdateTemplateCreateInfo<'a> {}
unsafe impl<'a> Sync for DescriptorUpdateTemplateCreateInfo<'a> {}
impl<'a> Default for DescriptorUpdateTemplateCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            descriptor_update_entry_count: Default::default(),
            p_descriptor_update_entries: ptr::null(),
            template_type: DescriptorUpdateTemplateType::DescriptorSet,
            descriptor_set_layout: Default::default(),
            pipeline_bind_point: PipelineBindPoint::Graphics,
            pipeline_layout: Default::default(),
            set: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorUpdateTemplateCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn template_type(mut self, value: DescriptorUpdateTemplateType) -> Self {
        self.template_type = value;
        self
    }
    #[inline]
    pub fn descriptor_set_layout(mut self, value: &'a DescriptorSetLayout) -> Self {
        self.descriptor_set_layout = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn pipeline_bind_point(mut self, value: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = value;
        self
    }
    #[inline]
    pub fn pipeline_layout(mut self, value: &'a PipelineLayout) -> Self {
        self.pipeline_layout = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn set(mut self, value: u32) -> Self {
        self.set = value;
        self
    }
    #[inline]
    pub fn descriptor_update_entries(
        mut self,
        p_descriptor_update_entries: impl AsSlice<'a, DescriptorUpdateTemplateEntry>,
    ) -> Self {
        self.p_descriptor_update_entries = p_descriptor_update_entries.as_slice().as_ptr().cast();
        self.descriptor_update_entry_count = p_descriptor_update_entries.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DescriptorUpdateTemplateCreateInfoKHR<'a> = DescriptorUpdateTemplateCreateInfo<'a>;
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryProperties.html>"]
#[doc(alias = "VkExternalMemoryProperties")]
pub struct ExternalMemoryProperties {
    pub external_memory_features: ExternalMemoryFeatureFlags,
    pub export_from_imported_handle_types: ExternalMemoryHandleTypeFlags,
    pub compatible_handle_types: ExternalMemoryHandleTypeFlags,
}
unsafe impl Send for ExternalMemoryProperties {}
unsafe impl Sync for ExternalMemoryProperties {}
impl Default for ExternalMemoryProperties {
    fn default() -> Self {
        Self {
            external_memory_features: Default::default(),
            export_from_imported_handle_types: Default::default(),
            compatible_handle_types: Default::default(),
        }
    }
}
impl ExternalMemoryProperties {
    #[inline]
    pub fn external_memory_features(mut self, value: ExternalMemoryFeatureFlags) -> Self {
        self.external_memory_features = value;
        self
    }
    #[inline]
    pub fn export_from_imported_handle_types(
        mut self,
        value: ExternalMemoryHandleTypeFlags,
    ) -> Self {
        self.export_from_imported_handle_types = value;
        self
    }
    #[inline]
    pub fn compatible_handle_types(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.compatible_handle_types = value;
        self
    }
}
pub type ExternalMemoryPropertiesKHR = ExternalMemoryProperties;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalImageFormatInfo.html>"]
#[doc(alias = "VkPhysicalDeviceExternalImageFormatInfo")]
pub struct PhysicalDeviceExternalImageFormatInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExternalImageFormatInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceExternalImageFormatInfo;
}
unsafe impl<'a> Send for PhysicalDeviceExternalImageFormatInfo<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExternalImageFormatInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceImageFormatInfo2<'b>>
    for PhysicalDeviceExternalImageFormatInfo<'a>
{
}
impl<'a> Default for PhysicalDeviceExternalImageFormatInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExternalImageFormatInfo<'a> {
    #[inline]
    pub fn handle_type(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceExternalImageFormatInfoKHR<'a> = PhysicalDeviceExternalImageFormatInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalImageFormatProperties.html>"]
#[doc(alias = "VkExternalImageFormatProperties")]
pub struct ExternalImageFormatProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub external_memory_properties: ExternalMemoryProperties,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExternalImageFormatProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExternalImageFormatProperties;
}
unsafe impl<'a> Send for ExternalImageFormatProperties<'a> {}
unsafe impl<'a> Sync for ExternalImageFormatProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageFormatProperties2<'b>>
    for ExternalImageFormatProperties<'a>
{
}
impl<'a> Default for ExternalImageFormatProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            external_memory_properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExternalImageFormatProperties<'a> {
    #[inline]
    pub fn external_memory_properties(mut self, value: ExternalMemoryProperties) -> Self {
        self.external_memory_properties = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ExternalImageFormatPropertiesKHR<'a> = ExternalImageFormatProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalBufferInfo.html>"]
#[doc(alias = "VkPhysicalDeviceExternalBufferInfo")]
pub struct PhysicalDeviceExternalBufferInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: BufferCreateFlags,
    pub usage: BufferUsageFlags,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExternalBufferInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceExternalBufferInfo;
}
unsafe impl<'a> Send for PhysicalDeviceExternalBufferInfo<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExternalBufferInfo<'a> {}
impl<'a> Default for PhysicalDeviceExternalBufferInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            usage: Default::default(),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExternalBufferInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: BufferCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn usage(mut self, value: BufferUsageFlags) -> Self {
        self.usage = value;
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceExternalBufferInfoKHR<'a> = PhysicalDeviceExternalBufferInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalBufferProperties.html>"]
#[doc(alias = "VkExternalBufferProperties")]
pub struct ExternalBufferProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub external_memory_properties: ExternalMemoryProperties,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExternalBufferProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExternalBufferProperties;
}
unsafe impl<'a> Send for ExternalBufferProperties<'a> {}
unsafe impl<'a> Sync for ExternalBufferProperties<'a> {}
impl<'a> Default for ExternalBufferProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            external_memory_properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExternalBufferProperties<'a> {
    #[inline]
    pub fn external_memory_properties(mut self, value: ExternalMemoryProperties) -> Self {
        self.external_memory_properties = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ExternalBufferPropertiesKHR<'a> = ExternalBufferProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceIDProperties.html>"]
#[doc(alias = "VkPhysicalDeviceIDProperties")]
pub struct PhysicalDeviceIDProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_uuid: [u8; UUID_SIZE as _],
    pub driver_uuid: [u8; UUID_SIZE as _],
    pub device_luid: [u8; LUID_SIZE as _],
    pub device_node_mask: u32,
    pub device_luidvalid: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceIDProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceIdProperties;
}
unsafe impl<'a> Send for PhysicalDeviceIDProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceIDProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceIDProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceIDProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_uuid: array::from_fn(|_| Default::default()),
            driver_uuid: array::from_fn(|_| Default::default()),
            device_luid: array::from_fn(|_| Default::default()),
            device_node_mask: Default::default(),
            device_luidvalid: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceIDProperties<'a> {
    #[inline]
    pub fn device_uuid(mut self, value: [u8; UUID_SIZE as _]) -> Self {
        self.device_uuid = value;
        self
    }
    #[inline]
    pub fn driver_uuid(mut self, value: [u8; UUID_SIZE as _]) -> Self {
        self.driver_uuid = value;
        self
    }
    #[inline]
    pub fn device_luid(mut self, value: [u8; LUID_SIZE as _]) -> Self {
        self.device_luid = value;
        self
    }
    #[inline]
    pub fn device_node_mask(mut self, value: u32) -> Self {
        self.device_node_mask = value;
        self
    }
    #[inline]
    pub fn device_luidvalid(mut self, value: impl Into<Bool32>) -> Self {
        self.device_luidvalid = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceIDPropertiesKHR<'a> = PhysicalDeviceIDProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryImageCreateInfo.html>"]
#[doc(alias = "VkExternalMemoryImageCreateInfo")]
pub struct ExternalMemoryImageCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_types: ExternalMemoryHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExternalMemoryImageCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExternalMemoryImageCreateInfo;
}
unsafe impl<'a> Send for ExternalMemoryImageCreateInfo<'a> {}
unsafe impl<'a> Sync for ExternalMemoryImageCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>> for ExternalMemoryImageCreateInfo<'a> {}
impl<'a> Default for ExternalMemoryImageCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_types: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExternalMemoryImageCreateInfo<'a> {
    #[inline]
    pub fn handle_types(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_types = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ExternalMemoryImageCreateInfoKHR<'a> = ExternalMemoryImageCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryBufferCreateInfo.html>"]
#[doc(alias = "VkExternalMemoryBufferCreateInfo")]
pub struct ExternalMemoryBufferCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_types: ExternalMemoryHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExternalMemoryBufferCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExternalMemoryBufferCreateInfo;
}
unsafe impl<'a> Send for ExternalMemoryBufferCreateInfo<'a> {}
unsafe impl<'a> Sync for ExternalMemoryBufferCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BufferCreateInfo<'b>>
    for ExternalMemoryBufferCreateInfo<'a>
{
}
impl<'a> Default for ExternalMemoryBufferCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_types: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExternalMemoryBufferCreateInfo<'a> {
    #[inline]
    pub fn handle_types(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_types = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ExternalMemoryBufferCreateInfoKHR<'a> = ExternalMemoryBufferCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryAllocateInfo.html>"]
#[doc(alias = "VkExportMemoryAllocateInfo")]
pub struct ExportMemoryAllocateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_types: ExternalMemoryHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportMemoryAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportMemoryAllocateInfo;
}
unsafe impl<'a> Send for ExportMemoryAllocateInfo<'a> {}
unsafe impl<'a> Sync for ExportMemoryAllocateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>> for ExportMemoryAllocateInfo<'a> {}
impl<'a> Default for ExportMemoryAllocateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_types: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportMemoryAllocateInfo<'a> {
    #[inline]
    pub fn handle_types(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_types = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ExportMemoryAllocateInfoKHR<'a> = ExportMemoryAllocateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalFenceInfo.html>"]
#[doc(alias = "VkPhysicalDeviceExternalFenceInfo")]
pub struct PhysicalDeviceExternalFenceInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_type: ExternalFenceHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExternalFenceInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceExternalFenceInfo;
}
unsafe impl<'a> Send for PhysicalDeviceExternalFenceInfo<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExternalFenceInfo<'a> {}
impl<'a> Default for PhysicalDeviceExternalFenceInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExternalFenceInfo<'a> {
    #[inline]
    pub fn handle_type(mut self, value: ExternalFenceHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceExternalFenceInfoKHR<'a> = PhysicalDeviceExternalFenceInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceProperties.html>"]
#[doc(alias = "VkExternalFenceProperties")]
pub struct ExternalFenceProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub export_from_imported_handle_types: ExternalFenceHandleTypeFlags,
    pub compatible_handle_types: ExternalFenceHandleTypeFlags,
    pub external_fence_features: ExternalFenceFeatureFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExternalFenceProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExternalFenceProperties;
}
unsafe impl<'a> Send for ExternalFenceProperties<'a> {}
unsafe impl<'a> Sync for ExternalFenceProperties<'a> {}
impl<'a> Default for ExternalFenceProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            export_from_imported_handle_types: Default::default(),
            compatible_handle_types: Default::default(),
            external_fence_features: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExternalFenceProperties<'a> {
    #[inline]
    pub fn export_from_imported_handle_types(
        mut self,
        value: ExternalFenceHandleTypeFlags,
    ) -> Self {
        self.export_from_imported_handle_types = value;
        self
    }
    #[inline]
    pub fn compatible_handle_types(mut self, value: ExternalFenceHandleTypeFlags) -> Self {
        self.compatible_handle_types = value;
        self
    }
    #[inline]
    pub fn external_fence_features(mut self, value: ExternalFenceFeatureFlags) -> Self {
        self.external_fence_features = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ExternalFencePropertiesKHR<'a> = ExternalFenceProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportFenceCreateInfo.html>"]
#[doc(alias = "VkExportFenceCreateInfo")]
pub struct ExportFenceCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_types: ExternalFenceHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportFenceCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportFenceCreateInfo;
}
unsafe impl<'a> Send for ExportFenceCreateInfo<'a> {}
unsafe impl<'a> Sync for ExportFenceCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<FenceCreateInfo<'b>> for ExportFenceCreateInfo<'a> {}
impl<'a> Default for ExportFenceCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_types: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportFenceCreateInfo<'a> {
    #[inline]
    pub fn handle_types(mut self, value: ExternalFenceHandleTypeFlags) -> Self {
        self.handle_types = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ExportFenceCreateInfoKHR<'a> = ExportFenceCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportSemaphoreCreateInfo.html>"]
#[doc(alias = "VkExportSemaphoreCreateInfo")]
pub struct ExportSemaphoreCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_types: ExternalSemaphoreHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportSemaphoreCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportSemaphoreCreateInfo;
}
unsafe impl<'a> Send for ExportSemaphoreCreateInfo<'a> {}
unsafe impl<'a> Sync for ExportSemaphoreCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SemaphoreCreateInfo<'b>> for ExportSemaphoreCreateInfo<'a> {}
impl<'a> Default for ExportSemaphoreCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_types: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportSemaphoreCreateInfo<'a> {
    #[inline]
    pub fn handle_types(mut self, value: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_types = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ExportSemaphoreCreateInfoKHR<'a> = ExportSemaphoreCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalSemaphoreInfo.html>"]
#[doc(alias = "VkPhysicalDeviceExternalSemaphoreInfo")]
pub struct PhysicalDeviceExternalSemaphoreInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExternalSemaphoreInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceExternalSemaphoreInfo;
}
unsafe impl<'a> Send for PhysicalDeviceExternalSemaphoreInfo<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExternalSemaphoreInfo<'a> {}
impl<'a> Default for PhysicalDeviceExternalSemaphoreInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExternalSemaphoreInfo<'a> {
    #[inline]
    pub fn handle_type(mut self, value: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceExternalSemaphoreInfoKHR<'a> = PhysicalDeviceExternalSemaphoreInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreProperties.html>"]
#[doc(alias = "VkExternalSemaphoreProperties")]
pub struct ExternalSemaphoreProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags,
    pub compatible_handle_types: ExternalSemaphoreHandleTypeFlags,
    pub external_semaphore_features: ExternalSemaphoreFeatureFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExternalSemaphoreProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExternalSemaphoreProperties;
}
unsafe impl<'a> Send for ExternalSemaphoreProperties<'a> {}
unsafe impl<'a> Sync for ExternalSemaphoreProperties<'a> {}
impl<'a> Default for ExternalSemaphoreProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            export_from_imported_handle_types: Default::default(),
            compatible_handle_types: Default::default(),
            external_semaphore_features: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExternalSemaphoreProperties<'a> {
    #[inline]
    pub fn export_from_imported_handle_types(
        mut self,
        value: ExternalSemaphoreHandleTypeFlags,
    ) -> Self {
        self.export_from_imported_handle_types = value;
        self
    }
    #[inline]
    pub fn compatible_handle_types(mut self, value: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.compatible_handle_types = value;
        self
    }
    #[inline]
    pub fn external_semaphore_features(mut self, value: ExternalSemaphoreFeatureFlags) -> Self {
        self.external_semaphore_features = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ExternalSemaphorePropertiesKHR<'a> = ExternalSemaphoreProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance3Properties.html>"]
#[doc(alias = "VkPhysicalDeviceMaintenance3Properties")]
pub struct PhysicalDeviceMaintenance3Properties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_per_set_descriptors: u32,
    pub max_memory_allocation_size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMaintenance3Properties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMaintenance3Properties;
}
unsafe impl<'a> Send for PhysicalDeviceMaintenance3Properties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMaintenance3Properties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceMaintenance3Properties<'a>
{
}
impl<'a> Default for PhysicalDeviceMaintenance3Properties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_per_set_descriptors: Default::default(),
            max_memory_allocation_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMaintenance3Properties<'a> {
    #[inline]
    pub fn max_per_set_descriptors(mut self, value: u32) -> Self {
        self.max_per_set_descriptors = value;
        self
    }
    #[inline]
    pub fn max_memory_allocation_size(mut self, value: DeviceSize) -> Self {
        self.max_memory_allocation_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceMaintenance3PropertiesKHR<'a> = PhysicalDeviceMaintenance3Properties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutSupport.html>"]
#[doc(alias = "VkDescriptorSetLayoutSupport")]
pub struct DescriptorSetLayoutSupport<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub supported: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorSetLayoutSupport<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DescriptorSetLayoutSupport;
}
unsafe impl<'a> Send for DescriptorSetLayoutSupport<'a> {}
unsafe impl<'a> Sync for DescriptorSetLayoutSupport<'a> {}
impl<'a> Default for DescriptorSetLayoutSupport<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            supported: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorSetLayoutSupport<'a> {
    #[inline]
    pub fn supported(mut self, value: impl Into<Bool32>) -> Self {
        self.supported = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DescriptorSetLayoutSupportKHR<'a> = DescriptorSetLayoutSupport<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDrawParametersFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceShaderDrawParametersFeatures")]
pub struct PhysicalDeviceShaderDrawParametersFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_draw_parameters: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderDrawParametersFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderDrawParametersFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceShaderDrawParametersFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderDrawParametersFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderDrawParametersFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderDrawParametersFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderDrawParametersFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_draw_parameters: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderDrawParametersFeatures<'a> {
    #[inline]
    pub fn shader_draw_parameters(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_draw_parameters = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceShaderDrawParameterFeatures<'a> =
    PhysicalDeviceShaderDrawParametersFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html>"]
#[doc(alias = "VkPhysicalDeviceVulkan11Features")]
pub struct PhysicalDeviceVulkan11Features<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub storage_buffer16_bit_access: Bool32,
    pub uniform_and_storage_buffer16_bit_access: Bool32,
    pub storage_push_constant16: Bool32,
    pub storage_input_output16: Bool32,
    pub multiview: Bool32,
    pub multiview_geometry_shader: Bool32,
    pub multiview_tessellation_shader: Bool32,
    pub variable_pointers_storage_buffer: Bool32,
    pub variable_pointers: Bool32,
    pub protected_memory: Bool32,
    pub sampler_ycbcr_conversion: Bool32,
    pub shader_draw_parameters: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceVulkan11Features<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceVulkan11Features;
}
unsafe impl<'a> Send for PhysicalDeviceVulkan11Features<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceVulkan11Features<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceVulkan11Features<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceVulkan11Features<'a>
{
}
impl<'a> Default for PhysicalDeviceVulkan11Features<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            storage_buffer16_bit_access: Default::default(),
            uniform_and_storage_buffer16_bit_access: Default::default(),
            storage_push_constant16: Default::default(),
            storage_input_output16: Default::default(),
            multiview: Default::default(),
            multiview_geometry_shader: Default::default(),
            multiview_tessellation_shader: Default::default(),
            variable_pointers_storage_buffer: Default::default(),
            variable_pointers: Default::default(),
            protected_memory: Default::default(),
            sampler_ycbcr_conversion: Default::default(),
            shader_draw_parameters: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceVulkan11Features<'a> {
    #[inline]
    pub fn storage_buffer16_bit_access(mut self, value: impl Into<Bool32>) -> Self {
        self.storage_buffer16_bit_access = value.into();
        self
    }
    #[inline]
    pub fn uniform_and_storage_buffer16_bit_access(mut self, value: impl Into<Bool32>) -> Self {
        self.uniform_and_storage_buffer16_bit_access = value.into();
        self
    }
    #[inline]
    pub fn storage_push_constant16(mut self, value: impl Into<Bool32>) -> Self {
        self.storage_push_constant16 = value.into();
        self
    }
    #[inline]
    pub fn storage_input_output16(mut self, value: impl Into<Bool32>) -> Self {
        self.storage_input_output16 = value.into();
        self
    }
    #[inline]
    pub fn multiview(mut self, value: impl Into<Bool32>) -> Self {
        self.multiview = value.into();
        self
    }
    #[inline]
    pub fn multiview_geometry_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.multiview_geometry_shader = value.into();
        self
    }
    #[inline]
    pub fn multiview_tessellation_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.multiview_tessellation_shader = value.into();
        self
    }
    #[inline]
    pub fn variable_pointers_storage_buffer(mut self, value: impl Into<Bool32>) -> Self {
        self.variable_pointers_storage_buffer = value.into();
        self
    }
    #[inline]
    pub fn variable_pointers(mut self, value: impl Into<Bool32>) -> Self {
        self.variable_pointers = value.into();
        self
    }
    #[inline]
    pub fn protected_memory(mut self, value: impl Into<Bool32>) -> Self {
        self.protected_memory = value.into();
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion(mut self, value: impl Into<Bool32>) -> Self {
        self.sampler_ycbcr_conversion = value.into();
        self
    }
    #[inline]
    pub fn shader_draw_parameters(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_draw_parameters = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Properties.html>"]
#[doc(alias = "VkPhysicalDeviceVulkan11Properties")]
pub struct PhysicalDeviceVulkan11Properties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_uuid: [u8; UUID_SIZE as _],
    pub driver_uuid: [u8; UUID_SIZE as _],
    pub device_luid: [u8; LUID_SIZE as _],
    pub device_node_mask: u32,
    pub device_luidvalid: Bool32,
    pub subgroup_size: u32,
    pub subgroup_supported_stages: ShaderStageFlags,
    pub subgroup_supported_operations: SubgroupFeatureFlags,
    pub subgroup_quad_operations_in_all_stages: Bool32,
    pub point_clipping_behavior: PointClippingBehavior,
    pub max_multiview_view_count: u32,
    pub max_multiview_instance_index: u32,
    pub protected_no_fault: Bool32,
    pub max_per_set_descriptors: u32,
    pub max_memory_allocation_size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceVulkan11Properties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceVulkan11Properties;
}
unsafe impl<'a> Send for PhysicalDeviceVulkan11Properties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceVulkan11Properties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceVulkan11Properties<'a>
{
}
impl<'a> Default for PhysicalDeviceVulkan11Properties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_uuid: array::from_fn(|_| Default::default()),
            driver_uuid: array::from_fn(|_| Default::default()),
            device_luid: array::from_fn(|_| Default::default()),
            device_node_mask: Default::default(),
            device_luidvalid: Default::default(),
            subgroup_size: Default::default(),
            subgroup_supported_stages: Default::default(),
            subgroup_supported_operations: Default::default(),
            subgroup_quad_operations_in_all_stages: Default::default(),
            point_clipping_behavior: PointClippingBehavior::AllClipPlanes,
            max_multiview_view_count: Default::default(),
            max_multiview_instance_index: Default::default(),
            protected_no_fault: Default::default(),
            max_per_set_descriptors: Default::default(),
            max_memory_allocation_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceVulkan11Properties<'a> {
    #[inline]
    pub fn device_uuid(mut self, value: [u8; UUID_SIZE as _]) -> Self {
        self.device_uuid = value;
        self
    }
    #[inline]
    pub fn driver_uuid(mut self, value: [u8; UUID_SIZE as _]) -> Self {
        self.driver_uuid = value;
        self
    }
    #[inline]
    pub fn device_luid(mut self, value: [u8; LUID_SIZE as _]) -> Self {
        self.device_luid = value;
        self
    }
    #[inline]
    pub fn device_node_mask(mut self, value: u32) -> Self {
        self.device_node_mask = value;
        self
    }
    #[inline]
    pub fn device_luidvalid(mut self, value: impl Into<Bool32>) -> Self {
        self.device_luidvalid = value.into();
        self
    }
    #[inline]
    pub fn subgroup_size(mut self, value: u32) -> Self {
        self.subgroup_size = value;
        self
    }
    #[inline]
    pub fn subgroup_supported_stages(mut self, value: ShaderStageFlags) -> Self {
        self.subgroup_supported_stages = value;
        self
    }
    #[inline]
    pub fn subgroup_supported_operations(mut self, value: SubgroupFeatureFlags) -> Self {
        self.subgroup_supported_operations = value;
        self
    }
    #[inline]
    pub fn subgroup_quad_operations_in_all_stages(mut self, value: impl Into<Bool32>) -> Self {
        self.subgroup_quad_operations_in_all_stages = value.into();
        self
    }
    #[inline]
    pub fn point_clipping_behavior(mut self, value: PointClippingBehavior) -> Self {
        self.point_clipping_behavior = value;
        self
    }
    #[inline]
    pub fn max_multiview_view_count(mut self, value: u32) -> Self {
        self.max_multiview_view_count = value;
        self
    }
    #[inline]
    pub fn max_multiview_instance_index(mut self, value: u32) -> Self {
        self.max_multiview_instance_index = value;
        self
    }
    #[inline]
    pub fn protected_no_fault(mut self, value: impl Into<Bool32>) -> Self {
        self.protected_no_fault = value.into();
        self
    }
    #[inline]
    pub fn max_per_set_descriptors(mut self, value: u32) -> Self {
        self.max_per_set_descriptors = value;
        self
    }
    #[inline]
    pub fn max_memory_allocation_size(mut self, value: DeviceSize) -> Self {
        self.max_memory_allocation_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html>"]
#[doc(alias = "VkPhysicalDeviceVulkan12Features")]
pub struct PhysicalDeviceVulkan12Features<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub sampler_mirror_clamp_to_edge: Bool32,
    pub draw_indirect_count: Bool32,
    pub storage_buffer8_bit_access: Bool32,
    pub uniform_and_storage_buffer8_bit_access: Bool32,
    pub storage_push_constant8: Bool32,
    pub shader_buffer_int64_atomics: Bool32,
    pub shader_shared_int64_atomics: Bool32,
    pub shader_float16: Bool32,
    pub shader_int8: Bool32,
    pub descriptor_indexing: Bool32,
    pub shader_input_attachment_array_dynamic_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_uniform_buffer_array_non_uniform_indexing: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_image_array_non_uniform_indexing: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_texel_buffer_array_non_uniform_indexing: Bool32,
    pub descriptor_binding_uniform_buffer_update_after_bind: Bool32,
    pub descriptor_binding_sampled_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_buffer_update_after_bind: Bool32,
    pub descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_storage_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_update_unused_while_pending: Bool32,
    pub descriptor_binding_partially_bound: Bool32,
    pub descriptor_binding_variable_descriptor_count: Bool32,
    pub runtime_descriptor_array: Bool32,
    pub sampler_filter_minmax: Bool32,
    pub scalar_block_layout: Bool32,
    pub imageless_framebuffer: Bool32,
    pub uniform_buffer_standard_layout: Bool32,
    pub shader_subgroup_extended_types: Bool32,
    pub separate_depth_stencil_layouts: Bool32,
    pub host_query_reset: Bool32,
    pub timeline_semaphore: Bool32,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
    pub vulkan_memory_model: Bool32,
    pub vulkan_memory_model_device_scope: Bool32,
    pub vulkan_memory_model_availability_visibility_chains: Bool32,
    pub shader_output_viewport_index: Bool32,
    pub shader_output_layer: Bool32,
    pub subgroup_broadcast_dynamic_id: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceVulkan12Features<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceVulkan12Features;
}
unsafe impl<'a> Send for PhysicalDeviceVulkan12Features<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceVulkan12Features<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceVulkan12Features<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceVulkan12Features<'a>
{
}
impl<'a> Default for PhysicalDeviceVulkan12Features<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            sampler_mirror_clamp_to_edge: Default::default(),
            draw_indirect_count: Default::default(),
            storage_buffer8_bit_access: Default::default(),
            uniform_and_storage_buffer8_bit_access: Default::default(),
            storage_push_constant8: Default::default(),
            shader_buffer_int64_atomics: Default::default(),
            shader_shared_int64_atomics: Default::default(),
            shader_float16: Default::default(),
            shader_int8: Default::default(),
            descriptor_indexing: Default::default(),
            shader_input_attachment_array_dynamic_indexing: Default::default(),
            shader_uniform_texel_buffer_array_dynamic_indexing: Default::default(),
            shader_storage_texel_buffer_array_dynamic_indexing: Default::default(),
            shader_uniform_buffer_array_non_uniform_indexing: Default::default(),
            shader_sampled_image_array_non_uniform_indexing: Default::default(),
            shader_storage_buffer_array_non_uniform_indexing: Default::default(),
            shader_storage_image_array_non_uniform_indexing: Default::default(),
            shader_input_attachment_array_non_uniform_indexing: Default::default(),
            shader_uniform_texel_buffer_array_non_uniform_indexing: Default::default(),
            shader_storage_texel_buffer_array_non_uniform_indexing: Default::default(),
            descriptor_binding_uniform_buffer_update_after_bind: Default::default(),
            descriptor_binding_sampled_image_update_after_bind: Default::default(),
            descriptor_binding_storage_image_update_after_bind: Default::default(),
            descriptor_binding_storage_buffer_update_after_bind: Default::default(),
            descriptor_binding_uniform_texel_buffer_update_after_bind: Default::default(),
            descriptor_binding_storage_texel_buffer_update_after_bind: Default::default(),
            descriptor_binding_update_unused_while_pending: Default::default(),
            descriptor_binding_partially_bound: Default::default(),
            descriptor_binding_variable_descriptor_count: Default::default(),
            runtime_descriptor_array: Default::default(),
            sampler_filter_minmax: Default::default(),
            scalar_block_layout: Default::default(),
            imageless_framebuffer: Default::default(),
            uniform_buffer_standard_layout: Default::default(),
            shader_subgroup_extended_types: Default::default(),
            separate_depth_stencil_layouts: Default::default(),
            host_query_reset: Default::default(),
            timeline_semaphore: Default::default(),
            buffer_device_address: Default::default(),
            buffer_device_address_capture_replay: Default::default(),
            buffer_device_address_multi_device: Default::default(),
            vulkan_memory_model: Default::default(),
            vulkan_memory_model_device_scope: Default::default(),
            vulkan_memory_model_availability_visibility_chains: Default::default(),
            shader_output_viewport_index: Default::default(),
            shader_output_layer: Default::default(),
            subgroup_broadcast_dynamic_id: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceVulkan12Features<'a> {
    #[inline]
    pub fn sampler_mirror_clamp_to_edge(mut self, value: impl Into<Bool32>) -> Self {
        self.sampler_mirror_clamp_to_edge = value.into();
        self
    }
    #[inline]
    pub fn draw_indirect_count(mut self, value: impl Into<Bool32>) -> Self {
        self.draw_indirect_count = value.into();
        self
    }
    #[inline]
    pub fn storage_buffer8_bit_access(mut self, value: impl Into<Bool32>) -> Self {
        self.storage_buffer8_bit_access = value.into();
        self
    }
    #[inline]
    pub fn uniform_and_storage_buffer8_bit_access(mut self, value: impl Into<Bool32>) -> Self {
        self.uniform_and_storage_buffer8_bit_access = value.into();
        self
    }
    #[inline]
    pub fn storage_push_constant8(mut self, value: impl Into<Bool32>) -> Self {
        self.storage_push_constant8 = value.into();
        self
    }
    #[inline]
    pub fn shader_buffer_int64_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_buffer_int64_atomics = value.into();
        self
    }
    #[inline]
    pub fn shader_shared_int64_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_shared_int64_atomics = value.into();
        self
    }
    #[inline]
    pub fn shader_float16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_float16 = value.into();
        self
    }
    #[inline]
    pub fn shader_int8(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_int8 = value.into();
        self
    }
    #[inline]
    pub fn descriptor_indexing(mut self, value: impl Into<Bool32>) -> Self {
        self.descriptor_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_dynamic_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_input_attachment_array_dynamic_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_uniform_texel_buffer_array_dynamic_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_uniform_texel_buffer_array_dynamic_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_texel_buffer_array_dynamic_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_texel_buffer_array_dynamic_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_uniform_buffer_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_sampled_image_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_buffer_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_image_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_input_attachment_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_uniform_texel_buffer_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_uniform_texel_buffer_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_texel_buffer_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_texel_buffer_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_uniform_buffer_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_uniform_buffer_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_sampled_image_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_sampled_image_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_image_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_storage_image_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_buffer_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_storage_buffer_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_uniform_texel_buffer_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_uniform_texel_buffer_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_texel_buffer_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_storage_texel_buffer_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_update_unused_while_pending(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_update_unused_while_pending = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_partially_bound(mut self, value: impl Into<Bool32>) -> Self {
        self.descriptor_binding_partially_bound = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_variable_descriptor_count(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_variable_descriptor_count = value.into();
        self
    }
    #[inline]
    pub fn runtime_descriptor_array(mut self, value: impl Into<Bool32>) -> Self {
        self.runtime_descriptor_array = value.into();
        self
    }
    #[inline]
    pub fn sampler_filter_minmax(mut self, value: impl Into<Bool32>) -> Self {
        self.sampler_filter_minmax = value.into();
        self
    }
    #[inline]
    pub fn scalar_block_layout(mut self, value: impl Into<Bool32>) -> Self {
        self.scalar_block_layout = value.into();
        self
    }
    #[inline]
    pub fn imageless_framebuffer(mut self, value: impl Into<Bool32>) -> Self {
        self.imageless_framebuffer = value.into();
        self
    }
    #[inline]
    pub fn uniform_buffer_standard_layout(mut self, value: impl Into<Bool32>) -> Self {
        self.uniform_buffer_standard_layout = value.into();
        self
    }
    #[inline]
    pub fn shader_subgroup_extended_types(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_subgroup_extended_types = value.into();
        self
    }
    #[inline]
    pub fn separate_depth_stencil_layouts(mut self, value: impl Into<Bool32>) -> Self {
        self.separate_depth_stencil_layouts = value.into();
        self
    }
    #[inline]
    pub fn host_query_reset(mut self, value: impl Into<Bool32>) -> Self {
        self.host_query_reset = value.into();
        self
    }
    #[inline]
    pub fn timeline_semaphore(mut self, value: impl Into<Bool32>) -> Self {
        self.timeline_semaphore = value.into();
        self
    }
    #[inline]
    pub fn buffer_device_address(mut self, value: impl Into<Bool32>) -> Self {
        self.buffer_device_address = value.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_capture_replay(mut self, value: impl Into<Bool32>) -> Self {
        self.buffer_device_address_capture_replay = value.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_multi_device(mut self, value: impl Into<Bool32>) -> Self {
        self.buffer_device_address_multi_device = value.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model(mut self, value: impl Into<Bool32>) -> Self {
        self.vulkan_memory_model = value.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model_device_scope(mut self, value: impl Into<Bool32>) -> Self {
        self.vulkan_memory_model_device_scope = value.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model_availability_visibility_chains(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.vulkan_memory_model_availability_visibility_chains = value.into();
        self
    }
    #[inline]
    pub fn shader_output_viewport_index(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_output_viewport_index = value.into();
        self
    }
    #[inline]
    pub fn shader_output_layer(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_output_layer = value.into();
        self
    }
    #[inline]
    pub fn subgroup_broadcast_dynamic_id(mut self, value: impl Into<Bool32>) -> Self {
        self.subgroup_broadcast_dynamic_id = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Properties.html>"]
#[doc(alias = "VkPhysicalDeviceVulkan12Properties")]
pub struct PhysicalDeviceVulkan12Properties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub driver_id: DriverId,
    pub(crate) driver_name: [c_char; MAX_DRIVER_NAME_SIZE as _],
    pub(crate) driver_info: [c_char; MAX_DRIVER_INFO_SIZE as _],
    pub conformance_version: ConformanceVersion,
    pub denorm_behavior_independence: ShaderFloatControlsIndependence,
    pub rounding_mode_independence: ShaderFloatControlsIndependence,
    pub shader_signed_zero_inf_nan_preserve_float16: Bool32,
    pub shader_signed_zero_inf_nan_preserve_float32: Bool32,
    pub shader_signed_zero_inf_nan_preserve_float64: Bool32,
    pub shader_denorm_preserve_float16: Bool32,
    pub shader_denorm_preserve_float32: Bool32,
    pub shader_denorm_preserve_float64: Bool32,
    pub shader_denorm_flush_to_zero_float16: Bool32,
    pub shader_denorm_flush_to_zero_float32: Bool32,
    pub shader_denorm_flush_to_zero_float64: Bool32,
    pub shader_rounding_mode_rtefloat16: Bool32,
    pub shader_rounding_mode_rtefloat32: Bool32,
    pub shader_rounding_mode_rtefloat64: Bool32,
    pub shader_rounding_mode_rtzfloat16: Bool32,
    pub shader_rounding_mode_rtzfloat32: Bool32,
    pub shader_rounding_mode_rtzfloat64: Bool32,
    pub max_update_after_bind_descriptors_in_all_pools: u32,
    pub shader_uniform_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_image_array_non_uniform_indexing_native: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing_native: Bool32,
    pub robust_buffer_access_update_after_bind: Bool32,
    pub quad_divergent_implicit_lod: Bool32,
    pub max_per_stage_descriptor_update_after_bind_samplers: u32,
    pub max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_images: u32,
    pub max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    pub max_per_stage_update_after_bind_resources: u32,
    pub max_descriptor_set_update_after_bind_samplers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_sampled_images: u32,
    pub max_descriptor_set_update_after_bind_storage_images: u32,
    pub max_descriptor_set_update_after_bind_input_attachments: u32,
    pub supported_depth_resolve_modes: ResolveModeFlags,
    pub supported_stencil_resolve_modes: ResolveModeFlags,
    pub independent_resolve_none: Bool32,
    pub independent_resolve: Bool32,
    pub filter_minmax_single_component_formats: Bool32,
    pub filter_minmax_image_component_mapping: Bool32,
    pub max_timeline_semaphore_value_difference: u64,
    pub framebuffer_integer_color_sample_counts: SampleCountFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceVulkan12Properties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceVulkan12Properties;
}
unsafe impl<'a> Send for PhysicalDeviceVulkan12Properties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceVulkan12Properties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceVulkan12Properties<'a>
{
}
impl<'a> Default for PhysicalDeviceVulkan12Properties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            driver_id: DriverId::AmdProprietary,
            driver_name: array::from_fn(|_| Default::default()),
            driver_info: array::from_fn(|_| Default::default()),
            conformance_version: Default::default(),
            denorm_behavior_independence: ShaderFloatControlsIndependence::Controls32BitOnly,
            rounding_mode_independence: ShaderFloatControlsIndependence::Controls32BitOnly,
            shader_signed_zero_inf_nan_preserve_float16: Default::default(),
            shader_signed_zero_inf_nan_preserve_float32: Default::default(),
            shader_signed_zero_inf_nan_preserve_float64: Default::default(),
            shader_denorm_preserve_float16: Default::default(),
            shader_denorm_preserve_float32: Default::default(),
            shader_denorm_preserve_float64: Default::default(),
            shader_denorm_flush_to_zero_float16: Default::default(),
            shader_denorm_flush_to_zero_float32: Default::default(),
            shader_denorm_flush_to_zero_float64: Default::default(),
            shader_rounding_mode_rtefloat16: Default::default(),
            shader_rounding_mode_rtefloat32: Default::default(),
            shader_rounding_mode_rtefloat64: Default::default(),
            shader_rounding_mode_rtzfloat16: Default::default(),
            shader_rounding_mode_rtzfloat32: Default::default(),
            shader_rounding_mode_rtzfloat64: Default::default(),
            max_update_after_bind_descriptors_in_all_pools: Default::default(),
            shader_uniform_buffer_array_non_uniform_indexing_native: Default::default(),
            shader_sampled_image_array_non_uniform_indexing_native: Default::default(),
            shader_storage_buffer_array_non_uniform_indexing_native: Default::default(),
            shader_storage_image_array_non_uniform_indexing_native: Default::default(),
            shader_input_attachment_array_non_uniform_indexing_native: Default::default(),
            robust_buffer_access_update_after_bind: Default::default(),
            quad_divergent_implicit_lod: Default::default(),
            max_per_stage_descriptor_update_after_bind_samplers: Default::default(),
            max_per_stage_descriptor_update_after_bind_uniform_buffers: Default::default(),
            max_per_stage_descriptor_update_after_bind_storage_buffers: Default::default(),
            max_per_stage_descriptor_update_after_bind_sampled_images: Default::default(),
            max_per_stage_descriptor_update_after_bind_storage_images: Default::default(),
            max_per_stage_descriptor_update_after_bind_input_attachments: Default::default(),
            max_per_stage_update_after_bind_resources: Default::default(),
            max_descriptor_set_update_after_bind_samplers: Default::default(),
            max_descriptor_set_update_after_bind_uniform_buffers: Default::default(),
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic: Default::default(),
            max_descriptor_set_update_after_bind_storage_buffers: Default::default(),
            max_descriptor_set_update_after_bind_storage_buffers_dynamic: Default::default(),
            max_descriptor_set_update_after_bind_sampled_images: Default::default(),
            max_descriptor_set_update_after_bind_storage_images: Default::default(),
            max_descriptor_set_update_after_bind_input_attachments: Default::default(),
            supported_depth_resolve_modes: Default::default(),
            supported_stencil_resolve_modes: Default::default(),
            independent_resolve_none: Default::default(),
            independent_resolve: Default::default(),
            filter_minmax_single_component_formats: Default::default(),
            filter_minmax_image_component_mapping: Default::default(),
            max_timeline_semaphore_value_difference: Default::default(),
            framebuffer_integer_color_sample_counts: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceVulkan12Properties<'a> {
    #[inline]
    pub fn driver_id(mut self, value: DriverId) -> Self {
        self.driver_id = value;
        self
    }
    #[inline]
    pub fn conformance_version(mut self, value: ConformanceVersion) -> Self {
        self.conformance_version = value;
        self
    }
    #[inline]
    pub fn denorm_behavior_independence(mut self, value: ShaderFloatControlsIndependence) -> Self {
        self.denorm_behavior_independence = value;
        self
    }
    #[inline]
    pub fn rounding_mode_independence(mut self, value: ShaderFloatControlsIndependence) -> Self {
        self.rounding_mode_independence = value;
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_signed_zero_inf_nan_preserve_float16 = value.into();
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float32(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_signed_zero_inf_nan_preserve_float32 = value.into();
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float64(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_signed_zero_inf_nan_preserve_float64 = value.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_denorm_preserve_float16 = value.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float32(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_denorm_preserve_float32 = value.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float64(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_denorm_preserve_float64 = value.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_denorm_flush_to_zero_float16 = value.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float32(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_denorm_flush_to_zero_float32 = value.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float64(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_denorm_flush_to_zero_float64 = value.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtefloat16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_rounding_mode_rtefloat16 = value.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtefloat32(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_rounding_mode_rtefloat32 = value.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtefloat64(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_rounding_mode_rtefloat64 = value.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtzfloat16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_rounding_mode_rtzfloat16 = value.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtzfloat32(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_rounding_mode_rtzfloat32 = value.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtzfloat64(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_rounding_mode_rtzfloat64 = value.into();
        self
    }
    #[inline]
    pub fn max_update_after_bind_descriptors_in_all_pools(mut self, value: u32) -> Self {
        self.max_update_after_bind_descriptors_in_all_pools = value;
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_non_uniform_indexing_native(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_uniform_buffer_array_non_uniform_indexing_native = value.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_non_uniform_indexing_native(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_sampled_image_array_non_uniform_indexing_native = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_non_uniform_indexing_native(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_buffer_array_non_uniform_indexing_native = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_non_uniform_indexing_native(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_image_array_non_uniform_indexing_native = value.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_non_uniform_indexing_native(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_input_attachment_array_non_uniform_indexing_native = value.into();
        self
    }
    #[inline]
    pub fn robust_buffer_access_update_after_bind(mut self, value: impl Into<Bool32>) -> Self {
        self.robust_buffer_access_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn quad_divergent_implicit_lod(mut self, value: impl Into<Bool32>) -> Self {
        self.quad_divergent_implicit_lod = value.into();
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_samplers(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_update_after_bind_samplers = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_uniform_buffers(
        mut self,
        value: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_uniform_buffers = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_storage_buffers(
        mut self,
        value: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_storage_buffers = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_sampled_images(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_update_after_bind_sampled_images = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_storage_images(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_update_after_bind_storage_images = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_input_attachments(
        mut self,
        value: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_input_attachments = value;
        self
    }
    #[inline]
    pub fn max_per_stage_update_after_bind_resources(mut self, value: u32) -> Self {
        self.max_per_stage_update_after_bind_resources = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_samplers(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_samplers = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_uniform_buffers(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_uniform_buffers = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_uniform_buffers_dynamic(
        mut self,
        value: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_uniform_buffers_dynamic = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_buffers(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_storage_buffers = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_buffers_dynamic(
        mut self,
        value: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_storage_buffers_dynamic = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_sampled_images(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_sampled_images = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_images(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_storage_images = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_input_attachments(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_input_attachments = value;
        self
    }
    #[inline]
    pub fn supported_depth_resolve_modes(mut self, value: ResolveModeFlags) -> Self {
        self.supported_depth_resolve_modes = value;
        self
    }
    #[inline]
    pub fn supported_stencil_resolve_modes(mut self, value: ResolveModeFlags) -> Self {
        self.supported_stencil_resolve_modes = value;
        self
    }
    #[inline]
    pub fn independent_resolve_none(mut self, value: impl Into<Bool32>) -> Self {
        self.independent_resolve_none = value.into();
        self
    }
    #[inline]
    pub fn independent_resolve(mut self, value: impl Into<Bool32>) -> Self {
        self.independent_resolve = value.into();
        self
    }
    #[inline]
    pub fn filter_minmax_single_component_formats(mut self, value: impl Into<Bool32>) -> Self {
        self.filter_minmax_single_component_formats = value.into();
        self
    }
    #[inline]
    pub fn filter_minmax_image_component_mapping(mut self, value: impl Into<Bool32>) -> Self {
        self.filter_minmax_image_component_mapping = value.into();
        self
    }
    #[inline]
    pub fn max_timeline_semaphore_value_difference(mut self, value: u64) -> Self {
        self.max_timeline_semaphore_value_difference = value;
        self
    }
    #[inline]
    pub fn framebuffer_integer_color_sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.framebuffer_integer_color_sample_counts = value;
        self
    }
    pub fn get_driver_name(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DRIVER_NAME_SIZE as _]>(&self.driver_name) }
                .as_slice(),
        )
        .unwrap()
    }
    pub fn get_driver_info(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DRIVER_INFO_SIZE as _]>(&self.driver_info) }
                .as_slice(),
        )
        .unwrap()
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatListCreateInfo.html>"]
#[doc(alias = "VkImageFormatListCreateInfo")]
pub struct ImageFormatListCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) view_format_count: u32,
    pub(crate) p_view_formats: *const Format,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageFormatListCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageFormatListCreateInfo;
}
unsafe impl<'a> Send for ImageFormatListCreateInfo<'a> {}
unsafe impl<'a> Sync for ImageFormatListCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>> for ImageFormatListCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SwapchainCreateInfoKHR<'b>>
    for ImageFormatListCreateInfo<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceImageFormatInfo2<'b>>
    for ImageFormatListCreateInfo<'a>
{
}
impl<'a> Default for ImageFormatListCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            view_format_count: Default::default(),
            p_view_formats: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageFormatListCreateInfo<'a> {
    #[inline]
    pub fn view_formats(mut self, p_view_formats: impl AsSlice<'a, Format>) -> Self {
        self.p_view_formats = p_view_formats.as_slice().as_ptr().cast();
        self.view_format_count = p_view_formats.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ImageFormatListCreateInfoKHR<'a> = ImageFormatListCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo2.html>"]
#[doc(alias = "VkRenderPassCreateInfo2")]
pub struct RenderPassCreateInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: RenderPassCreateFlags,
    pub(crate) attachment_count: u32,
    pub(crate) p_attachments: *const AttachmentDescription2<'a>,
    pub(crate) subpass_count: u32,
    pub(crate) p_subpasses: *const SubpassDescription2<'a>,
    pub(crate) dependency_count: u32,
    pub(crate) p_dependencies: *const SubpassDependency2<'a>,
    pub(crate) correlated_view_mask_count: u32,
    pub(crate) p_correlated_view_masks: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassCreateInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassCreateInfo2;
}
unsafe impl<'a> Send for RenderPassCreateInfo2<'a> {}
unsafe impl<'a> Sync for RenderPassCreateInfo2<'a> {}
impl<'a> Default for RenderPassCreateInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            attachment_count: Default::default(),
            p_attachments: ptr::null(),
            subpass_count: Default::default(),
            p_subpasses: ptr::null(),
            dependency_count: Default::default(),
            p_dependencies: ptr::null(),
            correlated_view_mask_count: Default::default(),
            p_correlated_view_masks: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassCreateInfo2<'a> {
    #[inline]
    pub fn flags(mut self, value: RenderPassCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn attachments(
        mut self,
        p_attachments: impl AsSlice<'a, AttachmentDescription2<'a>>,
    ) -> Self {
        self.p_attachments = p_attachments.as_slice().as_ptr().cast();
        self.attachment_count = p_attachments.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn subpasses(mut self, p_subpasses: impl AsSlice<'a, SubpassDescription2<'a>>) -> Self {
        self.p_subpasses = p_subpasses.as_slice().as_ptr().cast();
        self.subpass_count = p_subpasses.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn dependencies(
        mut self,
        p_dependencies: impl AsSlice<'a, SubpassDependency2<'a>>,
    ) -> Self {
        self.p_dependencies = p_dependencies.as_slice().as_ptr().cast();
        self.dependency_count = p_dependencies.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn correlated_view_masks(mut self, p_correlated_view_masks: impl AsSlice<'a, u32>) -> Self {
        self.p_correlated_view_masks = p_correlated_view_masks.as_slice().as_ptr().cast();
        self.correlated_view_mask_count = p_correlated_view_masks.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type RenderPassCreateInfo2KHR<'a> = RenderPassCreateInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription2.html>"]
#[doc(alias = "VkAttachmentDescription2")]
pub struct AttachmentDescription2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: AttachmentDescriptionFlags,
    pub format: Format,
    pub samples: SampleCountFlags,
    pub load_op: AttachmentLoadOp,
    pub store_op: AttachmentStoreOp,
    pub stencil_load_op: AttachmentLoadOp,
    pub stencil_store_op: AttachmentStoreOp,
    pub initial_layout: ImageLayout,
    pub final_layout: ImageLayout,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AttachmentDescription2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AttachmentDescription2;
}
unsafe impl<'a> Send for AttachmentDescription2<'a> {}
unsafe impl<'a> Sync for AttachmentDescription2<'a> {}
impl<'a> Default for AttachmentDescription2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            format: Format::Undefined,
            samples: Default::default(),
            load_op: AttachmentLoadOp::Load,
            store_op: AttachmentStoreOp::Store,
            stencil_load_op: AttachmentLoadOp::Load,
            stencil_store_op: AttachmentStoreOp::Store,
            initial_layout: ImageLayout::Undefined,
            final_layout: ImageLayout::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> AttachmentDescription2<'a> {
    #[inline]
    pub fn flags(mut self, value: AttachmentDescriptionFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn samples(mut self, value: SampleCountFlags) -> Self {
        self.samples = value;
        self
    }
    #[inline]
    pub fn load_op(mut self, value: AttachmentLoadOp) -> Self {
        self.load_op = value;
        self
    }
    #[inline]
    pub fn store_op(mut self, value: AttachmentStoreOp) -> Self {
        self.store_op = value;
        self
    }
    #[inline]
    pub fn stencil_load_op(mut self, value: AttachmentLoadOp) -> Self {
        self.stencil_load_op = value;
        self
    }
    #[inline]
    pub fn stencil_store_op(mut self, value: AttachmentStoreOp) -> Self {
        self.stencil_store_op = value;
        self
    }
    #[inline]
    pub fn initial_layout(mut self, value: ImageLayout) -> Self {
        self.initial_layout = value;
        self
    }
    #[inline]
    pub fn final_layout(mut self, value: ImageLayout) -> Self {
        self.final_layout = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type AttachmentDescription2KHR<'a> = AttachmentDescription2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference2.html>"]
#[doc(alias = "VkAttachmentReference2")]
pub struct AttachmentReference2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub attachment: u32,
    pub layout: ImageLayout,
    pub aspect_mask: ImageAspectFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AttachmentReference2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AttachmentReference2;
}
unsafe impl<'a> Send for AttachmentReference2<'a> {}
unsafe impl<'a> Sync for AttachmentReference2<'a> {}
impl<'a> Default for AttachmentReference2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            attachment: Default::default(),
            layout: ImageLayout::Undefined,
            aspect_mask: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AttachmentReference2<'a> {
    #[inline]
    pub fn attachment(mut self, value: u32) -> Self {
        self.attachment = value;
        self
    }
    #[inline]
    pub fn layout(mut self, value: ImageLayout) -> Self {
        self.layout = value;
        self
    }
    #[inline]
    pub fn aspect_mask(mut self, value: ImageAspectFlags) -> Self {
        self.aspect_mask = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type AttachmentReference2KHR<'a> = AttachmentReference2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription2.html>"]
#[doc(alias = "VkSubpassDescription2")]
pub struct SubpassDescription2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: SubpassDescriptionFlags,
    pub pipeline_bind_point: PipelineBindPoint,
    pub view_mask: u32,
    pub(crate) input_attachment_count: u32,
    pub(crate) p_input_attachments: *const AttachmentReference2<'a>,
    pub(crate) color_attachment_count: u32,
    pub(crate) p_color_attachments: *const AttachmentReference2<'a>,
    pub(crate) p_resolve_attachments: *const AttachmentReference2<'a>,
    pub p_depth_stencil_attachment: *const AttachmentReference2<'a>,
    pub(crate) preserve_attachment_count: u32,
    pub(crate) p_preserve_attachments: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SubpassDescription2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SubpassDescription2;
}
unsafe impl<'a> Send for SubpassDescription2<'a> {}
unsafe impl<'a> Sync for SubpassDescription2<'a> {}
impl<'a> Default for SubpassDescription2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            pipeline_bind_point: PipelineBindPoint::Graphics,
            view_mask: Default::default(),
            input_attachment_count: Default::default(),
            p_input_attachments: ptr::null(),
            color_attachment_count: Default::default(),
            p_color_attachments: ptr::null(),
            p_resolve_attachments: ptr::null(),
            p_depth_stencil_attachment: ptr::null(),
            preserve_attachment_count: Default::default(),
            p_preserve_attachments: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubpassDescription2<'a> {
    #[inline]
    pub fn flags(mut self, value: SubpassDescriptionFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn pipeline_bind_point(mut self, value: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = value;
        self
    }
    #[inline]
    pub fn view_mask(mut self, value: u32) -> Self {
        self.view_mask = value;
        self
    }
    #[inline]
    pub fn depth_stencil_attachment(mut self, value: Option<&'a AttachmentReference2<'a>>) -> Self {
        self.p_depth_stencil_attachment = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn input_attachments(
        mut self,
        p_input_attachments: impl AsSlice<'a, AttachmentReference2<'a>>,
    ) -> Self {
        self.p_input_attachments = p_input_attachments.as_slice().as_ptr().cast();
        self.input_attachment_count = p_input_attachments.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn color_attachment(
        mut self,
        p_color_attachments: impl AsSlice<'a, AttachmentReference2<'a>>,
        p_resolve_attachments: Option<impl AsSlice<'a, AttachmentReference2<'a>>>,
    ) -> Self {
        self.p_color_attachments = p_color_attachments.as_slice().as_ptr().cast();
        self.p_resolve_attachments = p_resolve_attachments
            .map(|p| p.as_slice().as_ptr().cast())
            .unwrap_or(ptr::null());
        self.color_attachment_count = p_color_attachments.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn preserve_attachments(mut self, p_preserve_attachments: impl AsSlice<'a, u32>) -> Self {
        self.p_preserve_attachments = p_preserve_attachments.as_slice().as_ptr().cast();
        self.preserve_attachment_count = p_preserve_attachments.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SubpassDescription2KHR<'a> = SubpassDescription2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency2.html>"]
#[doc(alias = "VkSubpassDependency2")]
pub struct SubpassDependency2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_subpass: u32,
    pub dst_subpass: u32,
    pub src_stage_mask: PipelineStageFlags,
    pub dst_stage_mask: PipelineStageFlags,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub dependency_flags: DependencyFlags,
    pub view_offset: i32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SubpassDependency2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SubpassDependency2;
}
unsafe impl<'a> Send for SubpassDependency2<'a> {}
unsafe impl<'a> Sync for SubpassDependency2<'a> {}
impl<'a> Default for SubpassDependency2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_subpass: Default::default(),
            dst_subpass: Default::default(),
            src_stage_mask: Default::default(),
            dst_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_access_mask: Default::default(),
            dependency_flags: Default::default(),
            view_offset: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubpassDependency2<'a> {
    #[inline]
    pub fn src_subpass(mut self, value: u32) -> Self {
        self.src_subpass = value;
        self
    }
    #[inline]
    pub fn dst_subpass(mut self, value: u32) -> Self {
        self.dst_subpass = value;
        self
    }
    #[inline]
    pub fn src_stage_mask(mut self, value: PipelineStageFlags) -> Self {
        self.src_stage_mask = value;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, value: PipelineStageFlags) -> Self {
        self.dst_stage_mask = value;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, value: AccessFlags) -> Self {
        self.src_access_mask = value;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, value: AccessFlags) -> Self {
        self.dst_access_mask = value;
        self
    }
    #[inline]
    pub fn dependency_flags(mut self, value: DependencyFlags) -> Self {
        self.dependency_flags = value;
        self
    }
    #[inline]
    pub fn view_offset(mut self, value: i32) -> Self {
        self.view_offset = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SubpassDependency2KHR<'a> = SubpassDependency2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassBeginInfo.html>"]
#[doc(alias = "VkSubpassBeginInfo")]
pub struct SubpassBeginInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub contents: SubpassContents,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SubpassBeginInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SubpassBeginInfo;
}
unsafe impl<'a> Send for SubpassBeginInfo<'a> {}
unsafe impl<'a> Sync for SubpassBeginInfo<'a> {}
impl<'a> Default for SubpassBeginInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            contents: SubpassContents::Inline,
            phantom: PhantomData,
        }
    }
}
impl<'a> SubpassBeginInfo<'a> {
    #[inline]
    pub fn contents(mut self, value: SubpassContents) -> Self {
        self.contents = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SubpassBeginInfoKHR<'a> = SubpassBeginInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassEndInfo.html>"]
#[doc(alias = "VkSubpassEndInfo")]
pub struct SubpassEndInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SubpassEndInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SubpassEndInfo;
}
unsafe impl<'a> Send for SubpassEndInfo<'a> {}
unsafe impl<'a> Sync for SubpassEndInfo<'a> {}
impl<'a> Default for SubpassEndInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubpassEndInfo<'a> {
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SubpassEndInfoKHR<'a> = SubpassEndInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice8BitStorageFeatures.html>"]
#[doc(alias = "VkPhysicalDevice8BitStorageFeatures")]
pub struct PhysicalDevice8BitStorageFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub storage_buffer8_bit_access: Bool32,
    pub uniform_and_storage_buffer8_bit_access: Bool32,
    pub storage_push_constant8: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevice8BitStorageFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDevice8BitStorageFeatures;
}
unsafe impl<'a> Send for PhysicalDevice8BitStorageFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDevice8BitStorageFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevice8BitStorageFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevice8BitStorageFeatures<'a>
{
}
impl<'a> Default for PhysicalDevice8BitStorageFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            storage_buffer8_bit_access: Default::default(),
            uniform_and_storage_buffer8_bit_access: Default::default(),
            storage_push_constant8: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevice8BitStorageFeatures<'a> {
    #[inline]
    pub fn storage_buffer8_bit_access(mut self, value: impl Into<Bool32>) -> Self {
        self.storage_buffer8_bit_access = value.into();
        self
    }
    #[inline]
    pub fn uniform_and_storage_buffer8_bit_access(mut self, value: impl Into<Bool32>) -> Self {
        self.uniform_and_storage_buffer8_bit_access = value.into();
        self
    }
    #[inline]
    pub fn storage_push_constant8(mut self, value: impl Into<Bool32>) -> Self {
        self.storage_push_constant8 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDevice8BitStorageFeaturesKHR<'a> = PhysicalDevice8BitStorageFeatures<'a>;
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkConformanceVersion.html>"]
#[doc(alias = "VkConformanceVersion")]
pub struct ConformanceVersion {
    pub major: u8,
    pub minor: u8,
    pub subminor: u8,
    pub patch: u8,
}
unsafe impl Send for ConformanceVersion {}
unsafe impl Sync for ConformanceVersion {}
impl Default for ConformanceVersion {
    fn default() -> Self {
        Self {
            major: Default::default(),
            minor: Default::default(),
            subminor: Default::default(),
            patch: Default::default(),
        }
    }
}
impl ConformanceVersion {
    #[inline]
    pub fn major(mut self, value: u8) -> Self {
        self.major = value;
        self
    }
    #[inline]
    pub fn minor(mut self, value: u8) -> Self {
        self.minor = value;
        self
    }
    #[inline]
    pub fn subminor(mut self, value: u8) -> Self {
        self.subminor = value;
        self
    }
    #[inline]
    pub fn patch(mut self, value: u8) -> Self {
        self.patch = value;
        self
    }
}
pub type ConformanceVersionKHR = ConformanceVersion;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDriverProperties.html>"]
#[doc(alias = "VkPhysicalDeviceDriverProperties")]
pub struct PhysicalDeviceDriverProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub driver_id: DriverId,
    pub(crate) driver_name: [c_char; MAX_DRIVER_NAME_SIZE as _],
    pub(crate) driver_info: [c_char; MAX_DRIVER_INFO_SIZE as _],
    pub conformance_version: ConformanceVersion,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDriverProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceDriverProperties;
}
unsafe impl<'a> Send for PhysicalDeviceDriverProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDriverProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceDriverProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceDriverProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            driver_id: DriverId::AmdProprietary,
            driver_name: array::from_fn(|_| Default::default()),
            driver_info: array::from_fn(|_| Default::default()),
            conformance_version: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDriverProperties<'a> {
    #[inline]
    pub fn driver_id(mut self, value: DriverId) -> Self {
        self.driver_id = value;
        self
    }
    #[inline]
    pub fn conformance_version(mut self, value: ConformanceVersion) -> Self {
        self.conformance_version = value;
        self
    }
    pub fn get_driver_name(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DRIVER_NAME_SIZE as _]>(&self.driver_name) }
                .as_slice(),
        )
        .unwrap()
    }
    pub fn get_driver_info(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DRIVER_INFO_SIZE as _]>(&self.driver_info) }
                .as_slice(),
        )
        .unwrap()
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceDriverPropertiesKHR<'a> = PhysicalDeviceDriverProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicInt64Features.html>"]
#[doc(alias = "VkPhysicalDeviceShaderAtomicInt64Features")]
pub struct PhysicalDeviceShaderAtomicInt64Features<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_buffer_int64_atomics: Bool32,
    pub shader_shared_int64_atomics: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderAtomicInt64Features<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderAtomicInt64Features;
}
unsafe impl<'a> Send for PhysicalDeviceShaderAtomicInt64Features<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderAtomicInt64Features<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderAtomicInt64Features<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderAtomicInt64Features<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderAtomicInt64Features<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_buffer_int64_atomics: Default::default(),
            shader_shared_int64_atomics: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderAtomicInt64Features<'a> {
    #[inline]
    pub fn shader_buffer_int64_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_buffer_int64_atomics = value.into();
        self
    }
    #[inline]
    pub fn shader_shared_int64_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_shared_int64_atomics = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceShaderAtomicInt64FeaturesKHR<'a> =
    PhysicalDeviceShaderAtomicInt64Features<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderFloat16Int8Features.html>"]
#[doc(alias = "VkPhysicalDeviceShaderFloat16Int8Features")]
pub struct PhysicalDeviceShaderFloat16Int8Features<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_float16: Bool32,
    pub shader_int8: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderFloat16Int8Features<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderFloat16Int8Features;
}
unsafe impl<'a> Send for PhysicalDeviceShaderFloat16Int8Features<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderFloat16Int8Features<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderFloat16Int8Features<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderFloat16Int8Features<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderFloat16Int8Features<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_float16: Default::default(),
            shader_int8: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderFloat16Int8Features<'a> {
    #[inline]
    pub fn shader_float16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_float16 = value.into();
        self
    }
    #[inline]
    pub fn shader_int8(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_int8 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceShaderFloat16Int8FeaturesKHR<'a> =
    PhysicalDeviceShaderFloat16Int8Features<'a>;
pub type PhysicalDeviceFloat16Int8FeaturesKHR<'a> = PhysicalDeviceShaderFloat16Int8Features<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFloatControlsProperties.html>"]
#[doc(alias = "VkPhysicalDeviceFloatControlsProperties")]
pub struct PhysicalDeviceFloatControlsProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub denorm_behavior_independence: ShaderFloatControlsIndependence,
    pub rounding_mode_independence: ShaderFloatControlsIndependence,
    pub shader_signed_zero_inf_nan_preserve_float16: Bool32,
    pub shader_signed_zero_inf_nan_preserve_float32: Bool32,
    pub shader_signed_zero_inf_nan_preserve_float64: Bool32,
    pub shader_denorm_preserve_float16: Bool32,
    pub shader_denorm_preserve_float32: Bool32,
    pub shader_denorm_preserve_float64: Bool32,
    pub shader_denorm_flush_to_zero_float16: Bool32,
    pub shader_denorm_flush_to_zero_float32: Bool32,
    pub shader_denorm_flush_to_zero_float64: Bool32,
    pub shader_rounding_mode_rtefloat16: Bool32,
    pub shader_rounding_mode_rtefloat32: Bool32,
    pub shader_rounding_mode_rtefloat64: Bool32,
    pub shader_rounding_mode_rtzfloat16: Bool32,
    pub shader_rounding_mode_rtzfloat32: Bool32,
    pub shader_rounding_mode_rtzfloat64: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFloatControlsProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceFloatControlsProperties;
}
unsafe impl<'a> Send for PhysicalDeviceFloatControlsProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFloatControlsProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceFloatControlsProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceFloatControlsProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            denorm_behavior_independence: ShaderFloatControlsIndependence::Controls32BitOnly,
            rounding_mode_independence: ShaderFloatControlsIndependence::Controls32BitOnly,
            shader_signed_zero_inf_nan_preserve_float16: Default::default(),
            shader_signed_zero_inf_nan_preserve_float32: Default::default(),
            shader_signed_zero_inf_nan_preserve_float64: Default::default(),
            shader_denorm_preserve_float16: Default::default(),
            shader_denorm_preserve_float32: Default::default(),
            shader_denorm_preserve_float64: Default::default(),
            shader_denorm_flush_to_zero_float16: Default::default(),
            shader_denorm_flush_to_zero_float32: Default::default(),
            shader_denorm_flush_to_zero_float64: Default::default(),
            shader_rounding_mode_rtefloat16: Default::default(),
            shader_rounding_mode_rtefloat32: Default::default(),
            shader_rounding_mode_rtefloat64: Default::default(),
            shader_rounding_mode_rtzfloat16: Default::default(),
            shader_rounding_mode_rtzfloat32: Default::default(),
            shader_rounding_mode_rtzfloat64: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFloatControlsProperties<'a> {
    #[inline]
    pub fn denorm_behavior_independence(mut self, value: ShaderFloatControlsIndependence) -> Self {
        self.denorm_behavior_independence = value;
        self
    }
    #[inline]
    pub fn rounding_mode_independence(mut self, value: ShaderFloatControlsIndependence) -> Self {
        self.rounding_mode_independence = value;
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_signed_zero_inf_nan_preserve_float16 = value.into();
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float32(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_signed_zero_inf_nan_preserve_float32 = value.into();
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float64(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_signed_zero_inf_nan_preserve_float64 = value.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_denorm_preserve_float16 = value.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float32(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_denorm_preserve_float32 = value.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float64(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_denorm_preserve_float64 = value.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_denorm_flush_to_zero_float16 = value.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float32(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_denorm_flush_to_zero_float32 = value.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float64(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_denorm_flush_to_zero_float64 = value.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtefloat16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_rounding_mode_rtefloat16 = value.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtefloat32(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_rounding_mode_rtefloat32 = value.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtefloat64(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_rounding_mode_rtefloat64 = value.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtzfloat16(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_rounding_mode_rtzfloat16 = value.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtzfloat32(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_rounding_mode_rtzfloat32 = value.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtzfloat64(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_rounding_mode_rtzfloat64 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceFloatControlsPropertiesKHR<'a> = PhysicalDeviceFloatControlsProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBindingFlagsCreateInfo.html>"]
#[doc(alias = "VkDescriptorSetLayoutBindingFlagsCreateInfo")]
pub struct DescriptorSetLayoutBindingFlagsCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub binding_count: u32,
    pub(crate) p_binding_flags: *const DescriptorBindingFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorSetLayoutBindingFlagsCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DescriptorSetLayoutBindingFlagsCreateInfo;
}
unsafe impl<'a> Send for DescriptorSetLayoutBindingFlagsCreateInfo<'a> {}
unsafe impl<'a> Sync for DescriptorSetLayoutBindingFlagsCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DescriptorSetLayoutCreateInfo<'b>>
    for DescriptorSetLayoutBindingFlagsCreateInfo<'a>
{
}
impl<'a> Default for DescriptorSetLayoutBindingFlagsCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            binding_count: Default::default(),
            p_binding_flags: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorSetLayoutBindingFlagsCreateInfo<'a> {
    #[inline]
    pub fn binding_count(mut self, value: u32) -> Self {
        self.binding_count = value;
        self
    }
    #[inline]
    pub fn binding_flags(
        mut self,
        p_binding_flags: impl AsSlice<'a, DescriptorBindingFlags>,
    ) -> Self {
        self.p_binding_flags = p_binding_flags.as_slice().as_ptr().cast();
        self.binding_count = p_binding_flags.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DescriptorSetLayoutBindingFlagsCreateInfoEXT<'a> =
    DescriptorSetLayoutBindingFlagsCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorIndexingFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceDescriptorIndexingFeatures")]
pub struct PhysicalDeviceDescriptorIndexingFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_input_attachment_array_dynamic_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_uniform_buffer_array_non_uniform_indexing: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_image_array_non_uniform_indexing: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_texel_buffer_array_non_uniform_indexing: Bool32,
    pub descriptor_binding_uniform_buffer_update_after_bind: Bool32,
    pub descriptor_binding_sampled_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_buffer_update_after_bind: Bool32,
    pub descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_storage_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_update_unused_while_pending: Bool32,
    pub descriptor_binding_partially_bound: Bool32,
    pub descriptor_binding_variable_descriptor_count: Bool32,
    pub runtime_descriptor_array: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDescriptorIndexingFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceDescriptorIndexingFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceDescriptorIndexingFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDescriptorIndexingFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDescriptorIndexingFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDescriptorIndexingFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceDescriptorIndexingFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_input_attachment_array_dynamic_indexing: Default::default(),
            shader_uniform_texel_buffer_array_dynamic_indexing: Default::default(),
            shader_storage_texel_buffer_array_dynamic_indexing: Default::default(),
            shader_uniform_buffer_array_non_uniform_indexing: Default::default(),
            shader_sampled_image_array_non_uniform_indexing: Default::default(),
            shader_storage_buffer_array_non_uniform_indexing: Default::default(),
            shader_storage_image_array_non_uniform_indexing: Default::default(),
            shader_input_attachment_array_non_uniform_indexing: Default::default(),
            shader_uniform_texel_buffer_array_non_uniform_indexing: Default::default(),
            shader_storage_texel_buffer_array_non_uniform_indexing: Default::default(),
            descriptor_binding_uniform_buffer_update_after_bind: Default::default(),
            descriptor_binding_sampled_image_update_after_bind: Default::default(),
            descriptor_binding_storage_image_update_after_bind: Default::default(),
            descriptor_binding_storage_buffer_update_after_bind: Default::default(),
            descriptor_binding_uniform_texel_buffer_update_after_bind: Default::default(),
            descriptor_binding_storage_texel_buffer_update_after_bind: Default::default(),
            descriptor_binding_update_unused_while_pending: Default::default(),
            descriptor_binding_partially_bound: Default::default(),
            descriptor_binding_variable_descriptor_count: Default::default(),
            runtime_descriptor_array: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDescriptorIndexingFeatures<'a> {
    #[inline]
    pub fn shader_input_attachment_array_dynamic_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_input_attachment_array_dynamic_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_uniform_texel_buffer_array_dynamic_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_uniform_texel_buffer_array_dynamic_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_texel_buffer_array_dynamic_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_texel_buffer_array_dynamic_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_uniform_buffer_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_sampled_image_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_buffer_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_image_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_input_attachment_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_uniform_texel_buffer_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_uniform_texel_buffer_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_texel_buffer_array_non_uniform_indexing(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_texel_buffer_array_non_uniform_indexing = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_uniform_buffer_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_uniform_buffer_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_sampled_image_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_sampled_image_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_image_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_storage_image_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_buffer_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_storage_buffer_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_uniform_texel_buffer_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_uniform_texel_buffer_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_texel_buffer_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_storage_texel_buffer_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_update_unused_while_pending(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_update_unused_while_pending = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_partially_bound(mut self, value: impl Into<Bool32>) -> Self {
        self.descriptor_binding_partially_bound = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_variable_descriptor_count(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_variable_descriptor_count = value.into();
        self
    }
    #[inline]
    pub fn runtime_descriptor_array(mut self, value: impl Into<Bool32>) -> Self {
        self.runtime_descriptor_array = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceDescriptorIndexingFeaturesEXT<'a> =
    PhysicalDeviceDescriptorIndexingFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorIndexingProperties.html>"]
#[doc(alias = "VkPhysicalDeviceDescriptorIndexingProperties")]
pub struct PhysicalDeviceDescriptorIndexingProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_update_after_bind_descriptors_in_all_pools: u32,
    pub shader_uniform_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_image_array_non_uniform_indexing_native: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing_native: Bool32,
    pub robust_buffer_access_update_after_bind: Bool32,
    pub quad_divergent_implicit_lod: Bool32,
    pub max_per_stage_descriptor_update_after_bind_samplers: u32,
    pub max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_images: u32,
    pub max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    pub max_per_stage_update_after_bind_resources: u32,
    pub max_descriptor_set_update_after_bind_samplers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_sampled_images: u32,
    pub max_descriptor_set_update_after_bind_storage_images: u32,
    pub max_descriptor_set_update_after_bind_input_attachments: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDescriptorIndexingProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceDescriptorIndexingProperties;
}
unsafe impl<'a> Send for PhysicalDeviceDescriptorIndexingProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDescriptorIndexingProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceDescriptorIndexingProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceDescriptorIndexingProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_update_after_bind_descriptors_in_all_pools: Default::default(),
            shader_uniform_buffer_array_non_uniform_indexing_native: Default::default(),
            shader_sampled_image_array_non_uniform_indexing_native: Default::default(),
            shader_storage_buffer_array_non_uniform_indexing_native: Default::default(),
            shader_storage_image_array_non_uniform_indexing_native: Default::default(),
            shader_input_attachment_array_non_uniform_indexing_native: Default::default(),
            robust_buffer_access_update_after_bind: Default::default(),
            quad_divergent_implicit_lod: Default::default(),
            max_per_stage_descriptor_update_after_bind_samplers: Default::default(),
            max_per_stage_descriptor_update_after_bind_uniform_buffers: Default::default(),
            max_per_stage_descriptor_update_after_bind_storage_buffers: Default::default(),
            max_per_stage_descriptor_update_after_bind_sampled_images: Default::default(),
            max_per_stage_descriptor_update_after_bind_storage_images: Default::default(),
            max_per_stage_descriptor_update_after_bind_input_attachments: Default::default(),
            max_per_stage_update_after_bind_resources: Default::default(),
            max_descriptor_set_update_after_bind_samplers: Default::default(),
            max_descriptor_set_update_after_bind_uniform_buffers: Default::default(),
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic: Default::default(),
            max_descriptor_set_update_after_bind_storage_buffers: Default::default(),
            max_descriptor_set_update_after_bind_storage_buffers_dynamic: Default::default(),
            max_descriptor_set_update_after_bind_sampled_images: Default::default(),
            max_descriptor_set_update_after_bind_storage_images: Default::default(),
            max_descriptor_set_update_after_bind_input_attachments: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDescriptorIndexingProperties<'a> {
    #[inline]
    pub fn max_update_after_bind_descriptors_in_all_pools(mut self, value: u32) -> Self {
        self.max_update_after_bind_descriptors_in_all_pools = value;
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_non_uniform_indexing_native(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_uniform_buffer_array_non_uniform_indexing_native = value.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_non_uniform_indexing_native(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_sampled_image_array_non_uniform_indexing_native = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_non_uniform_indexing_native(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_buffer_array_non_uniform_indexing_native = value.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_non_uniform_indexing_native(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_storage_image_array_non_uniform_indexing_native = value.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_non_uniform_indexing_native(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_input_attachment_array_non_uniform_indexing_native = value.into();
        self
    }
    #[inline]
    pub fn robust_buffer_access_update_after_bind(mut self, value: impl Into<Bool32>) -> Self {
        self.robust_buffer_access_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn quad_divergent_implicit_lod(mut self, value: impl Into<Bool32>) -> Self {
        self.quad_divergent_implicit_lod = value.into();
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_samplers(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_update_after_bind_samplers = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_uniform_buffers(
        mut self,
        value: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_uniform_buffers = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_storage_buffers(
        mut self,
        value: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_storage_buffers = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_sampled_images(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_update_after_bind_sampled_images = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_storage_images(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_update_after_bind_storage_images = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_input_attachments(
        mut self,
        value: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_input_attachments = value;
        self
    }
    #[inline]
    pub fn max_per_stage_update_after_bind_resources(mut self, value: u32) -> Self {
        self.max_per_stage_update_after_bind_resources = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_samplers(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_samplers = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_uniform_buffers(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_uniform_buffers = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_uniform_buffers_dynamic(
        mut self,
        value: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_uniform_buffers_dynamic = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_buffers(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_storage_buffers = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_buffers_dynamic(
        mut self,
        value: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_storage_buffers_dynamic = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_sampled_images(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_sampled_images = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_images(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_storage_images = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_input_attachments(mut self, value: u32) -> Self {
        self.max_descriptor_set_update_after_bind_input_attachments = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceDescriptorIndexingPropertiesEXT<'a> =
    PhysicalDeviceDescriptorIndexingProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetVariableDescriptorCountAllocateInfo.html>"]
#[doc(alias = "VkDescriptorSetVariableDescriptorCountAllocateInfo")]
pub struct DescriptorSetVariableDescriptorCountAllocateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) descriptor_set_count: u32,
    pub(crate) p_descriptor_counts: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorSetVariableDescriptorCountAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DescriptorSetVariableDescriptorCountAllocateInfo;
}
unsafe impl<'a> Send for DescriptorSetVariableDescriptorCountAllocateInfo<'a> {}
unsafe impl<'a> Sync for DescriptorSetVariableDescriptorCountAllocateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DescriptorSetAllocateInfo<'b>>
    for DescriptorSetVariableDescriptorCountAllocateInfo<'a>
{
}
impl<'a> Default for DescriptorSetVariableDescriptorCountAllocateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            descriptor_set_count: Default::default(),
            p_descriptor_counts: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorSetVariableDescriptorCountAllocateInfo<'a> {
    #[inline]
    pub fn descriptor_counts(mut self, p_descriptor_counts: impl AsSlice<'a, u32>) -> Self {
        self.p_descriptor_counts = p_descriptor_counts.as_slice().as_ptr().cast();
        self.descriptor_set_count = p_descriptor_counts.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DescriptorSetVariableDescriptorCountAllocateInfoEXT<'a> =
    DescriptorSetVariableDescriptorCountAllocateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetVariableDescriptorCountLayoutSupport.html>"]
#[doc(alias = "VkDescriptorSetVariableDescriptorCountLayoutSupport")]
pub struct DescriptorSetVariableDescriptorCountLayoutSupport<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_variable_descriptor_count: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorSetVariableDescriptorCountLayoutSupport<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DescriptorSetVariableDescriptorCountLayoutSupport;
}
unsafe impl<'a> Send for DescriptorSetVariableDescriptorCountLayoutSupport<'a> {}
unsafe impl<'a> Sync for DescriptorSetVariableDescriptorCountLayoutSupport<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DescriptorSetLayoutSupport<'b>>
    for DescriptorSetVariableDescriptorCountLayoutSupport<'a>
{
}
impl<'a> Default for DescriptorSetVariableDescriptorCountLayoutSupport<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_variable_descriptor_count: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorSetVariableDescriptorCountLayoutSupport<'a> {
    #[inline]
    pub fn max_variable_descriptor_count(mut self, value: u32) -> Self {
        self.max_variable_descriptor_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DescriptorSetVariableDescriptorCountLayoutSupportEXT<'a> =
    DescriptorSetVariableDescriptorCountLayoutSupport<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionDepthStencilResolve.html>"]
#[doc(alias = "VkSubpassDescriptionDepthStencilResolve")]
pub struct SubpassDescriptionDepthStencilResolve<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub depth_resolve_mode: ResolveModeFlags,
    pub stencil_resolve_mode: ResolveModeFlags,
    pub p_depth_stencil_resolve_attachment: *const AttachmentReference2<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SubpassDescriptionDepthStencilResolve<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SubpassDescriptionDepthStencilResolve;
}
unsafe impl<'a> Send for SubpassDescriptionDepthStencilResolve<'a> {}
unsafe impl<'a> Sync for SubpassDescriptionDepthStencilResolve<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubpassDescription2<'b>>
    for SubpassDescriptionDepthStencilResolve<'a>
{
}
impl<'a> Default for SubpassDescriptionDepthStencilResolve<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            depth_resolve_mode: Default::default(),
            stencil_resolve_mode: Default::default(),
            p_depth_stencil_resolve_attachment: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubpassDescriptionDepthStencilResolve<'a> {
    #[inline]
    pub fn depth_resolve_mode(mut self, value: ResolveModeFlags) -> Self {
        self.depth_resolve_mode = value;
        self
    }
    #[inline]
    pub fn stencil_resolve_mode(mut self, value: ResolveModeFlags) -> Self {
        self.stencil_resolve_mode = value;
        self
    }
    #[inline]
    pub fn depth_stencil_resolve_attachment(
        mut self,
        value: Option<&'a AttachmentReference2<'a>>,
    ) -> Self {
        self.p_depth_stencil_resolve_attachment =
            value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SubpassDescriptionDepthStencilResolveKHR<'a> = SubpassDescriptionDepthStencilResolve<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthStencilResolveProperties.html>"]
#[doc(alias = "VkPhysicalDeviceDepthStencilResolveProperties")]
pub struct PhysicalDeviceDepthStencilResolveProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub supported_depth_resolve_modes: ResolveModeFlags,
    pub supported_stencil_resolve_modes: ResolveModeFlags,
    pub independent_resolve_none: Bool32,
    pub independent_resolve: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDepthStencilResolveProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDepthStencilResolveProperties;
}
unsafe impl<'a> Send for PhysicalDeviceDepthStencilResolveProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDepthStencilResolveProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceDepthStencilResolveProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceDepthStencilResolveProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            supported_depth_resolve_modes: Default::default(),
            supported_stencil_resolve_modes: Default::default(),
            independent_resolve_none: Default::default(),
            independent_resolve: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDepthStencilResolveProperties<'a> {
    #[inline]
    pub fn supported_depth_resolve_modes(mut self, value: ResolveModeFlags) -> Self {
        self.supported_depth_resolve_modes = value;
        self
    }
    #[inline]
    pub fn supported_stencil_resolve_modes(mut self, value: ResolveModeFlags) -> Self {
        self.supported_stencil_resolve_modes = value;
        self
    }
    #[inline]
    pub fn independent_resolve_none(mut self, value: impl Into<Bool32>) -> Self {
        self.independent_resolve_none = value.into();
        self
    }
    #[inline]
    pub fn independent_resolve(mut self, value: impl Into<Bool32>) -> Self {
        self.independent_resolve = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceDepthStencilResolvePropertiesKHR<'a> =
    PhysicalDeviceDepthStencilResolveProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceScalarBlockLayoutFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceScalarBlockLayoutFeatures")]
pub struct PhysicalDeviceScalarBlockLayoutFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub scalar_block_layout: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceScalarBlockLayoutFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceScalarBlockLayoutFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceScalarBlockLayoutFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceScalarBlockLayoutFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceScalarBlockLayoutFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceScalarBlockLayoutFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceScalarBlockLayoutFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            scalar_block_layout: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceScalarBlockLayoutFeatures<'a> {
    #[inline]
    pub fn scalar_block_layout(mut self, value: impl Into<Bool32>) -> Self {
        self.scalar_block_layout = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceScalarBlockLayoutFeaturesEXT<'a> =
    PhysicalDeviceScalarBlockLayoutFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageStencilUsageCreateInfo.html>"]
#[doc(alias = "VkImageStencilUsageCreateInfo")]
pub struct ImageStencilUsageCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub stencil_usage: ImageUsageFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageStencilUsageCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageStencilUsageCreateInfo;
}
unsafe impl<'a> Send for ImageStencilUsageCreateInfo<'a> {}
unsafe impl<'a> Sync for ImageStencilUsageCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>> for ImageStencilUsageCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceImageFormatInfo2<'b>>
    for ImageStencilUsageCreateInfo<'a>
{
}
impl<'a> Default for ImageStencilUsageCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stencil_usage: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageStencilUsageCreateInfo<'a> {
    #[inline]
    pub fn stencil_usage(mut self, value: ImageUsageFlags) -> Self {
        self.stencil_usage = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ImageStencilUsageCreateInfoEXT<'a> = ImageStencilUsageCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerReductionModeCreateInfo.html>"]
#[doc(alias = "VkSamplerReductionModeCreateInfo")]
pub struct SamplerReductionModeCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub reduction_mode: SamplerReductionMode,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SamplerReductionModeCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SamplerReductionModeCreateInfo;
}
unsafe impl<'a> Send for SamplerReductionModeCreateInfo<'a> {}
unsafe impl<'a> Sync for SamplerReductionModeCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SamplerCreateInfo<'b>>
    for SamplerReductionModeCreateInfo<'a>
{
}
impl<'a> Default for SamplerReductionModeCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            reduction_mode: SamplerReductionMode::WeightedAverage,
            phantom: PhantomData,
        }
    }
}
impl<'a> SamplerReductionModeCreateInfo<'a> {
    #[inline]
    pub fn reduction_mode(mut self, value: SamplerReductionMode) -> Self {
        self.reduction_mode = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SamplerReductionModeCreateInfoEXT<'a> = SamplerReductionModeCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSamplerFilterMinmaxProperties.html>"]
#[doc(alias = "VkPhysicalDeviceSamplerFilterMinmaxProperties")]
pub struct PhysicalDeviceSamplerFilterMinmaxProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub filter_minmax_single_component_formats: Bool32,
    pub filter_minmax_image_component_mapping: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSamplerFilterMinmaxProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceSamplerFilterMinmaxProperties;
}
unsafe impl<'a> Send for PhysicalDeviceSamplerFilterMinmaxProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSamplerFilterMinmaxProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceSamplerFilterMinmaxProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceSamplerFilterMinmaxProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            filter_minmax_single_component_formats: Default::default(),
            filter_minmax_image_component_mapping: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSamplerFilterMinmaxProperties<'a> {
    #[inline]
    pub fn filter_minmax_single_component_formats(mut self, value: impl Into<Bool32>) -> Self {
        self.filter_minmax_single_component_formats = value.into();
        self
    }
    #[inline]
    pub fn filter_minmax_image_component_mapping(mut self, value: impl Into<Bool32>) -> Self {
        self.filter_minmax_image_component_mapping = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceSamplerFilterMinmaxPropertiesEXT<'a> =
    PhysicalDeviceSamplerFilterMinmaxProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkanMemoryModelFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceVulkanMemoryModelFeatures")]
pub struct PhysicalDeviceVulkanMemoryModelFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub vulkan_memory_model: Bool32,
    pub vulkan_memory_model_device_scope: Bool32,
    pub vulkan_memory_model_availability_visibility_chains: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceVulkanMemoryModelFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceVulkanMemoryModelFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceVulkanMemoryModelFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceVulkanMemoryModelFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceVulkanMemoryModelFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceVulkanMemoryModelFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceVulkanMemoryModelFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            vulkan_memory_model: Default::default(),
            vulkan_memory_model_device_scope: Default::default(),
            vulkan_memory_model_availability_visibility_chains: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceVulkanMemoryModelFeatures<'a> {
    #[inline]
    pub fn vulkan_memory_model(mut self, value: impl Into<Bool32>) -> Self {
        self.vulkan_memory_model = value.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model_device_scope(mut self, value: impl Into<Bool32>) -> Self {
        self.vulkan_memory_model_device_scope = value.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model_availability_visibility_chains(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.vulkan_memory_model_availability_visibility_chains = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceVulkanMemoryModelFeaturesKHR<'a> =
    PhysicalDeviceVulkanMemoryModelFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImagelessFramebufferFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceImagelessFramebufferFeatures")]
pub struct PhysicalDeviceImagelessFramebufferFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub imageless_framebuffer: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImagelessFramebufferFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceImagelessFramebufferFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceImagelessFramebufferFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImagelessFramebufferFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceImagelessFramebufferFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceImagelessFramebufferFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceImagelessFramebufferFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            imageless_framebuffer: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImagelessFramebufferFeatures<'a> {
    #[inline]
    pub fn imageless_framebuffer(mut self, value: impl Into<Bool32>) -> Self {
        self.imageless_framebuffer = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceImagelessFramebufferFeaturesKHR<'a> =
    PhysicalDeviceImagelessFramebufferFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferAttachmentsCreateInfo.html>"]
#[doc(alias = "VkFramebufferAttachmentsCreateInfo")]
pub struct FramebufferAttachmentsCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) attachment_image_info_count: u32,
    pub(crate) p_attachment_image_infos: *const FramebufferAttachmentImageInfo<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for FramebufferAttachmentsCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FramebufferAttachmentsCreateInfo;
}
unsafe impl<'a> Send for FramebufferAttachmentsCreateInfo<'a> {}
unsafe impl<'a> Sync for FramebufferAttachmentsCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<FramebufferCreateInfo<'b>>
    for FramebufferAttachmentsCreateInfo<'a>
{
}
impl<'a> Default for FramebufferAttachmentsCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            attachment_image_info_count: Default::default(),
            p_attachment_image_infos: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> FramebufferAttachmentsCreateInfo<'a> {
    #[inline]
    pub fn attachment_image_infos(
        mut self,
        p_attachment_image_infos: impl AsSlice<'a, FramebufferAttachmentImageInfo<'a>>,
    ) -> Self {
        self.p_attachment_image_infos = p_attachment_image_infos.as_slice().as_ptr().cast();
        self.attachment_image_info_count = p_attachment_image_infos.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type FramebufferAttachmentsCreateInfoKHR<'a> = FramebufferAttachmentsCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferAttachmentImageInfo.html>"]
#[doc(alias = "VkFramebufferAttachmentImageInfo")]
pub struct FramebufferAttachmentImageInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: ImageCreateFlags,
    pub usage: ImageUsageFlags,
    pub width: u32,
    pub height: u32,
    pub layer_count: u32,
    pub(crate) view_format_count: u32,
    pub(crate) p_view_formats: *const Format,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for FramebufferAttachmentImageInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FramebufferAttachmentImageInfo;
}
unsafe impl<'a> Send for FramebufferAttachmentImageInfo<'a> {}
unsafe impl<'a> Sync for FramebufferAttachmentImageInfo<'a> {}
impl<'a> Default for FramebufferAttachmentImageInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            usage: Default::default(),
            width: Default::default(),
            height: Default::default(),
            layer_count: Default::default(),
            view_format_count: Default::default(),
            p_view_formats: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> FramebufferAttachmentImageInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: ImageCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn usage(mut self, value: ImageUsageFlags) -> Self {
        self.usage = value;
        self
    }
    #[inline]
    pub fn width(mut self, value: u32) -> Self {
        self.width = value;
        self
    }
    #[inline]
    pub fn height(mut self, value: u32) -> Self {
        self.height = value;
        self
    }
    #[inline]
    pub fn layer_count(mut self, value: u32) -> Self {
        self.layer_count = value;
        self
    }
    #[inline]
    pub fn view_formats(mut self, p_view_formats: impl AsSlice<'a, Format>) -> Self {
        self.p_view_formats = p_view_formats.as_slice().as_ptr().cast();
        self.view_format_count = p_view_formats.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type FramebufferAttachmentImageInfoKHR<'a> = FramebufferAttachmentImageInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassAttachmentBeginInfo.html>"]
#[doc(alias = "VkRenderPassAttachmentBeginInfo")]
pub struct RenderPassAttachmentBeginInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) attachment_count: u32,
    pub(crate) p_attachments: *const ImageView,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassAttachmentBeginInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassAttachmentBeginInfo;
}
unsafe impl<'a> Send for RenderPassAttachmentBeginInfo<'a> {}
unsafe impl<'a> Sync for RenderPassAttachmentBeginInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderPassBeginInfo<'b>>
    for RenderPassAttachmentBeginInfo<'a>
{
}
impl<'a> Default for RenderPassAttachmentBeginInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            attachment_count: Default::default(),
            p_attachments: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassAttachmentBeginInfo<'a> {
    #[inline]
    pub fn attachments<V0: Alias<raw::ImageView> + 'a>(
        mut self,
        p_attachments: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_attachments = p_attachments.as_slice().as_ptr().cast();
        self.attachment_count = p_attachments.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type RenderPassAttachmentBeginInfoKHR<'a> = RenderPassAttachmentBeginInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceUniformBufferStandardLayoutFeatures")]
pub struct PhysicalDeviceUniformBufferStandardLayoutFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub uniform_buffer_standard_layout: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceUniformBufferStandardLayoutFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceUniformBufferStandardLayoutFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceUniformBufferStandardLayoutFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceUniformBufferStandardLayoutFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceUniformBufferStandardLayoutFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceUniformBufferStandardLayoutFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceUniformBufferStandardLayoutFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            uniform_buffer_standard_layout: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceUniformBufferStandardLayoutFeatures<'a> {
    #[inline]
    pub fn uniform_buffer_standard_layout(mut self, value: impl Into<Bool32>) -> Self {
        self.uniform_buffer_standard_layout = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR<'a> =
    PhysicalDeviceUniformBufferStandardLayoutFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures")]
pub struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_subgroup_extended_types: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_subgroup_extended_types: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a> {
    #[inline]
    pub fn shader_subgroup_extended_types(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_subgroup_extended_types = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR<'a> =
    PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures")]
pub struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub separate_depth_stencil_layouts: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            separate_depth_stencil_layouts: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a> {
    #[inline]
    pub fn separate_depth_stencil_layouts(mut self, value: impl Into<Bool32>) -> Self {
        self.separate_depth_stencil_layouts = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR<'a> =
    PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReferenceStencilLayout.html>"]
#[doc(alias = "VkAttachmentReferenceStencilLayout")]
pub struct AttachmentReferenceStencilLayout<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub stencil_layout: ImageLayout,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AttachmentReferenceStencilLayout<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AttachmentReferenceStencilLayout;
}
unsafe impl<'a> Send for AttachmentReferenceStencilLayout<'a> {}
unsafe impl<'a> Sync for AttachmentReferenceStencilLayout<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<AttachmentReference2<'b>>
    for AttachmentReferenceStencilLayout<'a>
{
}
impl<'a> Default for AttachmentReferenceStencilLayout<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stencil_layout: ImageLayout::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> AttachmentReferenceStencilLayout<'a> {
    #[inline]
    pub fn stencil_layout(mut self, value: ImageLayout) -> Self {
        self.stencil_layout = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type AttachmentReferenceStencilLayoutKHR<'a> = AttachmentReferenceStencilLayout<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescriptionStencilLayout.html>"]
#[doc(alias = "VkAttachmentDescriptionStencilLayout")]
pub struct AttachmentDescriptionStencilLayout<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub stencil_initial_layout: ImageLayout,
    pub stencil_final_layout: ImageLayout,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AttachmentDescriptionStencilLayout<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AttachmentDescriptionStencilLayout;
}
unsafe impl<'a> Send for AttachmentDescriptionStencilLayout<'a> {}
unsafe impl<'a> Sync for AttachmentDescriptionStencilLayout<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<AttachmentDescription2<'b>>
    for AttachmentDescriptionStencilLayout<'a>
{
}
impl<'a> Default for AttachmentDescriptionStencilLayout<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stencil_initial_layout: ImageLayout::Undefined,
            stencil_final_layout: ImageLayout::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> AttachmentDescriptionStencilLayout<'a> {
    #[inline]
    pub fn stencil_initial_layout(mut self, value: ImageLayout) -> Self {
        self.stencil_initial_layout = value;
        self
    }
    #[inline]
    pub fn stencil_final_layout(mut self, value: ImageLayout) -> Self {
        self.stencil_final_layout = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type AttachmentDescriptionStencilLayoutKHR<'a> = AttachmentDescriptionStencilLayout<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceHostQueryResetFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceHostQueryResetFeatures")]
pub struct PhysicalDeviceHostQueryResetFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub host_query_reset: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceHostQueryResetFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceHostQueryResetFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceHostQueryResetFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceHostQueryResetFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceHostQueryResetFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceHostQueryResetFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceHostQueryResetFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            host_query_reset: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceHostQueryResetFeatures<'a> {
    #[inline]
    pub fn host_query_reset(mut self, value: impl Into<Bool32>) -> Self {
        self.host_query_reset = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceHostQueryResetFeaturesEXT<'a> = PhysicalDeviceHostQueryResetFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTimelineSemaphoreFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceTimelineSemaphoreFeatures")]
pub struct PhysicalDeviceTimelineSemaphoreFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub timeline_semaphore: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceTimelineSemaphoreFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceTimelineSemaphoreFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceTimelineSemaphoreFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceTimelineSemaphoreFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceTimelineSemaphoreFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceTimelineSemaphoreFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceTimelineSemaphoreFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            timeline_semaphore: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceTimelineSemaphoreFeatures<'a> {
    #[inline]
    pub fn timeline_semaphore(mut self, value: impl Into<Bool32>) -> Self {
        self.timeline_semaphore = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceTimelineSemaphoreFeaturesKHR<'a> =
    PhysicalDeviceTimelineSemaphoreFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTimelineSemaphoreProperties.html>"]
#[doc(alias = "VkPhysicalDeviceTimelineSemaphoreProperties")]
pub struct PhysicalDeviceTimelineSemaphoreProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_timeline_semaphore_value_difference: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceTimelineSemaphoreProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceTimelineSemaphoreProperties;
}
unsafe impl<'a> Send for PhysicalDeviceTimelineSemaphoreProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceTimelineSemaphoreProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceTimelineSemaphoreProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceTimelineSemaphoreProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_timeline_semaphore_value_difference: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceTimelineSemaphoreProperties<'a> {
    #[inline]
    pub fn max_timeline_semaphore_value_difference(mut self, value: u64) -> Self {
        self.max_timeline_semaphore_value_difference = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceTimelineSemaphorePropertiesKHR<'a> =
    PhysicalDeviceTimelineSemaphoreProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreTypeCreateInfo.html>"]
#[doc(alias = "VkSemaphoreTypeCreateInfo")]
pub struct SemaphoreTypeCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub semaphore_type: SemaphoreType,
    pub initial_value: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SemaphoreTypeCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SemaphoreTypeCreateInfo;
}
unsafe impl<'a> Send for SemaphoreTypeCreateInfo<'a> {}
unsafe impl<'a> Sync for SemaphoreTypeCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SemaphoreCreateInfo<'b>> for SemaphoreTypeCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceExternalSemaphoreInfo<'b>>
    for SemaphoreTypeCreateInfo<'a>
{
}
impl<'a> Default for SemaphoreTypeCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            semaphore_type: SemaphoreType::Binary,
            initial_value: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SemaphoreTypeCreateInfo<'a> {
    #[inline]
    pub fn semaphore_type(mut self, value: SemaphoreType) -> Self {
        self.semaphore_type = value;
        self
    }
    #[inline]
    pub fn initial_value(mut self, value: u64) -> Self {
        self.initial_value = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SemaphoreTypeCreateInfoKHR<'a> = SemaphoreTypeCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTimelineSemaphoreSubmitInfo.html>"]
#[doc(alias = "VkTimelineSemaphoreSubmitInfo")]
pub struct TimelineSemaphoreSubmitInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub wait_semaphore_value_count: u32,
    pub(crate) p_wait_semaphore_values: *const u64,
    pub signal_semaphore_value_count: u32,
    pub(crate) p_signal_semaphore_values: *const u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for TimelineSemaphoreSubmitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::TimelineSemaphoreSubmitInfo;
}
unsafe impl<'a> Send for TimelineSemaphoreSubmitInfo<'a> {}
unsafe impl<'a> Sync for TimelineSemaphoreSubmitInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo<'b>> for TimelineSemaphoreSubmitInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BindSparseInfo<'b>> for TimelineSemaphoreSubmitInfo<'a> {}
impl<'a> Default for TimelineSemaphoreSubmitInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            wait_semaphore_value_count: Default::default(),
            p_wait_semaphore_values: ptr::null(),
            signal_semaphore_value_count: Default::default(),
            p_signal_semaphore_values: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> TimelineSemaphoreSubmitInfo<'a> {
    #[inline]
    pub fn wait_semaphore_value_count(mut self, value: u32) -> Self {
        self.wait_semaphore_value_count = value;
        self
    }
    #[inline]
    pub fn signal_semaphore_value_count(mut self, value: u32) -> Self {
        self.signal_semaphore_value_count = value;
        self
    }
    #[inline]
    pub fn wait_semaphore_values(mut self, p_wait_semaphore_values: impl AsSlice<'a, u64>) -> Self {
        self.p_wait_semaphore_values = p_wait_semaphore_values.as_slice().as_ptr().cast();
        self.wait_semaphore_value_count = p_wait_semaphore_values.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn signal_semaphore_values(
        mut self,
        p_signal_semaphore_values: impl AsSlice<'a, u64>,
    ) -> Self {
        self.p_signal_semaphore_values = p_signal_semaphore_values.as_slice().as_ptr().cast();
        self.signal_semaphore_value_count = p_signal_semaphore_values.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type TimelineSemaphoreSubmitInfoKHR<'a> = TimelineSemaphoreSubmitInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreWaitInfo.html>"]
#[doc(alias = "VkSemaphoreWaitInfo")]
pub struct SemaphoreWaitInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: SemaphoreWaitFlags,
    pub(crate) semaphore_count: u32,
    pub(crate) p_semaphores: *const Semaphore,
    pub(crate) p_values: *const u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SemaphoreWaitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SemaphoreWaitInfo;
}
unsafe impl<'a> Send for SemaphoreWaitInfo<'a> {}
unsafe impl<'a> Sync for SemaphoreWaitInfo<'a> {}
impl<'a> Default for SemaphoreWaitInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            semaphore_count: Default::default(),
            p_semaphores: ptr::null(),
            p_values: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SemaphoreWaitInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: SemaphoreWaitFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn semaphore<V0: Alias<raw::Semaphore> + 'a>(
        mut self,
        p_semaphores: impl AsSlice<'a, V0>,
        p_values: impl AsSlice<'a, u64>,
    ) -> Self {
        self.p_semaphores = p_semaphores.as_slice().as_ptr().cast();
        self.p_values = p_values.as_slice().as_ptr().cast();
        self.semaphore_count = p_semaphores.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SemaphoreWaitInfoKHR<'a> = SemaphoreWaitInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSignalInfo.html>"]
#[doc(alias = "VkSemaphoreSignalInfo")]
pub struct SemaphoreSignalInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub semaphore: Option<Semaphore>,
    pub value: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SemaphoreSignalInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SemaphoreSignalInfo;
}
unsafe impl<'a> Send for SemaphoreSignalInfo<'a> {}
unsafe impl<'a> Sync for SemaphoreSignalInfo<'a> {}
impl<'a> Default for SemaphoreSignalInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            semaphore: Default::default(),
            value: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SemaphoreSignalInfo<'a> {
    #[inline]
    pub fn semaphore(mut self, value: &'a Semaphore) -> Self {
        self.semaphore = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn value(mut self, value: u64) -> Self {
        self.value = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SemaphoreSignalInfoKHR<'a> = SemaphoreSignalInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBufferDeviceAddressFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceBufferDeviceAddressFeatures")]
pub struct PhysicalDeviceBufferDeviceAddressFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceBufferDeviceAddressFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceBufferDeviceAddressFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceBufferDeviceAddressFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceBufferDeviceAddressFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceBufferDeviceAddressFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceBufferDeviceAddressFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceBufferDeviceAddressFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            buffer_device_address: Default::default(),
            buffer_device_address_capture_replay: Default::default(),
            buffer_device_address_multi_device: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceBufferDeviceAddressFeatures<'a> {
    #[inline]
    pub fn buffer_device_address(mut self, value: impl Into<Bool32>) -> Self {
        self.buffer_device_address = value.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_capture_replay(mut self, value: impl Into<Bool32>) -> Self {
        self.buffer_device_address_capture_replay = value.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_multi_device(mut self, value: impl Into<Bool32>) -> Self {
        self.buffer_device_address_multi_device = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceBufferDeviceAddressFeaturesKHR<'a> =
    PhysicalDeviceBufferDeviceAddressFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferDeviceAddressInfo.html>"]
#[doc(alias = "VkBufferDeviceAddressInfo")]
pub struct BufferDeviceAddressInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub buffer: Option<Buffer>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferDeviceAddressInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferDeviceAddressInfo;
}
unsafe impl<'a> Send for BufferDeviceAddressInfo<'a> {}
unsafe impl<'a> Sync for BufferDeviceAddressInfo<'a> {}
impl<'a> Default for BufferDeviceAddressInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            buffer: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferDeviceAddressInfo<'a> {
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type BufferDeviceAddressInfoKHR<'a> = BufferDeviceAddressInfo<'a>;
pub type BufferDeviceAddressInfoEXT<'a> = BufferDeviceAddressInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferOpaqueCaptureAddressCreateInfo.html>"]
#[doc(alias = "VkBufferOpaqueCaptureAddressCreateInfo")]
pub struct BufferOpaqueCaptureAddressCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub opaque_capture_address: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferOpaqueCaptureAddressCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferOpaqueCaptureAddressCreateInfo;
}
unsafe impl<'a> Send for BufferOpaqueCaptureAddressCreateInfo<'a> {}
unsafe impl<'a> Sync for BufferOpaqueCaptureAddressCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BufferCreateInfo<'b>>
    for BufferOpaqueCaptureAddressCreateInfo<'a>
{
}
impl<'a> Default for BufferOpaqueCaptureAddressCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            opaque_capture_address: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferOpaqueCaptureAddressCreateInfo<'a> {
    #[inline]
    pub fn opaque_capture_address(mut self, value: u64) -> Self {
        self.opaque_capture_address = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type BufferOpaqueCaptureAddressCreateInfoKHR<'a> = BufferOpaqueCaptureAddressCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryOpaqueCaptureAddressAllocateInfo.html>"]
#[doc(alias = "VkMemoryOpaqueCaptureAddressAllocateInfo")]
pub struct MemoryOpaqueCaptureAddressAllocateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub opaque_capture_address: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryOpaqueCaptureAddressAllocateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryOpaqueCaptureAddressAllocateInfo;
}
unsafe impl<'a> Send for MemoryOpaqueCaptureAddressAllocateInfo<'a> {}
unsafe impl<'a> Sync for MemoryOpaqueCaptureAddressAllocateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>>
    for MemoryOpaqueCaptureAddressAllocateInfo<'a>
{
}
impl<'a> Default for MemoryOpaqueCaptureAddressAllocateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            opaque_capture_address: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryOpaqueCaptureAddressAllocateInfo<'a> {
    #[inline]
    pub fn opaque_capture_address(mut self, value: u64) -> Self {
        self.opaque_capture_address = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type MemoryOpaqueCaptureAddressAllocateInfoKHR<'a> = MemoryOpaqueCaptureAddressAllocateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryOpaqueCaptureAddressInfo.html>"]
#[doc(alias = "VkDeviceMemoryOpaqueCaptureAddressInfo")]
pub struct DeviceMemoryOpaqueCaptureAddressInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory: Option<DeviceMemory>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceMemoryOpaqueCaptureAddressInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceMemoryOpaqueCaptureAddressInfo;
}
unsafe impl<'a> Send for DeviceMemoryOpaqueCaptureAddressInfo<'a> {}
unsafe impl<'a> Sync for DeviceMemoryOpaqueCaptureAddressInfo<'a> {}
impl<'a> Default for DeviceMemoryOpaqueCaptureAddressInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceMemoryOpaqueCaptureAddressInfo<'a> {
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DeviceMemoryOpaqueCaptureAddressInfoKHR<'a> = DeviceMemoryOpaqueCaptureAddressInfo<'a>;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFlags64.html>"]
#[doc(alias = "VkFlags64")]
pub type Flags64 = u64;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html>"]
#[doc(alias = "VkPhysicalDeviceVulkan13Features")]
pub struct PhysicalDeviceVulkan13Features<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub robust_image_access: Bool32,
    pub inline_uniform_block: Bool32,
    pub descriptor_binding_inline_uniform_block_update_after_bind: Bool32,
    pub pipeline_creation_cache_control: Bool32,
    pub private_data: Bool32,
    pub shader_demote_to_helper_invocation: Bool32,
    pub shader_terminate_invocation: Bool32,
    pub subgroup_size_control: Bool32,
    pub compute_full_subgroups: Bool32,
    pub synchronization2: Bool32,
    pub texture_compression_astc_hdr: Bool32,
    pub shader_zero_initialize_workgroup_memory: Bool32,
    pub dynamic_rendering: Bool32,
    pub shader_integer_dot_product: Bool32,
    pub maintenance4: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceVulkan13Features<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceVulkan13Features;
}
unsafe impl<'a> Send for PhysicalDeviceVulkan13Features<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceVulkan13Features<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceVulkan13Features<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceVulkan13Features<'a>
{
}
impl<'a> Default for PhysicalDeviceVulkan13Features<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            robust_image_access: Default::default(),
            inline_uniform_block: Default::default(),
            descriptor_binding_inline_uniform_block_update_after_bind: Default::default(),
            pipeline_creation_cache_control: Default::default(),
            private_data: Default::default(),
            shader_demote_to_helper_invocation: Default::default(),
            shader_terminate_invocation: Default::default(),
            subgroup_size_control: Default::default(),
            compute_full_subgroups: Default::default(),
            synchronization2: Default::default(),
            texture_compression_astc_hdr: Default::default(),
            shader_zero_initialize_workgroup_memory: Default::default(),
            dynamic_rendering: Default::default(),
            shader_integer_dot_product: Default::default(),
            maintenance4: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceVulkan13Features<'a> {
    #[inline]
    pub fn robust_image_access(mut self, value: impl Into<Bool32>) -> Self {
        self.robust_image_access = value.into();
        self
    }
    #[inline]
    pub fn inline_uniform_block(mut self, value: impl Into<Bool32>) -> Self {
        self.inline_uniform_block = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_inline_uniform_block_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn pipeline_creation_cache_control(mut self, value: impl Into<Bool32>) -> Self {
        self.pipeline_creation_cache_control = value.into();
        self
    }
    #[inline]
    pub fn private_data(mut self, value: impl Into<Bool32>) -> Self {
        self.private_data = value.into();
        self
    }
    #[inline]
    pub fn shader_demote_to_helper_invocation(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_demote_to_helper_invocation = value.into();
        self
    }
    #[inline]
    pub fn shader_terminate_invocation(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_terminate_invocation = value.into();
        self
    }
    #[inline]
    pub fn subgroup_size_control(mut self, value: impl Into<Bool32>) -> Self {
        self.subgroup_size_control = value.into();
        self
    }
    #[inline]
    pub fn compute_full_subgroups(mut self, value: impl Into<Bool32>) -> Self {
        self.compute_full_subgroups = value.into();
        self
    }
    #[inline]
    pub fn synchronization2(mut self, value: impl Into<Bool32>) -> Self {
        self.synchronization2 = value.into();
        self
    }
    #[inline]
    pub fn texture_compression_astc_hdr(mut self, value: impl Into<Bool32>) -> Self {
        self.texture_compression_astc_hdr = value.into();
        self
    }
    #[inline]
    pub fn shader_zero_initialize_workgroup_memory(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_zero_initialize_workgroup_memory = value.into();
        self
    }
    #[inline]
    pub fn dynamic_rendering(mut self, value: impl Into<Bool32>) -> Self {
        self.dynamic_rendering = value.into();
        self
    }
    #[inline]
    pub fn shader_integer_dot_product(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_integer_dot_product = value.into();
        self
    }
    #[inline]
    pub fn maintenance4(mut self, value: impl Into<Bool32>) -> Self {
        self.maintenance4 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Properties.html>"]
#[doc(alias = "VkPhysicalDeviceVulkan13Properties")]
pub struct PhysicalDeviceVulkan13Properties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub min_subgroup_size: u32,
    pub max_subgroup_size: u32,
    pub max_compute_workgroup_subgroups: u32,
    pub required_subgroup_size_stages: ShaderStageFlags,
    pub max_inline_uniform_block_size: u32,
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    pub max_descriptor_set_inline_uniform_blocks: u32,
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    pub max_inline_uniform_total_size: u32,
    pub integer_dot_product8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product8_bit_signed_accelerated: Bool32,
    pub integer_dot_product8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product16_bit_signed_accelerated: Bool32,
    pub integer_dot_product16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product32_bit_signed_accelerated: Bool32,
    pub integer_dot_product32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product64_bit_signed_accelerated: Bool32,
    pub integer_dot_product64_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated:
        Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32,
    pub storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub storage_texel_buffer_offset_single_texel_alignment: Bool32,
    pub uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub uniform_texel_buffer_offset_single_texel_alignment: Bool32,
    pub max_buffer_size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceVulkan13Properties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceVulkan13Properties;
}
unsafe impl<'a> Send for PhysicalDeviceVulkan13Properties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceVulkan13Properties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceVulkan13Properties<'a>
{
}
impl<'a> Default for PhysicalDeviceVulkan13Properties<'a> {
    fn default() -> Self {
        Self { s_type : Self :: STRUCTURE_TYPE , p_next : Cell :: new (ptr :: null ()) , min_subgroup_size : Default :: default () , max_subgroup_size : Default :: default () , max_compute_workgroup_subgroups : Default :: default () , required_subgroup_size_stages : Default :: default () , max_inline_uniform_block_size : Default :: default () , max_per_stage_descriptor_inline_uniform_blocks : Default :: default () , max_per_stage_descriptor_update_after_bind_inline_uniform_blocks : Default :: default () , max_descriptor_set_inline_uniform_blocks : Default :: default () , max_descriptor_set_update_after_bind_inline_uniform_blocks : Default :: default () , max_inline_uniform_total_size : Default :: default () , integer_dot_product8_bit_unsigned_accelerated : Default :: default () , integer_dot_product8_bit_signed_accelerated : Default :: default () , integer_dot_product8_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product4x8_bit_packed_unsigned_accelerated : Default :: default () , integer_dot_product4x8_bit_packed_signed_accelerated : Default :: default () , integer_dot_product4x8_bit_packed_mixed_signedness_accelerated : Default :: default () , integer_dot_product16_bit_unsigned_accelerated : Default :: default () , integer_dot_product16_bit_signed_accelerated : Default :: default () , integer_dot_product16_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product32_bit_unsigned_accelerated : Default :: default () , integer_dot_product32_bit_signed_accelerated : Default :: default () , integer_dot_product32_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product64_bit_unsigned_accelerated : Default :: default () , integer_dot_product64_bit_signed_accelerated : Default :: default () , integer_dot_product64_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated : Default :: default () , integer_dot_product_accumulating_saturating8_bit_signed_accelerated : Default :: default () , integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated : Default :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated : Default :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated : Default :: default () , integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated : Default :: default () , integer_dot_product_accumulating_saturating16_bit_signed_accelerated : Default :: default () , integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated : Default :: default () , integer_dot_product_accumulating_saturating32_bit_signed_accelerated : Default :: default () , integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated : Default :: default () , integer_dot_product_accumulating_saturating64_bit_signed_accelerated : Default :: default () , integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated : Default :: default () , storage_texel_buffer_offset_alignment_bytes : Default :: default () , storage_texel_buffer_offset_single_texel_alignment : Default :: default () , uniform_texel_buffer_offset_alignment_bytes : Default :: default () , uniform_texel_buffer_offset_single_texel_alignment : Default :: default () , max_buffer_size : Default :: default () , phantom : PhantomData , }
    }
}
impl<'a> PhysicalDeviceVulkan13Properties<'a> {
    #[inline]
    pub fn min_subgroup_size(mut self, value: u32) -> Self {
        self.min_subgroup_size = value;
        self
    }
    #[inline]
    pub fn max_subgroup_size(mut self, value: u32) -> Self {
        self.max_subgroup_size = value;
        self
    }
    #[inline]
    pub fn max_compute_workgroup_subgroups(mut self, value: u32) -> Self {
        self.max_compute_workgroup_subgroups = value;
        self
    }
    #[inline]
    pub fn required_subgroup_size_stages(mut self, value: ShaderStageFlags) -> Self {
        self.required_subgroup_size_stages = value;
        self
    }
    #[inline]
    pub fn max_inline_uniform_block_size(mut self, value: u32) -> Self {
        self.max_inline_uniform_block_size = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_inline_uniform_blocks(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_inline_uniform_blocks = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(
        mut self,
        value: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_inline_uniform_blocks(mut self, value: u32) -> Self {
        self.max_descriptor_set_inline_uniform_blocks = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks(
        mut self,
        value: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_inline_uniform_blocks = value;
        self
    }
    #[inline]
    pub fn max_inline_uniform_total_size(mut self, value: u32) -> Self {
        self.max_inline_uniform_total_size = value;
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product8_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_signed_accelerated(mut self, value: impl Into<Bool32>) -> Self {
        self.integer_dot_product8_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product8_bit_mixed_signedness_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product4x8_bit_packed_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product16_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product16_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product16_bit_mixed_signedness_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product32_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product32_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product32_bit_mixed_signedness_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product64_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product64_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product64_bit_mixed_signedness_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated =
            value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated =
            value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated =
            value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self . integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated = value . into () ;
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated =
            value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated =
            value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated =
            value.into();
        self
    }
    #[inline]
    pub fn storage_texel_buffer_offset_alignment_bytes(mut self, value: DeviceSize) -> Self {
        self.storage_texel_buffer_offset_alignment_bytes = value;
        self
    }
    #[inline]
    pub fn storage_texel_buffer_offset_single_texel_alignment(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.storage_texel_buffer_offset_single_texel_alignment = value.into();
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_offset_alignment_bytes(mut self, value: DeviceSize) -> Self {
        self.uniform_texel_buffer_offset_alignment_bytes = value;
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_offset_single_texel_alignment(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.uniform_texel_buffer_offset_single_texel_alignment = value.into();
        self
    }
    #[inline]
    pub fn max_buffer_size(mut self, value: DeviceSize) -> Self {
        self.max_buffer_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackCreateInfo.html>"]
#[doc(alias = "VkPipelineCreationFeedbackCreateInfo")]
pub struct PipelineCreationFeedbackCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_pipeline_creation_feedback: *const PipelineCreationFeedback,
    pub(crate) pipeline_stage_creation_feedback_count: u32,
    pub(crate) p_pipeline_stage_creation_feedbacks: *const PipelineCreationFeedback,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineCreationFeedbackCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineCreationFeedbackCreateInfo;
}
unsafe impl<'a> Send for PipelineCreationFeedbackCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineCreationFeedbackCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for PipelineCreationFeedbackCreateInfo<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<ComputePipelineCreateInfo<'b>>
    for PipelineCreationFeedbackCreateInfo<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<RayTracingPipelineCreateInfoNV<'b>>
    for PipelineCreationFeedbackCreateInfo<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<RayTracingPipelineCreateInfoKHR<'b>>
    for PipelineCreationFeedbackCreateInfo<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<ExecutionGraphPipelineCreateInfoAMDX<'b>>
    for PipelineCreationFeedbackCreateInfo<'a>
{
}
impl<'a> Default for PipelineCreationFeedbackCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_pipeline_creation_feedback: ptr::null(),
            pipeline_stage_creation_feedback_count: Default::default(),
            p_pipeline_stage_creation_feedbacks: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineCreationFeedbackCreateInfo<'a> {
    #[inline]
    pub fn pipeline_creation_feedback(mut self, value: &'a PipelineCreationFeedback) -> Self {
        self.p_pipeline_creation_feedback = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn pipeline_stage_creation_feedbacks(
        mut self,
        p_pipeline_stage_creation_feedbacks: impl AsSlice<'a, PipelineCreationFeedback>,
    ) -> Self {
        self.p_pipeline_stage_creation_feedbacks = p_pipeline_stage_creation_feedbacks
            .as_slice()
            .as_ptr()
            .cast();
        self.pipeline_stage_creation_feedback_count =
            p_pipeline_stage_creation_feedbacks.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PipelineCreationFeedbackCreateInfoEXT<'a> = PipelineCreationFeedbackCreateInfo<'a>;
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedback.html>"]
#[doc(alias = "VkPipelineCreationFeedback")]
pub struct PipelineCreationFeedback {
    pub flags: PipelineCreationFeedbackFlags,
    pub duration: u64,
}
unsafe impl Send for PipelineCreationFeedback {}
unsafe impl Sync for PipelineCreationFeedback {}
impl Default for PipelineCreationFeedback {
    fn default() -> Self {
        Self {
            flags: Default::default(),
            duration: Default::default(),
        }
    }
}
impl PipelineCreationFeedback {
    #[inline]
    pub fn flags(mut self, value: PipelineCreationFeedbackFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn duration(mut self, value: u64) -> Self {
        self.duration = value;
        self
    }
}
pub type PipelineCreationFeedbackEXT = PipelineCreationFeedback;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTerminateInvocationFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceShaderTerminateInvocationFeatures")]
pub struct PhysicalDeviceShaderTerminateInvocationFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_terminate_invocation: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderTerminateInvocationFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderTerminateInvocationFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceShaderTerminateInvocationFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderTerminateInvocationFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderTerminateInvocationFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderTerminateInvocationFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderTerminateInvocationFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_terminate_invocation: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderTerminateInvocationFeatures<'a> {
    #[inline]
    pub fn shader_terminate_invocation(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_terminate_invocation = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceShaderTerminateInvocationFeaturesKHR<'a> =
    PhysicalDeviceShaderTerminateInvocationFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceToolProperties.html>"]
#[doc(alias = "VkPhysicalDeviceToolProperties")]
pub struct PhysicalDeviceToolProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) name: [c_char; MAX_EXTENSION_NAME_SIZE as _],
    pub(crate) version: [c_char; MAX_EXTENSION_NAME_SIZE as _],
    pub purposes: ToolPurposeFlags,
    pub(crate) description: [c_char; MAX_DESCRIPTION_SIZE as _],
    pub(crate) layer: [c_char; MAX_EXTENSION_NAME_SIZE as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceToolProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceToolProperties;
}
unsafe impl<'a> Send for PhysicalDeviceToolProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceToolProperties<'a> {}
impl<'a> Default for PhysicalDeviceToolProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            name: array::from_fn(|_| Default::default()),
            version: array::from_fn(|_| Default::default()),
            purposes: Default::default(),
            description: array::from_fn(|_| Default::default()),
            layer: array::from_fn(|_| Default::default()),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceToolProperties<'a> {
    #[inline]
    pub fn purposes(mut self, value: ToolPurposeFlags) -> Self {
        self.purposes = value;
        self
    }
    pub fn get_name(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_EXTENSION_NAME_SIZE as _]>(&self.name) }
                .as_slice(),
        )
        .unwrap()
    }
    pub fn get_version(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_EXTENSION_NAME_SIZE as _]>(&self.version) }
                .as_slice(),
        )
        .unwrap()
    }
    pub fn get_description(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.description) }
                .as_slice(),
        )
        .unwrap()
    }
    pub fn get_layer(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_EXTENSION_NAME_SIZE as _]>(&self.layer) }
                .as_slice(),
        )
        .unwrap()
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceToolPropertiesEXT<'a> = PhysicalDeviceToolProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures")]
pub struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_demote_to_helper_invocation: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderDemoteToHelperInvocationFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_demote_to_helper_invocation: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'a> {
    #[inline]
    pub fn shader_demote_to_helper_invocation(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_demote_to_helper_invocation = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT<'a> =
    PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrivateDataFeatures.html>"]
#[doc(alias = "VkPhysicalDevicePrivateDataFeatures")]
pub struct PhysicalDevicePrivateDataFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub private_data: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePrivateDataFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDevicePrivateDataFeatures;
}
unsafe impl<'a> Send for PhysicalDevicePrivateDataFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePrivateDataFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePrivateDataFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePrivateDataFeatures<'a>
{
}
impl<'a> Default for PhysicalDevicePrivateDataFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            private_data: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePrivateDataFeatures<'a> {
    #[inline]
    pub fn private_data(mut self, value: impl Into<Bool32>) -> Self {
        self.private_data = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDevicePrivateDataFeaturesEXT<'a> = PhysicalDevicePrivateDataFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevicePrivateDataCreateInfo.html>"]
#[doc(alias = "VkDevicePrivateDataCreateInfo")]
pub struct DevicePrivateDataCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub private_data_slot_request_count: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DevicePrivateDataCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DevicePrivateDataCreateInfo;
}
unsafe impl<'a> Send for DevicePrivateDataCreateInfo<'a> {}
unsafe impl<'a> Sync for DevicePrivateDataCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>> for DevicePrivateDataCreateInfo<'a> {}
impl<'a> Default for DevicePrivateDataCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            private_data_slot_request_count: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DevicePrivateDataCreateInfo<'a> {
    #[inline]
    pub fn private_data_slot_request_count(mut self, value: u32) -> Self {
        self.private_data_slot_request_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DevicePrivateDataCreateInfoEXT<'a> = DevicePrivateDataCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlotCreateInfo.html>"]
#[doc(alias = "VkPrivateDataSlotCreateInfo")]
pub struct PrivateDataSlotCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PrivateDataSlotCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PrivateDataSlotCreateInfo;
}
unsafe impl<'a> Send for PrivateDataSlotCreateInfo<'a> {}
unsafe impl<'a> Sync for PrivateDataSlotCreateInfo<'a> {}
impl<'a> Default for PrivateDataSlotCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PrivateDataSlotCreateInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PrivateDataSlotCreateInfoEXT<'a> = PrivateDataSlotCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineCreationCacheControlFeatures.html>"]
#[doc(alias = "VkPhysicalDevicePipelineCreationCacheControlFeatures")]
pub struct PhysicalDevicePipelineCreationCacheControlFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline_creation_cache_control: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePipelineCreationCacheControlFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePipelineCreationCacheControlFeatures;
}
unsafe impl<'a> Send for PhysicalDevicePipelineCreationCacheControlFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePipelineCreationCacheControlFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePipelineCreationCacheControlFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePipelineCreationCacheControlFeatures<'a>
{
}
impl<'a> Default for PhysicalDevicePipelineCreationCacheControlFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline_creation_cache_control: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePipelineCreationCacheControlFeatures<'a> {
    #[inline]
    pub fn pipeline_creation_cache_control(mut self, value: impl Into<Bool32>) -> Self {
        self.pipeline_creation_cache_control = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDevicePipelineCreationCacheControlFeaturesEXT<'a> =
    PhysicalDevicePipelineCreationCacheControlFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier2.html>"]
#[doc(alias = "VkMemoryBarrier2")]
pub struct MemoryBarrier2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_stage_mask: u32,
    pub src_access_mask: u32,
    pub dst_stage_mask: u32,
    pub dst_access_mask: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryBarrier2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryBarrier2;
}
unsafe impl<'a> Send for MemoryBarrier2<'a> {}
unsafe impl<'a> Sync for MemoryBarrier2<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubpassDependency2<'b>> for MemoryBarrier2<'a> {}
impl<'a> Default for MemoryBarrier2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_stage_mask: Default::default(),
            dst_access_mask: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryBarrier2<'a> {
    #[inline]
    pub fn src_stage_mask(mut self, value: u32) -> Self {
        self.src_stage_mask = value;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, value: u32) -> Self {
        self.src_access_mask = value;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, value: u32) -> Self {
        self.dst_stage_mask = value;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, value: u32) -> Self {
        self.dst_access_mask = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type MemoryBarrier2KHR<'a> = MemoryBarrier2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier2.html>"]
#[doc(alias = "VkBufferMemoryBarrier2")]
pub struct BufferMemoryBarrier2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_stage_mask: u32,
    pub src_access_mask: u32,
    pub dst_stage_mask: u32,
    pub dst_access_mask: u32,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
    pub size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferMemoryBarrier2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferMemoryBarrier2;
}
unsafe impl<'a> Send for BufferMemoryBarrier2<'a> {}
unsafe impl<'a> Sync for BufferMemoryBarrier2<'a> {}
impl<'a> Default for BufferMemoryBarrier2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_stage_mask: Default::default(),
            dst_access_mask: Default::default(),
            src_queue_family_index: Default::default(),
            dst_queue_family_index: Default::default(),
            buffer: Default::default(),
            offset: Default::default(),
            size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferMemoryBarrier2<'a> {
    #[inline]
    pub fn src_stage_mask(mut self, value: u32) -> Self {
        self.src_stage_mask = value;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, value: u32) -> Self {
        self.src_access_mask = value;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, value: u32) -> Self {
        self.dst_stage_mask = value;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, value: u32) -> Self {
        self.dst_access_mask = value;
        self
    }
    #[inline]
    pub fn src_queue_family_index(mut self, value: u32) -> Self {
        self.src_queue_family_index = value;
        self
    }
    #[inline]
    pub fn dst_queue_family_index(mut self, value: u32) -> Self {
        self.dst_queue_family_index = value;
        self
    }
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn offset(mut self, value: DeviceSize) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type BufferMemoryBarrier2KHR<'a> = BufferMemoryBarrier2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier2.html>"]
#[doc(alias = "VkImageMemoryBarrier2")]
pub struct ImageMemoryBarrier2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_stage_mask: u32,
    pub src_access_mask: u32,
    pub dst_stage_mask: u32,
    pub dst_access_mask: u32,
    pub old_layout: ImageLayout,
    pub new_layout: ImageLayout,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub image: Option<Image>,
    pub subresource_range: ImageSubresourceRange,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageMemoryBarrier2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageMemoryBarrier2;
}
unsafe impl<'a> Send for ImageMemoryBarrier2<'a> {}
unsafe impl<'a> Sync for ImageMemoryBarrier2<'a> {}
impl<'a> Default for ImageMemoryBarrier2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_stage_mask: Default::default(),
            src_access_mask: Default::default(),
            dst_stage_mask: Default::default(),
            dst_access_mask: Default::default(),
            old_layout: ImageLayout::Undefined,
            new_layout: ImageLayout::Undefined,
            src_queue_family_index: Default::default(),
            dst_queue_family_index: Default::default(),
            image: Default::default(),
            subresource_range: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageMemoryBarrier2<'a> {
    #[inline]
    pub fn src_stage_mask(mut self, value: u32) -> Self {
        self.src_stage_mask = value;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, value: u32) -> Self {
        self.src_access_mask = value;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, value: u32) -> Self {
        self.dst_stage_mask = value;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, value: u32) -> Self {
        self.dst_access_mask = value;
        self
    }
    #[inline]
    pub fn old_layout(mut self, value: ImageLayout) -> Self {
        self.old_layout = value;
        self
    }
    #[inline]
    pub fn new_layout(mut self, value: ImageLayout) -> Self {
        self.new_layout = value;
        self
    }
    #[inline]
    pub fn src_queue_family_index(mut self, value: u32) -> Self {
        self.src_queue_family_index = value;
        self
    }
    #[inline]
    pub fn dst_queue_family_index(mut self, value: u32) -> Self {
        self.dst_queue_family_index = value;
        self
    }
    #[inline]
    pub fn image(mut self, value: &'a Image) -> Self {
        self.image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn subresource_range(mut self, value: ImageSubresourceRange) -> Self {
        self.subresource_range = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ImageMemoryBarrier2KHR<'a> = ImageMemoryBarrier2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyInfo.html>"]
#[doc(alias = "VkDependencyInfo")]
pub struct DependencyInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub dependency_flags: DependencyFlags,
    pub(crate) memory_barrier_count: u32,
    pub(crate) p_memory_barriers: *const MemoryBarrier2<'a>,
    pub(crate) buffer_memory_barrier_count: u32,
    pub(crate) p_buffer_memory_barriers: *const BufferMemoryBarrier2<'a>,
    pub(crate) image_memory_barrier_count: u32,
    pub(crate) p_image_memory_barriers: *const ImageMemoryBarrier2<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DependencyInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DependencyInfo;
}
unsafe impl<'a> Send for DependencyInfo<'a> {}
unsafe impl<'a> Sync for DependencyInfo<'a> {}
impl<'a> Default for DependencyInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            dependency_flags: Default::default(),
            memory_barrier_count: Default::default(),
            p_memory_barriers: ptr::null(),
            buffer_memory_barrier_count: Default::default(),
            p_buffer_memory_barriers: ptr::null(),
            image_memory_barrier_count: Default::default(),
            p_image_memory_barriers: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DependencyInfo<'a> {
    #[inline]
    pub fn dependency_flags(mut self, value: DependencyFlags) -> Self {
        self.dependency_flags = value;
        self
    }
    #[inline]
    pub fn memory_barriers(
        mut self,
        p_memory_barriers: impl AsSlice<'a, MemoryBarrier2<'a>>,
    ) -> Self {
        self.p_memory_barriers = p_memory_barriers.as_slice().as_ptr().cast();
        self.memory_barrier_count = p_memory_barriers.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn buffer_memory_barriers(
        mut self,
        p_buffer_memory_barriers: impl AsSlice<'a, BufferMemoryBarrier2<'a>>,
    ) -> Self {
        self.p_buffer_memory_barriers = p_buffer_memory_barriers.as_slice().as_ptr().cast();
        self.buffer_memory_barrier_count = p_buffer_memory_barriers.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn image_memory_barriers(
        mut self,
        p_image_memory_barriers: impl AsSlice<'a, ImageMemoryBarrier2<'a>>,
    ) -> Self {
        self.p_image_memory_barriers = p_image_memory_barriers.as_slice().as_ptr().cast();
        self.image_memory_barrier_count = p_image_memory_barriers.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DependencyInfoKHR<'a> = DependencyInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo2.html>"]
#[doc(alias = "VkSubmitInfo2")]
pub struct SubmitInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: SubmitFlags,
    pub(crate) wait_semaphore_info_count: u32,
    pub(crate) p_wait_semaphore_infos: *const SemaphoreSubmitInfo<'a>,
    pub(crate) command_buffer_info_count: u32,
    pub(crate) p_command_buffer_infos: *const CommandBufferSubmitInfo<'a>,
    pub(crate) signal_semaphore_info_count: u32,
    pub(crate) p_signal_semaphore_infos: *const SemaphoreSubmitInfo<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SubmitInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SubmitInfo2;
}
unsafe impl<'a> Send for SubmitInfo2<'a> {}
unsafe impl<'a> Sync for SubmitInfo2<'a> {}
impl<'a> Default for SubmitInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            wait_semaphore_info_count: Default::default(),
            p_wait_semaphore_infos: ptr::null(),
            command_buffer_info_count: Default::default(),
            p_command_buffer_infos: ptr::null(),
            signal_semaphore_info_count: Default::default(),
            p_signal_semaphore_infos: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubmitInfo2<'a> {
    #[inline]
    pub fn flags(mut self, value: SubmitFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn wait_semaphore_infos(
        mut self,
        p_wait_semaphore_infos: impl AsSlice<'a, SemaphoreSubmitInfo<'a>>,
    ) -> Self {
        self.p_wait_semaphore_infos = p_wait_semaphore_infos.as_slice().as_ptr().cast();
        self.wait_semaphore_info_count = p_wait_semaphore_infos.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn command_buffer_infos(
        mut self,
        p_command_buffer_infos: impl AsSlice<'a, CommandBufferSubmitInfo<'a>>,
    ) -> Self {
        self.p_command_buffer_infos = p_command_buffer_infos.as_slice().as_ptr().cast();
        self.command_buffer_info_count = p_command_buffer_infos.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn signal_semaphore_infos(
        mut self,
        p_signal_semaphore_infos: impl AsSlice<'a, SemaphoreSubmitInfo<'a>>,
    ) -> Self {
        self.p_signal_semaphore_infos = p_signal_semaphore_infos.as_slice().as_ptr().cast();
        self.signal_semaphore_info_count = p_signal_semaphore_infos.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SubmitInfo2KHR<'a> = SubmitInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSubmitInfo.html>"]
#[doc(alias = "VkSemaphoreSubmitInfo")]
pub struct SemaphoreSubmitInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub semaphore: Option<Semaphore>,
    pub value: u64,
    pub stage_mask: u32,
    pub device_index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SemaphoreSubmitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SemaphoreSubmitInfo;
}
unsafe impl<'a> Send for SemaphoreSubmitInfo<'a> {}
unsafe impl<'a> Sync for SemaphoreSubmitInfo<'a> {}
impl<'a> Default for SemaphoreSubmitInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            semaphore: Default::default(),
            value: Default::default(),
            stage_mask: Default::default(),
            device_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SemaphoreSubmitInfo<'a> {
    #[inline]
    pub fn semaphore(mut self, value: &'a Semaphore) -> Self {
        self.semaphore = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn value(mut self, value: u64) -> Self {
        self.value = value;
        self
    }
    #[inline]
    pub fn stage_mask(mut self, value: u32) -> Self {
        self.stage_mask = value;
        self
    }
    #[inline]
    pub fn device_index(mut self, value: u32) -> Self {
        self.device_index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SemaphoreSubmitInfoKHR<'a> = SemaphoreSubmitInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferSubmitInfo.html>"]
#[doc(alias = "VkCommandBufferSubmitInfo")]
pub struct CommandBufferSubmitInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub command_buffer: Option<CommandBuffer>,
    pub device_mask: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CommandBufferSubmitInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CommandBufferSubmitInfo;
}
unsafe impl<'a> Send for CommandBufferSubmitInfo<'a> {}
unsafe impl<'a> Sync for CommandBufferSubmitInfo<'a> {}
impl<'a> Default for CommandBufferSubmitInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            command_buffer: Default::default(),
            device_mask: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CommandBufferSubmitInfo<'a> {
    #[inline]
    pub fn command_buffer(mut self, value: &'a CommandBuffer) -> Self {
        self.command_buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn device_mask(mut self, value: u32) -> Self {
        self.device_mask = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type CommandBufferSubmitInfoKHR<'a> = CommandBufferSubmitInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSynchronization2Features.html>"]
#[doc(alias = "VkPhysicalDeviceSynchronization2Features")]
pub struct PhysicalDeviceSynchronization2Features<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub synchronization2: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSynchronization2Features<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceSynchronization2Features;
}
unsafe impl<'a> Send for PhysicalDeviceSynchronization2Features<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSynchronization2Features<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceSynchronization2Features<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceSynchronization2Features<'a>
{
}
impl<'a> Default for PhysicalDeviceSynchronization2Features<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            synchronization2: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSynchronization2Features<'a> {
    #[inline]
    pub fn synchronization2(mut self, value: impl Into<Bool32>) -> Self {
        self.synchronization2 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceSynchronization2FeaturesKHR<'a> = PhysicalDeviceSynchronization2Features<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures")]
pub struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_zero_initialize_workgroup_memory: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_zero_initialize_workgroup_memory: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'a> {
    #[inline]
    pub fn shader_zero_initialize_workgroup_memory(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_zero_initialize_workgroup_memory = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR<'a> =
    PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageRobustnessFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceImageRobustnessFeatures")]
pub struct PhysicalDeviceImageRobustnessFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub robust_image_access: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageRobustnessFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceImageRobustnessFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceImageRobustnessFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageRobustnessFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceImageRobustnessFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceImageRobustnessFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceImageRobustnessFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            robust_image_access: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageRobustnessFeatures<'a> {
    #[inline]
    pub fn robust_image_access(mut self, value: impl Into<Bool32>) -> Self {
        self.robust_image_access = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceImageRobustnessFeaturesEXT<'a> = PhysicalDeviceImageRobustnessFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferInfo2.html>"]
#[doc(alias = "VkCopyBufferInfo2")]
pub struct CopyBufferInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_buffer: Option<Buffer>,
    pub dst_buffer: Option<Buffer>,
    pub(crate) region_count: u32,
    pub(crate) p_regions: *const BufferCopy2<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyBufferInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyBufferInfo2;
}
unsafe impl<'a> Send for CopyBufferInfo2<'a> {}
unsafe impl<'a> Sync for CopyBufferInfo2<'a> {}
impl<'a> Default for CopyBufferInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_buffer: Default::default(),
            dst_buffer: Default::default(),
            region_count: Default::default(),
            p_regions: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyBufferInfo2<'a> {
    #[inline]
    pub fn src_buffer(mut self, value: &'a Buffer) -> Self {
        self.src_buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst_buffer(mut self, value: &'a Buffer) -> Self {
        self.dst_buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn regions(mut self, p_regions: impl AsSlice<'a, BufferCopy2<'a>>) -> Self {
        self.p_regions = p_regions.as_slice().as_ptr().cast();
        self.region_count = p_regions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type CopyBufferInfo2KHR<'a> = CopyBufferInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageInfo2.html>"]
#[doc(alias = "VkCopyImageInfo2")]
pub struct CopyImageInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub(crate) region_count: u32,
    pub(crate) p_regions: *const ImageCopy2<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyImageInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyImageInfo2;
}
unsafe impl<'a> Send for CopyImageInfo2<'a> {}
unsafe impl<'a> Sync for CopyImageInfo2<'a> {}
impl<'a> Default for CopyImageInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_image: Default::default(),
            src_image_layout: ImageLayout::Undefined,
            dst_image: Default::default(),
            dst_image_layout: ImageLayout::Undefined,
            region_count: Default::default(),
            p_regions: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyImageInfo2<'a> {
    #[inline]
    pub fn src_image(mut self, value: &'a Image) -> Self {
        self.src_image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, value: ImageLayout) -> Self {
        self.src_image_layout = value;
        self
    }
    #[inline]
    pub fn dst_image(mut self, value: &'a Image) -> Self {
        self.dst_image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, value: ImageLayout) -> Self {
        self.dst_image_layout = value;
        self
    }
    #[inline]
    pub fn regions(mut self, p_regions: impl AsSlice<'a, ImageCopy2<'a>>) -> Self {
        self.p_regions = p_regions.as_slice().as_ptr().cast();
        self.region_count = p_regions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type CopyImageInfo2KHR<'a> = CopyImageInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferToImageInfo2.html>"]
#[doc(alias = "VkCopyBufferToImageInfo2")]
pub struct CopyBufferToImageInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_buffer: Option<Buffer>,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub(crate) region_count: u32,
    pub(crate) p_regions: *const BufferImageCopy2<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyBufferToImageInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyBufferToImageInfo2;
}
unsafe impl<'a> Send for CopyBufferToImageInfo2<'a> {}
unsafe impl<'a> Sync for CopyBufferToImageInfo2<'a> {}
impl<'a> Default for CopyBufferToImageInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_buffer: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: ImageLayout::Undefined,
            region_count: Default::default(),
            p_regions: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyBufferToImageInfo2<'a> {
    #[inline]
    pub fn src_buffer(mut self, value: &'a Buffer) -> Self {
        self.src_buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst_image(mut self, value: &'a Image) -> Self {
        self.dst_image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, value: ImageLayout) -> Self {
        self.dst_image_layout = value;
        self
    }
    #[inline]
    pub fn regions(mut self, p_regions: impl AsSlice<'a, BufferImageCopy2<'a>>) -> Self {
        self.p_regions = p_regions.as_slice().as_ptr().cast();
        self.region_count = p_regions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type CopyBufferToImageInfo2KHR<'a> = CopyBufferToImageInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageToBufferInfo2.html>"]
#[doc(alias = "VkCopyImageToBufferInfo2")]
pub struct CopyImageToBufferInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_buffer: Option<Buffer>,
    pub(crate) region_count: u32,
    pub(crate) p_regions: *const BufferImageCopy2<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyImageToBufferInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyImageToBufferInfo2;
}
unsafe impl<'a> Send for CopyImageToBufferInfo2<'a> {}
unsafe impl<'a> Sync for CopyImageToBufferInfo2<'a> {}
impl<'a> Default for CopyImageToBufferInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_image: Default::default(),
            src_image_layout: ImageLayout::Undefined,
            dst_buffer: Default::default(),
            region_count: Default::default(),
            p_regions: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyImageToBufferInfo2<'a> {
    #[inline]
    pub fn src_image(mut self, value: &'a Image) -> Self {
        self.src_image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, value: ImageLayout) -> Self {
        self.src_image_layout = value;
        self
    }
    #[inline]
    pub fn dst_buffer(mut self, value: &'a Buffer) -> Self {
        self.dst_buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn regions(mut self, p_regions: impl AsSlice<'a, BufferImageCopy2<'a>>) -> Self {
        self.p_regions = p_regions.as_slice().as_ptr().cast();
        self.region_count = p_regions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type CopyImageToBufferInfo2KHR<'a> = CopyImageToBufferInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlitImageInfo2.html>"]
#[doc(alias = "VkBlitImageInfo2")]
pub struct BlitImageInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub(crate) region_count: u32,
    pub(crate) p_regions: *const ImageBlit2<'a>,
    pub filter: Filter,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BlitImageInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BlitImageInfo2;
}
unsafe impl<'a> Send for BlitImageInfo2<'a> {}
unsafe impl<'a> Sync for BlitImageInfo2<'a> {}
impl<'a> Default for BlitImageInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_image: Default::default(),
            src_image_layout: ImageLayout::Undefined,
            dst_image: Default::default(),
            dst_image_layout: ImageLayout::Undefined,
            region_count: Default::default(),
            p_regions: ptr::null(),
            filter: Filter::Nearest,
            phantom: PhantomData,
        }
    }
}
impl<'a> BlitImageInfo2<'a> {
    #[inline]
    pub fn src_image(mut self, value: &'a Image) -> Self {
        self.src_image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, value: ImageLayout) -> Self {
        self.src_image_layout = value;
        self
    }
    #[inline]
    pub fn dst_image(mut self, value: &'a Image) -> Self {
        self.dst_image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, value: ImageLayout) -> Self {
        self.dst_image_layout = value;
        self
    }
    #[inline]
    pub fn filter(mut self, value: Filter) -> Self {
        self.filter = value;
        self
    }
    #[inline]
    pub fn regions(mut self, p_regions: impl AsSlice<'a, ImageBlit2<'a>>) -> Self {
        self.p_regions = p_regions.as_slice().as_ptr().cast();
        self.region_count = p_regions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type BlitImageInfo2KHR<'a> = BlitImageInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResolveImageInfo2.html>"]
#[doc(alias = "VkResolveImageInfo2")]
pub struct ResolveImageInfo2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub(crate) region_count: u32,
    pub(crate) p_regions: *const ImageResolve2<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ResolveImageInfo2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ResolveImageInfo2;
}
unsafe impl<'a> Send for ResolveImageInfo2<'a> {}
unsafe impl<'a> Sync for ResolveImageInfo2<'a> {}
impl<'a> Default for ResolveImageInfo2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_image: Default::default(),
            src_image_layout: ImageLayout::Undefined,
            dst_image: Default::default(),
            dst_image_layout: ImageLayout::Undefined,
            region_count: Default::default(),
            p_regions: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ResolveImageInfo2<'a> {
    #[inline]
    pub fn src_image(mut self, value: &'a Image) -> Self {
        self.src_image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, value: ImageLayout) -> Self {
        self.src_image_layout = value;
        self
    }
    #[inline]
    pub fn dst_image(mut self, value: &'a Image) -> Self {
        self.dst_image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, value: ImageLayout) -> Self {
        self.dst_image_layout = value;
        self
    }
    #[inline]
    pub fn regions(mut self, p_regions: impl AsSlice<'a, ImageResolve2<'a>>) -> Self {
        self.p_regions = p_regions.as_slice().as_ptr().cast();
        self.region_count = p_regions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ResolveImageInfo2KHR<'a> = ResolveImageInfo2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy2.html>"]
#[doc(alias = "VkBufferCopy2")]
pub struct BufferCopy2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_offset: DeviceSize,
    pub dst_offset: DeviceSize,
    pub size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferCopy2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferCopy2;
}
unsafe impl<'a> Send for BufferCopy2<'a> {}
unsafe impl<'a> Sync for BufferCopy2<'a> {}
impl<'a> Default for BufferCopy2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_offset: Default::default(),
            dst_offset: Default::default(),
            size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferCopy2<'a> {
    #[inline]
    pub fn src_offset(mut self, value: DeviceSize) -> Self {
        self.src_offset = value;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, value: DeviceSize) -> Self {
        self.dst_offset = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type BufferCopy2KHR<'a> = BufferCopy2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy2.html>"]
#[doc(alias = "VkImageCopy2")]
pub struct ImageCopy2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageCopy2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageCopy2;
}
unsafe impl<'a> Send for ImageCopy2<'a> {}
unsafe impl<'a> Sync for ImageCopy2<'a> {}
impl<'a> Default for ImageCopy2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_subresource: Default::default(),
            src_offset: Default::default(),
            dst_subresource: Default::default(),
            dst_offset: Default::default(),
            extent: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageCopy2<'a> {
    #[inline]
    pub fn src_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.src_subresource = value;
        self
    }
    #[inline]
    pub fn src_offset(mut self, value: Offset3D) -> Self {
        self.src_offset = value;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.dst_subresource = value;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, value: Offset3D) -> Self {
        self.dst_offset = value;
        self
    }
    #[inline]
    pub fn extent(mut self, value: Extent3D) -> Self {
        self.extent = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ImageCopy2KHR<'a> = ImageCopy2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit2.html>"]
#[doc(alias = "VkImageBlit2")]
pub struct ImageBlit2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_subresource: ImageSubresourceLayers,
    pub src_offsets: [Offset3D; 2u16 as _],
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offsets: [Offset3D; 2u16 as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageBlit2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageBlit2;
}
unsafe impl<'a> Send for ImageBlit2<'a> {}
unsafe impl<'a> Sync for ImageBlit2<'a> {}
impl<'a> Default for ImageBlit2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_subresource: Default::default(),
            src_offsets: array::from_fn(|_| Default::default()),
            dst_subresource: Default::default(),
            dst_offsets: array::from_fn(|_| Default::default()),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageBlit2<'a> {
    #[inline]
    pub fn src_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.src_subresource = value;
        self
    }
    #[inline]
    pub fn src_offsets(mut self, value: [Offset3D; 2u16 as _]) -> Self {
        self.src_offsets = value;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.dst_subresource = value;
        self
    }
    #[inline]
    pub fn dst_offsets(mut self, value: [Offset3D; 2u16 as _]) -> Self {
        self.dst_offsets = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ImageBlit2KHR<'a> = ImageBlit2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy2.html>"]
#[doc(alias = "VkBufferImageCopy2")]
pub struct BufferImageCopy2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub buffer_offset: DeviceSize,
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    pub image_offset: Offset3D,
    pub image_extent: Extent3D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferImageCopy2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferImageCopy2;
}
unsafe impl<'a> Send for BufferImageCopy2<'a> {}
unsafe impl<'a> Sync for BufferImageCopy2<'a> {}
impl<'a> Default for BufferImageCopy2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            buffer_offset: Default::default(),
            buffer_row_length: Default::default(),
            buffer_image_height: Default::default(),
            image_subresource: Default::default(),
            image_offset: Default::default(),
            image_extent: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferImageCopy2<'a> {
    #[inline]
    pub fn buffer_offset(mut self, value: DeviceSize) -> Self {
        self.buffer_offset = value;
        self
    }
    #[inline]
    pub fn buffer_row_length(mut self, value: u32) -> Self {
        self.buffer_row_length = value;
        self
    }
    #[inline]
    pub fn buffer_image_height(mut self, value: u32) -> Self {
        self.buffer_image_height = value;
        self
    }
    #[inline]
    pub fn image_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.image_subresource = value;
        self
    }
    #[inline]
    pub fn image_offset(mut self, value: Offset3D) -> Self {
        self.image_offset = value;
        self
    }
    #[inline]
    pub fn image_extent(mut self, value: Extent3D) -> Self {
        self.image_extent = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type BufferImageCopy2KHR<'a> = BufferImageCopy2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve2.html>"]
#[doc(alias = "VkImageResolve2")]
pub struct ImageResolve2<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageResolve2<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageResolve2;
}
unsafe impl<'a> Send for ImageResolve2<'a> {}
unsafe impl<'a> Sync for ImageResolve2<'a> {}
impl<'a> Default for ImageResolve2<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_subresource: Default::default(),
            src_offset: Default::default(),
            dst_subresource: Default::default(),
            dst_offset: Default::default(),
            extent: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageResolve2<'a> {
    #[inline]
    pub fn src_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.src_subresource = value;
        self
    }
    #[inline]
    pub fn src_offset(mut self, value: Offset3D) -> Self {
        self.src_offset = value;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.dst_subresource = value;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, value: Offset3D) -> Self {
        self.dst_offset = value;
        self
    }
    #[inline]
    pub fn extent(mut self, value: Extent3D) -> Self {
        self.extent = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ImageResolve2KHR<'a> = ImageResolve2<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceSubgroupSizeControlFeatures")]
pub struct PhysicalDeviceSubgroupSizeControlFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub subgroup_size_control: Bool32,
    pub compute_full_subgroups: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSubgroupSizeControlFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceSubgroupSizeControlFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceSubgroupSizeControlFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSubgroupSizeControlFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceSubgroupSizeControlFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceSubgroupSizeControlFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceSubgroupSizeControlFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            subgroup_size_control: Default::default(),
            compute_full_subgroups: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSubgroupSizeControlFeatures<'a> {
    #[inline]
    pub fn subgroup_size_control(mut self, value: impl Into<Bool32>) -> Self {
        self.subgroup_size_control = value.into();
        self
    }
    #[inline]
    pub fn compute_full_subgroups(mut self, value: impl Into<Bool32>) -> Self {
        self.compute_full_subgroups = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceSubgroupSizeControlFeaturesEXT<'a> =
    PhysicalDeviceSubgroupSizeControlFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlProperties.html>"]
#[doc(alias = "VkPhysicalDeviceSubgroupSizeControlProperties")]
pub struct PhysicalDeviceSubgroupSizeControlProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub min_subgroup_size: u32,
    pub max_subgroup_size: u32,
    pub max_compute_workgroup_subgroups: u32,
    pub required_subgroup_size_stages: ShaderStageFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSubgroupSizeControlProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceSubgroupSizeControlProperties;
}
unsafe impl<'a> Send for PhysicalDeviceSubgroupSizeControlProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSubgroupSizeControlProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceSubgroupSizeControlProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceSubgroupSizeControlProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            min_subgroup_size: Default::default(),
            max_subgroup_size: Default::default(),
            max_compute_workgroup_subgroups: Default::default(),
            required_subgroup_size_stages: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSubgroupSizeControlProperties<'a> {
    #[inline]
    pub fn min_subgroup_size(mut self, value: u32) -> Self {
        self.min_subgroup_size = value;
        self
    }
    #[inline]
    pub fn max_subgroup_size(mut self, value: u32) -> Self {
        self.max_subgroup_size = value;
        self
    }
    #[inline]
    pub fn max_compute_workgroup_subgroups(mut self, value: u32) -> Self {
        self.max_compute_workgroup_subgroups = value;
        self
    }
    #[inline]
    pub fn required_subgroup_size_stages(mut self, value: ShaderStageFlags) -> Self {
        self.required_subgroup_size_stages = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceSubgroupSizeControlPropertiesEXT<'a> =
    PhysicalDeviceSubgroupSizeControlProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.html>"]
#[doc(alias = "VkPipelineShaderStageRequiredSubgroupSizeCreateInfo")]
pub struct PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub required_subgroup_size: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineShaderStageRequiredSubgroupSizeCreateInfo;
}
unsafe impl<'a> Send for PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineShaderStageCreateInfo<'b>>
    for PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<ShaderCreateInfoEXT<'b>>
    for PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a>
{
}
impl<'a> Default for PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            required_subgroup_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a> {
    #[inline]
    pub fn required_subgroup_size(mut self, value: u32) -> Self {
        self.required_subgroup_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT<'a> =
    PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a>;
pub type ShaderRequiredSubgroupSizeCreateInfoEXT<'a> =
    PipelineShaderStageRequiredSubgroupSizeCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceInlineUniformBlockFeatures")]
pub struct PhysicalDeviceInlineUniformBlockFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub inline_uniform_block: Bool32,
    pub descriptor_binding_inline_uniform_block_update_after_bind: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceInlineUniformBlockFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceInlineUniformBlockFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceInlineUniformBlockFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceInlineUniformBlockFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceInlineUniformBlockFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceInlineUniformBlockFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceInlineUniformBlockFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            inline_uniform_block: Default::default(),
            descriptor_binding_inline_uniform_block_update_after_bind: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceInlineUniformBlockFeatures<'a> {
    #[inline]
    pub fn inline_uniform_block(mut self, value: impl Into<Bool32>) -> Self {
        self.inline_uniform_block = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_inline_uniform_block_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceInlineUniformBlockFeaturesEXT<'a> =
    PhysicalDeviceInlineUniformBlockFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockProperties.html>"]
#[doc(alias = "VkPhysicalDeviceInlineUniformBlockProperties")]
pub struct PhysicalDeviceInlineUniformBlockProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_inline_uniform_block_size: u32,
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    pub max_descriptor_set_inline_uniform_blocks: u32,
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceInlineUniformBlockProperties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceInlineUniformBlockProperties;
}
unsafe impl<'a> Send for PhysicalDeviceInlineUniformBlockProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceInlineUniformBlockProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceInlineUniformBlockProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceInlineUniformBlockProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_inline_uniform_block_size: Default::default(),
            max_per_stage_descriptor_inline_uniform_blocks: Default::default(),
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: Default::default(),
            max_descriptor_set_inline_uniform_blocks: Default::default(),
            max_descriptor_set_update_after_bind_inline_uniform_blocks: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceInlineUniformBlockProperties<'a> {
    #[inline]
    pub fn max_inline_uniform_block_size(mut self, value: u32) -> Self {
        self.max_inline_uniform_block_size = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_inline_uniform_blocks(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_inline_uniform_blocks = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(
        mut self,
        value: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_inline_uniform_blocks = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_inline_uniform_blocks(mut self, value: u32) -> Self {
        self.max_descriptor_set_inline_uniform_blocks = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks(
        mut self,
        value: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_inline_uniform_blocks = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceInlineUniformBlockPropertiesEXT<'a> =
    PhysicalDeviceInlineUniformBlockProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetInlineUniformBlock.html>"]
#[doc(alias = "VkWriteDescriptorSetInlineUniformBlock")]
pub struct WriteDescriptorSetInlineUniformBlock<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) data_size: u32,
    pub(crate) p_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for WriteDescriptorSetInlineUniformBlock<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::WriteDescriptorSetInlineUniformBlock;
}
unsafe impl<'a> Send for WriteDescriptorSetInlineUniformBlock<'a> {}
unsafe impl<'a> Sync for WriteDescriptorSetInlineUniformBlock<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<WriteDescriptorSet<'b>>
    for WriteDescriptorSetInlineUniformBlock<'a>
{
}
impl<'a> Default for WriteDescriptorSetInlineUniformBlock<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            data_size: Default::default(),
            p_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> WriteDescriptorSetInlineUniformBlock<'a> {
    #[inline]
    pub fn data(mut self, p_data: impl AsSlice<'a, u8>) -> Self {
        self.p_data = p_data.as_slice().as_ptr().cast();
        self.data_size = p_data.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type WriteDescriptorSetInlineUniformBlockEXT<'a> = WriteDescriptorSetInlineUniformBlock<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolInlineUniformBlockCreateInfo.html>"]
#[doc(alias = "VkDescriptorPoolInlineUniformBlockCreateInfo")]
pub struct DescriptorPoolInlineUniformBlockCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_inline_uniform_block_bindings: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorPoolInlineUniformBlockCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DescriptorPoolInlineUniformBlockCreateInfo;
}
unsafe impl<'a> Send for DescriptorPoolInlineUniformBlockCreateInfo<'a> {}
unsafe impl<'a> Sync for DescriptorPoolInlineUniformBlockCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DescriptorPoolCreateInfo<'b>>
    for DescriptorPoolInlineUniformBlockCreateInfo<'a>
{
}
impl<'a> Default for DescriptorPoolInlineUniformBlockCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_inline_uniform_block_bindings: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorPoolInlineUniformBlockCreateInfo<'a> {
    #[inline]
    pub fn max_inline_uniform_block_bindings(mut self, value: u32) -> Self {
        self.max_inline_uniform_block_bindings = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DescriptorPoolInlineUniformBlockCreateInfoEXT<'a> =
    DescriptorPoolInlineUniformBlockCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTextureCompressionASTCHDRFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceTextureCompressionASTCHDRFeatures")]
pub struct PhysicalDeviceTextureCompressionASTCHDRFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub texture_compression_astc_hdr: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceTextureCompressionASTCHDRFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceTextureCompressionAstcHdrFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceTextureCompressionASTCHDRFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceTextureCompressionASTCHDRFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceTextureCompressionASTCHDRFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceTextureCompressionASTCHDRFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceTextureCompressionASTCHDRFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            texture_compression_astc_hdr: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceTextureCompressionASTCHDRFeatures<'a> {
    #[inline]
    pub fn texture_compression_astc_hdr(mut self, value: impl Into<Bool32>) -> Self {
        self.texture_compression_astc_hdr = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT<'a> =
    PhysicalDeviceTextureCompressionASTCHDRFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingInfo.html>"]
#[doc(alias = "VkRenderingInfo")]
pub struct RenderingInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: RenderingFlags,
    pub render_area: Rect2D,
    pub layer_count: u32,
    pub view_mask: u32,
    pub(crate) color_attachment_count: u32,
    pub(crate) p_color_attachments: *const RenderingAttachmentInfo<'a>,
    pub p_depth_attachment: *const RenderingAttachmentInfo<'a>,
    pub p_stencil_attachment: *const RenderingAttachmentInfo<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderingInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderingInfo;
}
unsafe impl<'a> Send for RenderingInfo<'a> {}
unsafe impl<'a> Sync for RenderingInfo<'a> {}
impl<'a> Default for RenderingInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            render_area: Default::default(),
            layer_count: Default::default(),
            view_mask: Default::default(),
            color_attachment_count: Default::default(),
            p_color_attachments: ptr::null(),
            p_depth_attachment: ptr::null(),
            p_stencil_attachment: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderingInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: RenderingFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn render_area(mut self, value: Rect2D) -> Self {
        self.render_area = value;
        self
    }
    #[inline]
    pub fn layer_count(mut self, value: u32) -> Self {
        self.layer_count = value;
        self
    }
    #[inline]
    pub fn view_mask(mut self, value: u32) -> Self {
        self.view_mask = value;
        self
    }
    #[inline]
    pub fn depth_attachment(mut self, value: Option<&'a RenderingAttachmentInfo<'a>>) -> Self {
        self.p_depth_attachment = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn stencil_attachment(mut self, value: Option<&'a RenderingAttachmentInfo<'a>>) -> Self {
        self.p_stencil_attachment = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn color_attachments(
        mut self,
        p_color_attachments: impl AsSlice<'a, RenderingAttachmentInfo<'a>>,
    ) -> Self {
        self.p_color_attachments = p_color_attachments.as_slice().as_ptr().cast();
        self.color_attachment_count = p_color_attachments.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type RenderingInfoKHR<'a> = RenderingInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingAttachmentInfo.html>"]
#[doc(alias = "VkRenderingAttachmentInfo")]
pub struct RenderingAttachmentInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_view: Option<ImageView>,
    pub image_layout: ImageLayout,
    pub resolve_mode: ResolveModeFlags,
    pub resolve_image_view: Option<ImageView>,
    pub resolve_image_layout: ImageLayout,
    pub load_op: AttachmentLoadOp,
    pub store_op: AttachmentStoreOp,
    pub clear_value: ClearValue,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderingAttachmentInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderingAttachmentInfo;
}
unsafe impl<'a> Send for RenderingAttachmentInfo<'a> {}
unsafe impl<'a> Sync for RenderingAttachmentInfo<'a> {}
impl<'a> Default for RenderingAttachmentInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_view: Default::default(),
            image_layout: ImageLayout::Undefined,
            resolve_mode: Default::default(),
            resolve_image_view: Default::default(),
            resolve_image_layout: ImageLayout::Undefined,
            load_op: AttachmentLoadOp::Load,
            store_op: AttachmentStoreOp::Store,
            clear_value: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderingAttachmentInfo<'a> {
    #[inline]
    pub fn image_view(mut self, value: Option<&'a ImageView>) -> Self {
        self.image_view = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn image_layout(mut self, value: ImageLayout) -> Self {
        self.image_layout = value;
        self
    }
    #[inline]
    pub fn resolve_mode(mut self, value: ResolveModeFlags) -> Self {
        self.resolve_mode = value;
        self
    }
    #[inline]
    pub fn resolve_image_view(mut self, value: Option<&'a ImageView>) -> Self {
        self.resolve_image_view = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn resolve_image_layout(mut self, value: ImageLayout) -> Self {
        self.resolve_image_layout = value;
        self
    }
    #[inline]
    pub fn load_op(mut self, value: AttachmentLoadOp) -> Self {
        self.load_op = value;
        self
    }
    #[inline]
    pub fn store_op(mut self, value: AttachmentStoreOp) -> Self {
        self.store_op = value;
        self
    }
    #[inline]
    pub fn clear_value(mut self, value: ClearValue) -> Self {
        self.clear_value = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type RenderingAttachmentInfoKHR<'a> = RenderingAttachmentInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRenderingCreateInfo.html>"]
#[doc(alias = "VkPipelineRenderingCreateInfo")]
pub struct PipelineRenderingCreateInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub view_mask: u32,
    pub(crate) color_attachment_count: u32,
    pub(crate) p_color_attachment_formats: *const Format,
    pub depth_attachment_format: Format,
    pub stencil_attachment_format: Format,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineRenderingCreateInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineRenderingCreateInfo;
}
unsafe impl<'a> Send for PipelineRenderingCreateInfo<'a> {}
unsafe impl<'a> Sync for PipelineRenderingCreateInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for PipelineRenderingCreateInfo<'a>
{
}
impl<'a> Default for PipelineRenderingCreateInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            view_mask: Default::default(),
            color_attachment_count: Default::default(),
            p_color_attachment_formats: ptr::null(),
            depth_attachment_format: Format::Undefined,
            stencil_attachment_format: Format::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineRenderingCreateInfo<'a> {
    #[inline]
    pub fn view_mask(mut self, value: u32) -> Self {
        self.view_mask = value;
        self
    }
    #[inline]
    pub fn depth_attachment_format(mut self, value: Format) -> Self {
        self.depth_attachment_format = value;
        self
    }
    #[inline]
    pub fn stencil_attachment_format(mut self, value: Format) -> Self {
        self.stencil_attachment_format = value;
        self
    }
    #[inline]
    pub fn color_attachment_formats(
        mut self,
        p_color_attachment_formats: impl AsSlice<'a, Format>,
    ) -> Self {
        self.p_color_attachment_formats = p_color_attachment_formats.as_slice().as_ptr().cast();
        self.color_attachment_count = p_color_attachment_formats.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PipelineRenderingCreateInfoKHR<'a> = PipelineRenderingCreateInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceDynamicRenderingFeatures")]
pub struct PhysicalDeviceDynamicRenderingFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub dynamic_rendering: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDynamicRenderingFeatures<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceDynamicRenderingFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceDynamicRenderingFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDynamicRenderingFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDynamicRenderingFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDynamicRenderingFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceDynamicRenderingFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            dynamic_rendering: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDynamicRenderingFeatures<'a> {
    #[inline]
    pub fn dynamic_rendering(mut self, value: impl Into<Bool32>) -> Self {
        self.dynamic_rendering = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceDynamicRenderingFeaturesKHR<'a> = PhysicalDeviceDynamicRenderingFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceRenderingInfo.html>"]
#[doc(alias = "VkCommandBufferInheritanceRenderingInfo")]
pub struct CommandBufferInheritanceRenderingInfo<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: RenderingFlags,
    pub view_mask: u32,
    pub(crate) color_attachment_count: u32,
    pub(crate) p_color_attachment_formats: *const Format,
    pub depth_attachment_format: Format,
    pub stencil_attachment_format: Format,
    pub rasterization_samples: SampleCountFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CommandBufferInheritanceRenderingInfo<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CommandBufferInheritanceRenderingInfo;
}
unsafe impl<'a> Send for CommandBufferInheritanceRenderingInfo<'a> {}
unsafe impl<'a> Sync for CommandBufferInheritanceRenderingInfo<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<CommandBufferInheritanceInfo<'b>>
    for CommandBufferInheritanceRenderingInfo<'a>
{
}
impl<'a> Default for CommandBufferInheritanceRenderingInfo<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            view_mask: Default::default(),
            color_attachment_count: Default::default(),
            p_color_attachment_formats: ptr::null(),
            depth_attachment_format: Format::Undefined,
            stencil_attachment_format: Format::Undefined,
            rasterization_samples: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CommandBufferInheritanceRenderingInfo<'a> {
    #[inline]
    pub fn flags(mut self, value: RenderingFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn view_mask(mut self, value: u32) -> Self {
        self.view_mask = value;
        self
    }
    #[inline]
    pub fn depth_attachment_format(mut self, value: Format) -> Self {
        self.depth_attachment_format = value;
        self
    }
    #[inline]
    pub fn stencil_attachment_format(mut self, value: Format) -> Self {
        self.stencil_attachment_format = value;
        self
    }
    #[inline]
    pub fn rasterization_samples(mut self, value: SampleCountFlags) -> Self {
        self.rasterization_samples = value;
        self
    }
    #[inline]
    pub fn color_attachment_formats(
        mut self,
        p_color_attachment_formats: impl AsSlice<'a, Format>,
    ) -> Self {
        self.p_color_attachment_formats = p_color_attachment_formats.as_slice().as_ptr().cast();
        self.color_attachment_count = p_color_attachment_formats.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type CommandBufferInheritanceRenderingInfoKHR<'a> = CommandBufferInheritanceRenderingInfo<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductFeatures.html>"]
#[doc(alias = "VkPhysicalDeviceShaderIntegerDotProductFeatures")]
pub struct PhysicalDeviceShaderIntegerDotProductFeatures<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_integer_dot_product: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderIntegerDotProductFeatures<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderIntegerDotProductFeatures;
}
unsafe impl<'a> Send for PhysicalDeviceShaderIntegerDotProductFeatures<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderIntegerDotProductFeatures<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderIntegerDotProductFeatures<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderIntegerDotProductFeatures<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderIntegerDotProductFeatures<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_integer_dot_product: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderIntegerDotProductFeatures<'a> {
    #[inline]
    pub fn shader_integer_dot_product(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_integer_dot_product = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceShaderIntegerDotProductFeaturesKHR<'a> =
    PhysicalDeviceShaderIntegerDotProductFeatures<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductProperties.html>"]
#[doc(alias = "VkPhysicalDeviceShaderIntegerDotProductProperties")]
pub struct PhysicalDeviceShaderIntegerDotProductProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub integer_dot_product8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product8_bit_signed_accelerated: Bool32,
    pub integer_dot_product8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product16_bit_signed_accelerated: Bool32,
    pub integer_dot_product16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product32_bit_signed_accelerated: Bool32,
    pub integer_dot_product32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product64_bit_signed_accelerated: Bool32,
    pub integer_dot_product64_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated:
        Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderIntegerDotProductProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderIntegerDotProductProperties;
}
unsafe impl<'a> Send for PhysicalDeviceShaderIntegerDotProductProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderIntegerDotProductProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceShaderIntegerDotProductProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderIntegerDotProductProperties<'a> {
    fn default() -> Self {
        Self { s_type : Self :: STRUCTURE_TYPE , p_next : Cell :: new (ptr :: null ()) , integer_dot_product8_bit_unsigned_accelerated : Default :: default () , integer_dot_product8_bit_signed_accelerated : Default :: default () , integer_dot_product8_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product4x8_bit_packed_unsigned_accelerated : Default :: default () , integer_dot_product4x8_bit_packed_signed_accelerated : Default :: default () , integer_dot_product4x8_bit_packed_mixed_signedness_accelerated : Default :: default () , integer_dot_product16_bit_unsigned_accelerated : Default :: default () , integer_dot_product16_bit_signed_accelerated : Default :: default () , integer_dot_product16_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product32_bit_unsigned_accelerated : Default :: default () , integer_dot_product32_bit_signed_accelerated : Default :: default () , integer_dot_product32_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product64_bit_unsigned_accelerated : Default :: default () , integer_dot_product64_bit_signed_accelerated : Default :: default () , integer_dot_product64_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated : Default :: default () , integer_dot_product_accumulating_saturating8_bit_signed_accelerated : Default :: default () , integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated : Default :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated : Default :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated : Default :: default () , integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated : Default :: default () , integer_dot_product_accumulating_saturating16_bit_signed_accelerated : Default :: default () , integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated : Default :: default () , integer_dot_product_accumulating_saturating32_bit_signed_accelerated : Default :: default () , integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated : Default :: default () , integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated : Default :: default () , integer_dot_product_accumulating_saturating64_bit_signed_accelerated : Default :: default () , integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated : Default :: default () , phantom : PhantomData , }
    }
}
impl<'a> PhysicalDeviceShaderIntegerDotProductProperties<'a> {
    #[inline]
    pub fn integer_dot_product8_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product8_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_signed_accelerated(mut self, value: impl Into<Bool32>) -> Self {
        self.integer_dot_product8_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product8_bit_mixed_signedness_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product4x8_bit_packed_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product4x8_bit_packed_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product4x8_bit_packed_mixed_signedness_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product16_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product16_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product16_bit_mixed_signedness_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product32_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product32_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product32_bit_mixed_signedness_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product64_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product64_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product64_bit_mixed_signedness_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated =
            value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated =
            value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated =
            value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self . integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated = value . into () ;
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated =
            value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated =
            value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_signed_accelerated = value.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated =
            value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceShaderIntegerDotProductPropertiesKHR<'a> =
    PhysicalDeviceShaderIntegerDotProductProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentProperties.html>"]
#[doc(alias = "VkPhysicalDeviceTexelBufferAlignmentProperties")]
pub struct PhysicalDeviceTexelBufferAlignmentProperties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub storage_texel_buffer_offset_single_texel_alignment: Bool32,
    pub uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub uniform_texel_buffer_offset_single_texel_alignment: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceTexelBufferAlignmentProperties<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceTexelBufferAlignmentProperties;
}
unsafe impl<'a> Send for PhysicalDeviceTexelBufferAlignmentProperties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceTexelBufferAlignmentProperties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceTexelBufferAlignmentProperties<'a>
{
}
impl<'a> Default for PhysicalDeviceTexelBufferAlignmentProperties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            storage_texel_buffer_offset_alignment_bytes: Default::default(),
            storage_texel_buffer_offset_single_texel_alignment: Default::default(),
            uniform_texel_buffer_offset_alignment_bytes: Default::default(),
            uniform_texel_buffer_offset_single_texel_alignment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceTexelBufferAlignmentProperties<'a> {
    #[inline]
    pub fn storage_texel_buffer_offset_alignment_bytes(mut self, value: DeviceSize) -> Self {
        self.storage_texel_buffer_offset_alignment_bytes = value;
        self
    }
    #[inline]
    pub fn storage_texel_buffer_offset_single_texel_alignment(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.storage_texel_buffer_offset_single_texel_alignment = value.into();
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_offset_alignment_bytes(mut self, value: DeviceSize) -> Self {
        self.uniform_texel_buffer_offset_alignment_bytes = value;
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_offset_single_texel_alignment(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.uniform_texel_buffer_offset_single_texel_alignment = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceTexelBufferAlignmentPropertiesEXT<'a> =
    PhysicalDeviceTexelBufferAlignmentProperties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties3.html>"]
#[doc(alias = "VkFormatProperties3")]
pub struct FormatProperties3<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub linear_tiling_features: u32,
    pub optimal_tiling_features: u32,
    pub buffer_features: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for FormatProperties3<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FormatProperties3;
}
unsafe impl<'a> Send for FormatProperties3<'a> {}
unsafe impl<'a> Sync for FormatProperties3<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<FormatProperties2<'b>> for FormatProperties3<'a> {}
impl<'a> Default for FormatProperties3<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            linear_tiling_features: Default::default(),
            optimal_tiling_features: Default::default(),
            buffer_features: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> FormatProperties3<'a> {
    #[inline]
    pub fn linear_tiling_features(mut self, value: u32) -> Self {
        self.linear_tiling_features = value;
        self
    }
    #[inline]
    pub fn optimal_tiling_features(mut self, value: u32) -> Self {
        self.optimal_tiling_features = value;
        self
    }
    #[inline]
    pub fn buffer_features(mut self, value: u32) -> Self {
        self.buffer_features = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type FormatProperties3KHR<'a> = FormatProperties3<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Features.html>"]
#[doc(alias = "VkPhysicalDeviceMaintenance4Features")]
pub struct PhysicalDeviceMaintenance4Features<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub maintenance4: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMaintenance4Features<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMaintenance4Features;
}
unsafe impl<'a> Send for PhysicalDeviceMaintenance4Features<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMaintenance4Features<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMaintenance4Features<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMaintenance4Features<'a>
{
}
impl<'a> Default for PhysicalDeviceMaintenance4Features<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            maintenance4: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMaintenance4Features<'a> {
    #[inline]
    pub fn maintenance4(mut self, value: impl Into<Bool32>) -> Self {
        self.maintenance4 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceMaintenance4FeaturesKHR<'a> = PhysicalDeviceMaintenance4Features<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Properties.html>"]
#[doc(alias = "VkPhysicalDeviceMaintenance4Properties")]
pub struct PhysicalDeviceMaintenance4Properties<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_buffer_size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMaintenance4Properties<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMaintenance4Properties;
}
unsafe impl<'a> Send for PhysicalDeviceMaintenance4Properties<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMaintenance4Properties<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceMaintenance4Properties<'a>
{
}
impl<'a> Default for PhysicalDeviceMaintenance4Properties<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_buffer_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMaintenance4Properties<'a> {
    #[inline]
    pub fn max_buffer_size(mut self, value: DeviceSize) -> Self {
        self.max_buffer_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceMaintenance4PropertiesKHR<'a> = PhysicalDeviceMaintenance4Properties<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceBufferMemoryRequirements.html>"]
#[doc(alias = "VkDeviceBufferMemoryRequirements")]
pub struct DeviceBufferMemoryRequirements<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_create_info: *const BufferCreateInfo<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceBufferMemoryRequirements<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceBufferMemoryRequirements;
}
unsafe impl<'a> Send for DeviceBufferMemoryRequirements<'a> {}
unsafe impl<'a> Sync for DeviceBufferMemoryRequirements<'a> {}
impl<'a> Default for DeviceBufferMemoryRequirements<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_create_info: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceBufferMemoryRequirements<'a> {
    #[inline]
    pub fn create_info(mut self, value: &'a BufferCreateInfo<'a>) -> Self {
        self.p_create_info = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DeviceBufferMemoryRequirementsKHR<'a> = DeviceBufferMemoryRequirements<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceImageMemoryRequirements.html>"]
#[doc(alias = "VkDeviceImageMemoryRequirements")]
pub struct DeviceImageMemoryRequirements<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_create_info: *const ImageCreateInfo<'a>,
    pub plane_aspect: ImageAspectFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceImageMemoryRequirements<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceImageMemoryRequirements;
}
unsafe impl<'a> Send for DeviceImageMemoryRequirements<'a> {}
unsafe impl<'a> Sync for DeviceImageMemoryRequirements<'a> {}
impl<'a> Default for DeviceImageMemoryRequirements<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_create_info: ptr::null(),
            plane_aspect: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceImageMemoryRequirements<'a> {
    #[inline]
    pub fn create_info(mut self, value: &'a ImageCreateInfo<'a>) -> Self {
        self.p_create_info = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn plane_aspect(mut self, value: ImageAspectFlags) -> Self {
        self.plane_aspect = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DeviceImageMemoryRequirementsKHR<'a> = DeviceImageMemoryRequirements<'a>;
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesKHR.html>"]
#[doc(alias = "VkSurfaceCapabilitiesKHR")]
pub struct SurfaceCapabilitiesKHR {
    pub min_image_count: u32,
    pub max_image_count: u32,
    pub current_extent: Extent2D,
    pub min_image_extent: Extent2D,
    pub max_image_extent: Extent2D,
    pub max_image_array_layers: u32,
    pub supported_transforms: SurfaceTransformFlagsKHR,
    pub current_transform: SurfaceTransformFlagsKHR,
    pub supported_composite_alpha: CompositeAlphaFlagsKHR,
    pub supported_usage_flags: ImageUsageFlags,
}
unsafe impl Send for SurfaceCapabilitiesKHR {}
unsafe impl Sync for SurfaceCapabilitiesKHR {}
impl Default for SurfaceCapabilitiesKHR {
    fn default() -> Self {
        Self {
            min_image_count: Default::default(),
            max_image_count: Default::default(),
            current_extent: Default::default(),
            min_image_extent: Default::default(),
            max_image_extent: Default::default(),
            max_image_array_layers: Default::default(),
            supported_transforms: Default::default(),
            current_transform: Default::default(),
            supported_composite_alpha: Default::default(),
            supported_usage_flags: Default::default(),
        }
    }
}
impl SurfaceCapabilitiesKHR {
    #[inline]
    pub fn min_image_count(mut self, value: u32) -> Self {
        self.min_image_count = value;
        self
    }
    #[inline]
    pub fn max_image_count(mut self, value: u32) -> Self {
        self.max_image_count = value;
        self
    }
    #[inline]
    pub fn current_extent(mut self, value: Extent2D) -> Self {
        self.current_extent = value;
        self
    }
    #[inline]
    pub fn min_image_extent(mut self, value: Extent2D) -> Self {
        self.min_image_extent = value;
        self
    }
    #[inline]
    pub fn max_image_extent(mut self, value: Extent2D) -> Self {
        self.max_image_extent = value;
        self
    }
    #[inline]
    pub fn max_image_array_layers(mut self, value: u32) -> Self {
        self.max_image_array_layers = value;
        self
    }
    #[inline]
    pub fn supported_transforms(mut self, value: SurfaceTransformFlagsKHR) -> Self {
        self.supported_transforms = value;
        self
    }
    #[inline]
    pub fn current_transform(mut self, value: SurfaceTransformFlagsKHR) -> Self {
        self.current_transform = value;
        self
    }
    #[inline]
    pub fn supported_composite_alpha(mut self, value: CompositeAlphaFlagsKHR) -> Self {
        self.supported_composite_alpha = value;
        self
    }
    #[inline]
    pub fn supported_usage_flags(mut self, value: ImageUsageFlags) -> Self {
        self.supported_usage_flags = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormatKHR.html>"]
#[doc(alias = "VkSurfaceFormatKHR")]
pub struct SurfaceFormatKHR {
    pub format: Format,
    pub color_space: ColorSpaceKHR,
}
unsafe impl Send for SurfaceFormatKHR {}
unsafe impl Sync for SurfaceFormatKHR {}
impl Default for SurfaceFormatKHR {
    fn default() -> Self {
        Self {
            format: Format::Undefined,
            color_space: ColorSpaceKHR::SrgbNonlinear,
        }
    }
}
impl SurfaceFormatKHR {
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn color_space(mut self, value: ColorSpaceKHR) -> Self {
        self.color_space = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html>"]
#[doc(alias = "VkSwapchainCreateInfoKHR")]
pub struct SwapchainCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: SwapchainCreateFlagsKHR,
    pub surface: Option<SurfaceKHR>,
    pub min_image_count: u32,
    pub image_format: Format,
    pub image_color_space: ColorSpaceKHR,
    pub image_extent: Extent2D,
    pub image_array_layers: u32,
    pub image_usage: ImageUsageFlags,
    pub image_sharing_mode: SharingMode,
    pub(crate) queue_family_index_count: u32,
    pub(crate) p_queue_family_indices: *const u32,
    pub pre_transform: SurfaceTransformFlagsKHR,
    pub composite_alpha: CompositeAlphaFlagsKHR,
    pub present_mode: PresentModeKHR,
    pub clipped: Bool32,
    pub old_swapchain: Option<SwapchainKHR>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SwapchainCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SwapchainCreateInfoKHR;
}
unsafe impl<'a> Send for SwapchainCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for SwapchainCreateInfoKHR<'a> {}
impl<'a> Default for SwapchainCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            surface: Default::default(),
            min_image_count: Default::default(),
            image_format: Format::Undefined,
            image_color_space: ColorSpaceKHR::SrgbNonlinear,
            image_extent: Default::default(),
            image_array_layers: Default::default(),
            image_usage: Default::default(),
            image_sharing_mode: SharingMode::Exclusive,
            queue_family_index_count: Default::default(),
            p_queue_family_indices: ptr::null(),
            pre_transform: Default::default(),
            composite_alpha: Default::default(),
            present_mode: PresentModeKHR::Immediate,
            clipped: Default::default(),
            old_swapchain: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SwapchainCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: SwapchainCreateFlagsKHR) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn surface(mut self, value: &'a SurfaceKHR) -> Self {
        self.surface = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn min_image_count(mut self, value: u32) -> Self {
        self.min_image_count = value;
        self
    }
    #[inline]
    pub fn image_format(mut self, value: Format) -> Self {
        self.image_format = value;
        self
    }
    #[inline]
    pub fn image_color_space(mut self, value: ColorSpaceKHR) -> Self {
        self.image_color_space = value;
        self
    }
    #[inline]
    pub fn image_extent(mut self, value: Extent2D) -> Self {
        self.image_extent = value;
        self
    }
    #[inline]
    pub fn image_array_layers(mut self, value: u32) -> Self {
        self.image_array_layers = value;
        self
    }
    #[inline]
    pub fn image_usage(mut self, value: ImageUsageFlags) -> Self {
        self.image_usage = value;
        self
    }
    #[inline]
    pub fn image_sharing_mode(mut self, value: SharingMode) -> Self {
        self.image_sharing_mode = value;
        self
    }
    #[inline]
    pub fn pre_transform(mut self, value: SurfaceTransformFlagsKHR) -> Self {
        self.pre_transform = value;
        self
    }
    #[inline]
    pub fn composite_alpha(mut self, value: CompositeAlphaFlagsKHR) -> Self {
        self.composite_alpha = value;
        self
    }
    #[inline]
    pub fn present_mode(mut self, value: PresentModeKHR) -> Self {
        self.present_mode = value;
        self
    }
    #[inline]
    pub fn clipped(mut self, value: impl Into<Bool32>) -> Self {
        self.clipped = value.into();
        self
    }
    #[inline]
    pub fn old_swapchain(mut self, value: Option<&'a SwapchainKHR>) -> Self {
        self.old_swapchain = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn queue_family_indices(mut self, p_queue_family_indices: impl AsSlice<'a, u32>) -> Self {
        self.p_queue_family_indices = p_queue_family_indices.as_slice().as_ptr().cast();
        self.queue_family_index_count = p_queue_family_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentInfoKHR.html>"]
#[doc(alias = "VkPresentInfoKHR")]
pub struct PresentInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) wait_semaphore_count: u32,
    pub(crate) p_wait_semaphores: *const Semaphore,
    pub(crate) swapchain_count: u32,
    pub(crate) p_swapchains: *const SwapchainKHR,
    pub(crate) p_image_indices: *const u32,
    pub(crate) p_results: *const Status,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PresentInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PresentInfoKHR;
}
unsafe impl<'a> Send for PresentInfoKHR<'a> {}
unsafe impl<'a> Sync for PresentInfoKHR<'a> {}
impl<'a> Default for PresentInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            wait_semaphore_count: Default::default(),
            p_wait_semaphores: ptr::null(),
            swapchain_count: Default::default(),
            p_swapchains: ptr::null(),
            p_image_indices: ptr::null(),
            p_results: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PresentInfoKHR<'a> {
    #[inline]
    pub fn wait_semaphores<V0: Alias<raw::Semaphore> + 'a>(
        mut self,
        p_wait_semaphores: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_wait_semaphores = p_wait_semaphores.as_slice().as_ptr().cast();
        self.wait_semaphore_count = p_wait_semaphores.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn swapchain<V0: Alias<raw::SwapchainKHR> + 'a>(
        mut self,
        p_swapchains: impl AsSlice<'a, V0>,
        p_image_indices: impl AsSlice<'a, u32>,
        p_results: Option<impl AsSlice<'a, Status>>,
    ) -> Self {
        self.p_swapchains = p_swapchains.as_slice().as_ptr().cast();
        self.p_image_indices = p_image_indices.as_slice().as_ptr().cast();
        self.p_results = p_results
            .map(|p| p.as_slice().as_ptr().cast())
            .unwrap_or(ptr::null());
        self.swapchain_count = p_swapchains.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSwapchainCreateInfoKHR.html>"]
#[doc(alias = "VkImageSwapchainCreateInfoKHR")]
pub struct ImageSwapchainCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub swapchain: Option<SwapchainKHR>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageSwapchainCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageSwapchainCreateInfoKHR;
}
unsafe impl<'a> Send for ImageSwapchainCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for ImageSwapchainCreateInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>> for ImageSwapchainCreateInfoKHR<'a> {}
impl<'a> Default for ImageSwapchainCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            swapchain: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageSwapchainCreateInfoKHR<'a> {
    #[inline]
    pub fn swapchain(mut self, value: Option<&'a SwapchainKHR>) -> Self {
        self.swapchain = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemorySwapchainInfoKHR.html>"]
#[doc(alias = "VkBindImageMemorySwapchainInfoKHR")]
pub struct BindImageMemorySwapchainInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub swapchain: Option<SwapchainKHR>,
    pub image_index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BindImageMemorySwapchainInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BindImageMemorySwapchainInfoKHR;
}
unsafe impl<'a> Send for BindImageMemorySwapchainInfoKHR<'a> {}
unsafe impl<'a> Sync for BindImageMemorySwapchainInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BindImageMemoryInfo<'b>>
    for BindImageMemorySwapchainInfoKHR<'a>
{
}
impl<'a> Default for BindImageMemorySwapchainInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            swapchain: Default::default(),
            image_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BindImageMemorySwapchainInfoKHR<'a> {
    #[inline]
    pub fn swapchain(mut self, value: &'a SwapchainKHR) -> Self {
        self.swapchain = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn image_index(mut self, value: u32) -> Self {
        self.image_index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAcquireNextImageInfoKHR.html>"]
#[doc(alias = "VkAcquireNextImageInfoKHR")]
pub struct AcquireNextImageInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub swapchain: Option<SwapchainKHR>,
    pub timeout: u64,
    pub semaphore: Option<Semaphore>,
    pub fence: Option<Fence>,
    pub device_mask: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AcquireNextImageInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AcquireNextImageInfoKHR;
}
unsafe impl<'a> Send for AcquireNextImageInfoKHR<'a> {}
unsafe impl<'a> Sync for AcquireNextImageInfoKHR<'a> {}
impl<'a> Default for AcquireNextImageInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            swapchain: Default::default(),
            timeout: Default::default(),
            semaphore: Default::default(),
            fence: Default::default(),
            device_mask: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AcquireNextImageInfoKHR<'a> {
    #[inline]
    pub fn swapchain(mut self, value: &'a SwapchainKHR) -> Self {
        self.swapchain = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn timeout(mut self, value: u64) -> Self {
        self.timeout = value;
        self
    }
    #[inline]
    pub fn semaphore(mut self, value: Option<&'a Semaphore>) -> Self {
        self.semaphore = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn fence(mut self, value: Option<&'a Fence>) -> Self {
        self.fence = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn device_mask(mut self, value: u32) -> Self {
        self.device_mask = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentCapabilitiesKHR.html>"]
#[doc(alias = "VkDeviceGroupPresentCapabilitiesKHR")]
pub struct DeviceGroupPresentCapabilitiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub present_mask: [u32; MAX_DEVICE_GROUP_SIZE as _],
    pub modes: DeviceGroupPresentModeFlagsKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceGroupPresentCapabilitiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceGroupPresentCapabilitiesKHR;
}
unsafe impl<'a> Send for DeviceGroupPresentCapabilitiesKHR<'a> {}
unsafe impl<'a> Sync for DeviceGroupPresentCapabilitiesKHR<'a> {}
impl<'a> Default for DeviceGroupPresentCapabilitiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_mask: array::from_fn(|_| Default::default()),
            modes: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceGroupPresentCapabilitiesKHR<'a> {
    #[inline]
    pub fn present_mask(mut self, value: [u32; MAX_DEVICE_GROUP_SIZE as _]) -> Self {
        self.present_mask = value;
        self
    }
    #[inline]
    pub fn modes(mut self, value: DeviceGroupPresentModeFlagsKHR) -> Self {
        self.modes = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentInfoKHR.html>"]
#[doc(alias = "VkDeviceGroupPresentInfoKHR")]
pub struct DeviceGroupPresentInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) swapchain_count: u32,
    pub(crate) p_device_masks: *const u32,
    pub mode: DeviceGroupPresentModeFlagsKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceGroupPresentInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceGroupPresentInfoKHR;
}
unsafe impl<'a> Send for DeviceGroupPresentInfoKHR<'a> {}
unsafe impl<'a> Sync for DeviceGroupPresentInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PresentInfoKHR<'b>> for DeviceGroupPresentInfoKHR<'a> {}
impl<'a> Default for DeviceGroupPresentInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            swapchain_count: Default::default(),
            p_device_masks: ptr::null(),
            mode: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceGroupPresentInfoKHR<'a> {
    #[inline]
    pub fn mode(mut self, value: DeviceGroupPresentModeFlagsKHR) -> Self {
        self.mode = value;
        self
    }
    #[inline]
    pub fn device_masks(mut self, p_device_masks: impl AsSlice<'a, u32>) -> Self {
        self.p_device_masks = p_device_masks.as_slice().as_ptr().cast();
        self.swapchain_count = p_device_masks.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupSwapchainCreateInfoKHR.html>"]
#[doc(alias = "VkDeviceGroupSwapchainCreateInfoKHR")]
pub struct DeviceGroupSwapchainCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub modes: DeviceGroupPresentModeFlagsKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceGroupSwapchainCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceGroupSwapchainCreateInfoKHR;
}
unsafe impl<'a> Send for DeviceGroupSwapchainCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for DeviceGroupSwapchainCreateInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SwapchainCreateInfoKHR<'b>>
    for DeviceGroupSwapchainCreateInfoKHR<'a>
{
}
impl<'a> Default for DeviceGroupSwapchainCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            modes: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceGroupSwapchainCreateInfoKHR<'a> {
    #[inline]
    pub fn modes(mut self, value: DeviceGroupPresentModeFlagsKHR) -> Self {
        self.modes = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeCreateInfoKHR.html>"]
#[doc(alias = "VkDisplayModeCreateInfoKHR")]
pub struct DisplayModeCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub parameters: DisplayModeParametersKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DisplayModeCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DisplayModeCreateInfoKHR;
}
unsafe impl<'a> Send for DisplayModeCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for DisplayModeCreateInfoKHR<'a> {}
impl<'a> Default for DisplayModeCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            parameters: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayModeCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn parameters(mut self, value: DisplayModeParametersKHR) -> Self {
        self.parameters = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeParametersKHR.html>"]
#[doc(alias = "VkDisplayModeParametersKHR")]
pub struct DisplayModeParametersKHR {
    pub visible_region: Extent2D,
    pub refresh_rate: u32,
}
unsafe impl Send for DisplayModeParametersKHR {}
unsafe impl Sync for DisplayModeParametersKHR {}
impl Default for DisplayModeParametersKHR {
    fn default() -> Self {
        Self {
            visible_region: Default::default(),
            refresh_rate: Default::default(),
        }
    }
}
impl DisplayModeParametersKHR {
    #[inline]
    pub fn visible_region(mut self, value: Extent2D) -> Self {
        self.visible_region = value;
        self
    }
    #[inline]
    pub fn refresh_rate(mut self, value: u32) -> Self {
        self.refresh_rate = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModePropertiesKHR.html>"]
#[doc(alias = "VkDisplayModePropertiesKHR")]
pub struct DisplayModePropertiesKHR<'a> {
    pub display_mode: Option<DisplayModeKHR>,
    pub parameters: DisplayModeParametersKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for DisplayModePropertiesKHR<'a> {}
unsafe impl<'a> Sync for DisplayModePropertiesKHR<'a> {}
impl<'a> Default for DisplayModePropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            display_mode: Default::default(),
            parameters: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayModePropertiesKHR<'a> {
    #[inline]
    pub fn display_mode(mut self, value: &'a DisplayModeKHR) -> Self {
        self.display_mode = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn parameters(mut self, value: DisplayModeParametersKHR) -> Self {
        self.parameters = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneCapabilitiesKHR.html>"]
#[doc(alias = "VkDisplayPlaneCapabilitiesKHR")]
pub struct DisplayPlaneCapabilitiesKHR {
    pub supported_alpha: DisplayPlaneAlphaFlagsKHR,
    pub min_src_position: Offset2D,
    pub max_src_position: Offset2D,
    pub min_src_extent: Extent2D,
    pub max_src_extent: Extent2D,
    pub min_dst_position: Offset2D,
    pub max_dst_position: Offset2D,
    pub min_dst_extent: Extent2D,
    pub max_dst_extent: Extent2D,
}
unsafe impl Send for DisplayPlaneCapabilitiesKHR {}
unsafe impl Sync for DisplayPlaneCapabilitiesKHR {}
impl Default for DisplayPlaneCapabilitiesKHR {
    fn default() -> Self {
        Self {
            supported_alpha: Default::default(),
            min_src_position: Default::default(),
            max_src_position: Default::default(),
            min_src_extent: Default::default(),
            max_src_extent: Default::default(),
            min_dst_position: Default::default(),
            max_dst_position: Default::default(),
            min_dst_extent: Default::default(),
            max_dst_extent: Default::default(),
        }
    }
}
impl DisplayPlaneCapabilitiesKHR {
    #[inline]
    pub fn supported_alpha(mut self, value: DisplayPlaneAlphaFlagsKHR) -> Self {
        self.supported_alpha = value;
        self
    }
    #[inline]
    pub fn min_src_position(mut self, value: Offset2D) -> Self {
        self.min_src_position = value;
        self
    }
    #[inline]
    pub fn max_src_position(mut self, value: Offset2D) -> Self {
        self.max_src_position = value;
        self
    }
    #[inline]
    pub fn min_src_extent(mut self, value: Extent2D) -> Self {
        self.min_src_extent = value;
        self
    }
    #[inline]
    pub fn max_src_extent(mut self, value: Extent2D) -> Self {
        self.max_src_extent = value;
        self
    }
    #[inline]
    pub fn min_dst_position(mut self, value: Offset2D) -> Self {
        self.min_dst_position = value;
        self
    }
    #[inline]
    pub fn max_dst_position(mut self, value: Offset2D) -> Self {
        self.max_dst_position = value;
        self
    }
    #[inline]
    pub fn min_dst_extent(mut self, value: Extent2D) -> Self {
        self.min_dst_extent = value;
        self
    }
    #[inline]
    pub fn max_dst_extent(mut self, value: Extent2D) -> Self {
        self.max_dst_extent = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlanePropertiesKHR.html>"]
#[doc(alias = "VkDisplayPlanePropertiesKHR")]
pub struct DisplayPlanePropertiesKHR<'a> {
    pub current_display: Option<DisplayKHR>,
    pub current_stack_index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for DisplayPlanePropertiesKHR<'a> {}
unsafe impl<'a> Sync for DisplayPlanePropertiesKHR<'a> {}
impl<'a> Default for DisplayPlanePropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            current_display: Default::default(),
            current_stack_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayPlanePropertiesKHR<'a> {
    #[inline]
    pub fn current_display(mut self, value: &'a DisplayKHR) -> Self {
        self.current_display = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn current_stack_index(mut self, value: u32) -> Self {
        self.current_stack_index = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPropertiesKHR.html>"]
#[doc(alias = "VkDisplayPropertiesKHR")]
pub struct DisplayPropertiesKHR<'a> {
    pub display: Option<DisplayKHR>,
    pub display_name: *const c_char,
    pub physical_dimensions: Extent2D,
    pub physical_resolution: Extent2D,
    pub supported_transforms: SurfaceTransformFlagsKHR,
    pub plane_reorder_possible: Bool32,
    pub persistent_content: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for DisplayPropertiesKHR<'a> {}
unsafe impl<'a> Sync for DisplayPropertiesKHR<'a> {}
impl<'a> Default for DisplayPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            display: Default::default(),
            display_name: ptr::null(),
            physical_dimensions: Default::default(),
            physical_resolution: Default::default(),
            supported_transforms: Default::default(),
            plane_reorder_possible: Default::default(),
            persistent_content: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayPropertiesKHR<'a> {
    #[inline]
    pub fn display(mut self, value: &'a DisplayKHR) -> Self {
        self.display = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn display_name(mut self, value: &'a CStr) -> Self {
        self.display_name = value.as_ptr();
        self
    }
    #[inline]
    pub fn physical_dimensions(mut self, value: Extent2D) -> Self {
        self.physical_dimensions = value;
        self
    }
    #[inline]
    pub fn physical_resolution(mut self, value: Extent2D) -> Self {
        self.physical_resolution = value;
        self
    }
    #[inline]
    pub fn supported_transforms(mut self, value: SurfaceTransformFlagsKHR) -> Self {
        self.supported_transforms = value;
        self
    }
    #[inline]
    pub fn plane_reorder_possible(mut self, value: impl Into<Bool32>) -> Self {
        self.plane_reorder_possible = value.into();
        self
    }
    #[inline]
    pub fn persistent_content(mut self, value: impl Into<Bool32>) -> Self {
        self.persistent_content = value.into();
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplaySurfaceCreateInfoKHR.html>"]
#[doc(alias = "VkDisplaySurfaceCreateInfoKHR")]
pub struct DisplaySurfaceCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub display_mode: Option<DisplayModeKHR>,
    pub plane_index: u32,
    pub plane_stack_index: u32,
    pub transform: SurfaceTransformFlagsKHR,
    pub global_alpha: f32,
    pub alpha_mode: DisplayPlaneAlphaFlagsKHR,
    pub image_extent: Extent2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DisplaySurfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DisplaySurfaceCreateInfoKHR;
}
unsafe impl<'a> Send for DisplaySurfaceCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for DisplaySurfaceCreateInfoKHR<'a> {}
impl<'a> Default for DisplaySurfaceCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            display_mode: Default::default(),
            plane_index: Default::default(),
            plane_stack_index: Default::default(),
            transform: Default::default(),
            global_alpha: Default::default(),
            alpha_mode: Default::default(),
            image_extent: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplaySurfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn display_mode(mut self, value: &'a DisplayModeKHR) -> Self {
        self.display_mode = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn plane_index(mut self, value: u32) -> Self {
        self.plane_index = value;
        self
    }
    #[inline]
    pub fn plane_stack_index(mut self, value: u32) -> Self {
        self.plane_stack_index = value;
        self
    }
    #[inline]
    pub fn transform(mut self, value: SurfaceTransformFlagsKHR) -> Self {
        self.transform = value;
        self
    }
    #[inline]
    pub fn global_alpha(mut self, value: f32) -> Self {
        self.global_alpha = value;
        self
    }
    #[inline]
    pub fn alpha_mode(mut self, value: DisplayPlaneAlphaFlagsKHR) -> Self {
        self.alpha_mode = value;
        self
    }
    #[inline]
    pub fn image_extent(mut self, value: Extent2D) -> Self {
        self.image_extent = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPresentInfoKHR.html>"]
#[doc(alias = "VkDisplayPresentInfoKHR")]
pub struct DisplayPresentInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_rect: Rect2D,
    pub dst_rect: Rect2D,
    pub persistent: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DisplayPresentInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DisplayPresentInfoKHR;
}
unsafe impl<'a> Send for DisplayPresentInfoKHR<'a> {}
unsafe impl<'a> Sync for DisplayPresentInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PresentInfoKHR<'b>> for DisplayPresentInfoKHR<'a> {}
impl<'a> Default for DisplayPresentInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_rect: Default::default(),
            dst_rect: Default::default(),
            persistent: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayPresentInfoKHR<'a> {
    #[inline]
    pub fn src_rect(mut self, value: Rect2D) -> Self {
        self.src_rect = value;
        self
    }
    #[inline]
    pub fn dst_rect(mut self, value: Rect2D) -> Self {
        self.dst_rect = value;
        self
    }
    #[inline]
    pub fn persistent(mut self, value: impl Into<Bool32>) -> Self {
        self.persistent = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXlibSurfaceCreateInfoKHR.html>"]
#[doc(alias = "VkXlibSurfaceCreateInfoKHR")]
pub struct XlibSurfaceCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub dpy: *const VoidPtr,
    pub window: c_ulong,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for XlibSurfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::XlibSurfaceCreateInfoKHR;
}
unsafe impl<'a> Send for XlibSurfaceCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for XlibSurfaceCreateInfoKHR<'a> {}
impl<'a> Default for XlibSurfaceCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            dpy: ptr::null(),
            window: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> XlibSurfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn dpy(mut self, value: &'a VoidPtr) -> Self {
        self.dpy = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn window(mut self, value: c_ulong) -> Self {
        self.window = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXcbSurfaceCreateInfoKHR.html>"]
#[doc(alias = "VkXcbSurfaceCreateInfoKHR")]
pub struct XcbSurfaceCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub connection: *const VoidPtr,
    pub window: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for XcbSurfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::XcbSurfaceCreateInfoKHR;
}
unsafe impl<'a> Send for XcbSurfaceCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for XcbSurfaceCreateInfoKHR<'a> {}
impl<'a> Default for XcbSurfaceCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            connection: ptr::null(),
            window: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> XcbSurfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn connection(mut self, value: &'a VoidPtr) -> Self {
        self.connection = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn window(mut self, value: u32) -> Self {
        self.window = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWaylandSurfaceCreateInfoKHR.html>"]
#[doc(alias = "VkWaylandSurfaceCreateInfoKHR")]
pub struct WaylandSurfaceCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub display: *const VoidPtr,
    pub surface: *const VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for WaylandSurfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::WaylandSurfaceCreateInfoKHR;
}
unsafe impl<'a> Send for WaylandSurfaceCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for WaylandSurfaceCreateInfoKHR<'a> {}
impl<'a> Default for WaylandSurfaceCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            display: ptr::null(),
            surface: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> WaylandSurfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn display(mut self, value: &'a VoidPtr) -> Self {
        self.display = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn surface(mut self, value: &'a VoidPtr) -> Self {
        self.surface = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/ANativeWindow.html>"]
pub type ANativeWindow = c_void;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidSurfaceCreateInfoKHR.html>"]
#[doc(alias = "VkAndroidSurfaceCreateInfoKHR")]
pub struct AndroidSurfaceCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub window: *const ANativeWindow,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AndroidSurfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AndroidSurfaceCreateInfoKHR;
}
unsafe impl<'a> Send for AndroidSurfaceCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for AndroidSurfaceCreateInfoKHR<'a> {}
impl<'a> Default for AndroidSurfaceCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            window: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AndroidSurfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn window(mut self, value: &'a ANativeWindow) -> Self {
        self.window = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWin32SurfaceCreateInfoKHR.html>"]
#[doc(alias = "VkWin32SurfaceCreateInfoKHR")]
pub struct Win32SurfaceCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub hinstance: VoidPtr,
    pub hwnd: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for Win32SurfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::Win32SurfaceCreateInfoKHR;
}
unsafe impl<'a> Send for Win32SurfaceCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for Win32SurfaceCreateInfoKHR<'a> {}
impl<'a> Default for Win32SurfaceCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            hinstance: ptr::null(),
            hwnd: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> Win32SurfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn hinstance(mut self, value: VoidPtr) -> Self {
        self.hinstance = value;
        self
    }
    #[inline]
    pub fn hwnd(mut self, value: VoidPtr) -> Self {
        self.hwnd = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugReportCallbackCreateInfoEXT.html>"]
#[doc(alias = "VkDebugReportCallbackCreateInfoEXT")]
pub struct DebugReportCallbackCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: DebugReportFlagsEXT,
    pub pfn_callback: FuncPtr,
    pub p_user_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DebugReportCallbackCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DebugReportCallbackCreateInfoEXT;
}
unsafe impl<'a> Send for DebugReportCallbackCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for DebugReportCallbackCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<InstanceCreateInfo<'b>>
    for DebugReportCallbackCreateInfoEXT<'a>
{
}
impl<'a> Default for DebugReportCallbackCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            pfn_callback: ptr::null(),
            p_user_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DebugReportCallbackCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: DebugReportFlagsEXT) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn pfn_callback(mut self, value: FuncPtr) -> Self {
        self.pfn_callback = value;
        self
    }
    #[inline]
    pub fn user_data(mut self, value: VoidPtr) -> Self {
        self.p_user_data = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateRasterizationOrderAMD.html>"]
#[doc(alias = "VkPipelineRasterizationStateRasterizationOrderAMD")]
pub struct PipelineRasterizationStateRasterizationOrderAMD<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub rasterization_order: RasterizationOrderAMD,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineRasterizationStateRasterizationOrderAMD<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineRasterizationStateRasterizationOrderAMD;
}
unsafe impl<'a> Send for PipelineRasterizationStateRasterizationOrderAMD<'a> {}
unsafe impl<'a> Sync for PipelineRasterizationStateRasterizationOrderAMD<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineRasterizationStateCreateInfo<'b>>
    for PipelineRasterizationStateRasterizationOrderAMD<'a>
{
}
impl<'a> Default for PipelineRasterizationStateRasterizationOrderAMD<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            rasterization_order: RasterizationOrderAMD::Strict,
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineRasterizationStateRasterizationOrderAMD<'a> {
    #[inline]
    pub fn rasterization_order(mut self, value: RasterizationOrderAMD) -> Self {
        self.rasterization_order = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugMarkerObjectNameInfoEXT.html>"]
#[doc(alias = "VkDebugMarkerObjectNameInfoEXT")]
pub struct DebugMarkerObjectNameInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub object_type: DebugReportObjectTypeEXT,
    pub object: u64,
    pub p_object_name: *const c_char,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DebugMarkerObjectNameInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DebugMarkerObjectNameInfoEXT;
}
unsafe impl<'a> Send for DebugMarkerObjectNameInfoEXT<'a> {}
unsafe impl<'a> Sync for DebugMarkerObjectNameInfoEXT<'a> {}
impl<'a> Default for DebugMarkerObjectNameInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            object_type: DebugReportObjectTypeEXT::Unknown,
            object: Default::default(),
            p_object_name: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DebugMarkerObjectNameInfoEXT<'a> {
    #[inline]
    pub fn object_type(mut self, value: DebugReportObjectTypeEXT) -> Self {
        self.object_type = value;
        self
    }
    #[inline]
    pub fn object(mut self, value: u64) -> Self {
        self.object = value;
        self
    }
    #[inline]
    pub fn object_name(mut self, value: &'a CStr) -> Self {
        self.p_object_name = value.as_ptr();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugMarkerObjectTagInfoEXT.html>"]
#[doc(alias = "VkDebugMarkerObjectTagInfoEXT")]
pub struct DebugMarkerObjectTagInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub object_type: DebugReportObjectTypeEXT,
    pub object: u64,
    pub tag_name: u64,
    pub(crate) tag_size: usize,
    pub(crate) p_tag: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DebugMarkerObjectTagInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DebugMarkerObjectTagInfoEXT;
}
unsafe impl<'a> Send for DebugMarkerObjectTagInfoEXT<'a> {}
unsafe impl<'a> Sync for DebugMarkerObjectTagInfoEXT<'a> {}
impl<'a> Default for DebugMarkerObjectTagInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            object_type: DebugReportObjectTypeEXT::Unknown,
            object: Default::default(),
            tag_name: Default::default(),
            tag_size: Default::default(),
            p_tag: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DebugMarkerObjectTagInfoEXT<'a> {
    #[inline]
    pub fn object_type(mut self, value: DebugReportObjectTypeEXT) -> Self {
        self.object_type = value;
        self
    }
    #[inline]
    pub fn object(mut self, value: u64) -> Self {
        self.object = value;
        self
    }
    #[inline]
    pub fn tag_name(mut self, value: u64) -> Self {
        self.tag_name = value;
        self
    }
    #[inline]
    pub fn tag(mut self, p_tag: impl AsSlice<'a, u8>) -> Self {
        self.p_tag = p_tag.as_slice().as_ptr().cast();
        self.tag_size = p_tag.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugMarkerMarkerInfoEXT.html>"]
#[doc(alias = "VkDebugMarkerMarkerInfoEXT")]
pub struct DebugMarkerMarkerInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_marker_name: *const c_char,
    pub color: [f32; 4u16 as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DebugMarkerMarkerInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DebugMarkerMarkerInfoEXT;
}
unsafe impl<'a> Send for DebugMarkerMarkerInfoEXT<'a> {}
unsafe impl<'a> Sync for DebugMarkerMarkerInfoEXT<'a> {}
impl<'a> Default for DebugMarkerMarkerInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_marker_name: ptr::null(),
            color: array::from_fn(|_| Default::default()),
            phantom: PhantomData,
        }
    }
}
impl<'a> DebugMarkerMarkerInfoEXT<'a> {
    #[inline]
    pub fn marker_name(mut self, value: &'a CStr) -> Self {
        self.p_marker_name = value.as_ptr();
        self
    }
    #[inline]
    pub fn color(mut self, value: [f32; 4u16 as _]) -> Self {
        self.color = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDedicatedAllocationImageCreateInfoNV.html>"]
#[doc(alias = "VkDedicatedAllocationImageCreateInfoNV")]
pub struct DedicatedAllocationImageCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub dedicated_allocation: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DedicatedAllocationImageCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DedicatedAllocationImageCreateInfoNV;
}
unsafe impl<'a> Send for DedicatedAllocationImageCreateInfoNV<'a> {}
unsafe impl<'a> Sync for DedicatedAllocationImageCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>>
    for DedicatedAllocationImageCreateInfoNV<'a>
{
}
impl<'a> Default for DedicatedAllocationImageCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            dedicated_allocation: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DedicatedAllocationImageCreateInfoNV<'a> {
    #[inline]
    pub fn dedicated_allocation(mut self, value: impl Into<Bool32>) -> Self {
        self.dedicated_allocation = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDedicatedAllocationBufferCreateInfoNV.html>"]
#[doc(alias = "VkDedicatedAllocationBufferCreateInfoNV")]
pub struct DedicatedAllocationBufferCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub dedicated_allocation: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DedicatedAllocationBufferCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DedicatedAllocationBufferCreateInfoNV;
}
unsafe impl<'a> Send for DedicatedAllocationBufferCreateInfoNV<'a> {}
unsafe impl<'a> Sync for DedicatedAllocationBufferCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BufferCreateInfo<'b>>
    for DedicatedAllocationBufferCreateInfoNV<'a>
{
}
impl<'a> Default for DedicatedAllocationBufferCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            dedicated_allocation: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DedicatedAllocationBufferCreateInfoNV<'a> {
    #[inline]
    pub fn dedicated_allocation(mut self, value: impl Into<Bool32>) -> Self {
        self.dedicated_allocation = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDedicatedAllocationMemoryAllocateInfoNV.html>"]
#[doc(alias = "VkDedicatedAllocationMemoryAllocateInfoNV")]
pub struct DedicatedAllocationMemoryAllocateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image: Option<Image>,
    pub buffer: Option<Buffer>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DedicatedAllocationMemoryAllocateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DedicatedAllocationMemoryAllocateInfoNV;
}
unsafe impl<'a> Send for DedicatedAllocationMemoryAllocateInfoNV<'a> {}
unsafe impl<'a> Sync for DedicatedAllocationMemoryAllocateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>>
    for DedicatedAllocationMemoryAllocateInfoNV<'a>
{
}
impl<'a> Default for DedicatedAllocationMemoryAllocateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image: Default::default(),
            buffer: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DedicatedAllocationMemoryAllocateInfoNV<'a> {
    #[inline]
    pub fn image(mut self, value: Option<&'a Image>) -> Self {
        self.image = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn buffer(mut self, value: Option<&'a Buffer>) -> Self {
        self.buffer = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTransformFeedbackFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceTransformFeedbackFeaturesEXT")]
pub struct PhysicalDeviceTransformFeedbackFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub transform_feedback: Bool32,
    pub geometry_streams: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceTransformFeedbackFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceTransformFeedbackFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceTransformFeedbackFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceTransformFeedbackFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceTransformFeedbackFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceTransformFeedbackFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceTransformFeedbackFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            transform_feedback: Default::default(),
            geometry_streams: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceTransformFeedbackFeaturesEXT<'a> {
    #[inline]
    pub fn transform_feedback(mut self, value: impl Into<Bool32>) -> Self {
        self.transform_feedback = value.into();
        self
    }
    #[inline]
    pub fn geometry_streams(mut self, value: impl Into<Bool32>) -> Self {
        self.geometry_streams = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTransformFeedbackPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceTransformFeedbackPropertiesEXT")]
pub struct PhysicalDeviceTransformFeedbackPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_transform_feedback_streams: u32,
    pub max_transform_feedback_buffers: u32,
    pub max_transform_feedback_buffer_size: DeviceSize,
    pub max_transform_feedback_stream_data_size: u32,
    pub max_transform_feedback_buffer_data_size: u32,
    pub max_transform_feedback_buffer_data_stride: u32,
    pub transform_feedback_queries: Bool32,
    pub transform_feedback_streams_lines_triangles: Bool32,
    pub transform_feedback_rasterization_stream_select: Bool32,
    pub transform_feedback_draw: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceTransformFeedbackPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceTransformFeedbackPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceTransformFeedbackPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceTransformFeedbackPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceTransformFeedbackPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceTransformFeedbackPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_transform_feedback_streams: Default::default(),
            max_transform_feedback_buffers: Default::default(),
            max_transform_feedback_buffer_size: Default::default(),
            max_transform_feedback_stream_data_size: Default::default(),
            max_transform_feedback_buffer_data_size: Default::default(),
            max_transform_feedback_buffer_data_stride: Default::default(),
            transform_feedback_queries: Default::default(),
            transform_feedback_streams_lines_triangles: Default::default(),
            transform_feedback_rasterization_stream_select: Default::default(),
            transform_feedback_draw: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceTransformFeedbackPropertiesEXT<'a> {
    #[inline]
    pub fn max_transform_feedback_streams(mut self, value: u32) -> Self {
        self.max_transform_feedback_streams = value;
        self
    }
    #[inline]
    pub fn max_transform_feedback_buffers(mut self, value: u32) -> Self {
        self.max_transform_feedback_buffers = value;
        self
    }
    #[inline]
    pub fn max_transform_feedback_buffer_size(mut self, value: DeviceSize) -> Self {
        self.max_transform_feedback_buffer_size = value;
        self
    }
    #[inline]
    pub fn max_transform_feedback_stream_data_size(mut self, value: u32) -> Self {
        self.max_transform_feedback_stream_data_size = value;
        self
    }
    #[inline]
    pub fn max_transform_feedback_buffer_data_size(mut self, value: u32) -> Self {
        self.max_transform_feedback_buffer_data_size = value;
        self
    }
    #[inline]
    pub fn max_transform_feedback_buffer_data_stride(mut self, value: u32) -> Self {
        self.max_transform_feedback_buffer_data_stride = value;
        self
    }
    #[inline]
    pub fn transform_feedback_queries(mut self, value: impl Into<Bool32>) -> Self {
        self.transform_feedback_queries = value.into();
        self
    }
    #[inline]
    pub fn transform_feedback_streams_lines_triangles(mut self, value: impl Into<Bool32>) -> Self {
        self.transform_feedback_streams_lines_triangles = value.into();
        self
    }
    #[inline]
    pub fn transform_feedback_rasterization_stream_select(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.transform_feedback_rasterization_stream_select = value.into();
        self
    }
    #[inline]
    pub fn transform_feedback_draw(mut self, value: impl Into<Bool32>) -> Self {
        self.transform_feedback_draw = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateStreamCreateInfoEXT.html>"]
#[doc(alias = "VkPipelineRasterizationStateStreamCreateInfoEXT")]
pub struct PipelineRasterizationStateStreamCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub rasterization_stream: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineRasterizationStateStreamCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineRasterizationStateStreamCreateInfoEXT;
}
unsafe impl<'a> Send for PipelineRasterizationStateStreamCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for PipelineRasterizationStateStreamCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineRasterizationStateCreateInfo<'b>>
    for PipelineRasterizationStateStreamCreateInfoEXT<'a>
{
}
impl<'a> Default for PipelineRasterizationStateStreamCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            rasterization_stream: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineRasterizationStateStreamCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn rasterization_stream(mut self, value: u32) -> Self {
        self.rasterization_stream = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuModuleCreateInfoNVX.html>"]
#[doc(alias = "VkCuModuleCreateInfoNVX")]
pub struct CuModuleCreateInfoNVX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) data_size: usize,
    pub(crate) p_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CuModuleCreateInfoNVX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CuModuleCreateInfoNVX;
}
unsafe impl<'a> Send for CuModuleCreateInfoNVX<'a> {}
unsafe impl<'a> Sync for CuModuleCreateInfoNVX<'a> {}
impl<'a> Default for CuModuleCreateInfoNVX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            data_size: Default::default(),
            p_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CuModuleCreateInfoNVX<'a> {
    #[inline]
    pub fn data(mut self, p_data: impl AsSlice<'a, u8>) -> Self {
        self.p_data = p_data.as_slice().as_ptr().cast();
        self.data_size = p_data.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuFunctionCreateInfoNVX.html>"]
#[doc(alias = "VkCuFunctionCreateInfoNVX")]
pub struct CuFunctionCreateInfoNVX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub module: Option<CuModuleNVX>,
    pub p_name: *const c_char,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CuFunctionCreateInfoNVX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CuFunctionCreateInfoNVX;
}
unsafe impl<'a> Send for CuFunctionCreateInfoNVX<'a> {}
unsafe impl<'a> Sync for CuFunctionCreateInfoNVX<'a> {}
impl<'a> Default for CuFunctionCreateInfoNVX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            module: Default::default(),
            p_name: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CuFunctionCreateInfoNVX<'a> {
    #[inline]
    pub fn module(mut self, value: &'a CuModuleNVX) -> Self {
        self.module = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn name(mut self, value: &'a CStr) -> Self {
        self.p_name = value.as_ptr();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuLaunchInfoNVX.html>"]
#[doc(alias = "VkCuLaunchInfoNVX")]
pub struct CuLaunchInfoNVX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub function: Option<CuFunctionNVX>,
    pub grid_dim_x: u32,
    pub grid_dim_y: u32,
    pub grid_dim_z: u32,
    pub block_dim_x: u32,
    pub block_dim_y: u32,
    pub block_dim_z: u32,
    pub shared_mem_bytes: u32,
    pub(crate) param_count: usize,
    pub(crate) p_params: *const *const c_void,
    pub(crate) extra_count: usize,
    pub(crate) p_extras: *const *const c_void,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CuLaunchInfoNVX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CuLaunchInfoNVX;
}
unsafe impl<'a> Send for CuLaunchInfoNVX<'a> {}
unsafe impl<'a> Sync for CuLaunchInfoNVX<'a> {}
impl<'a> Default for CuLaunchInfoNVX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            function: Default::default(),
            grid_dim_x: Default::default(),
            grid_dim_y: Default::default(),
            grid_dim_z: Default::default(),
            block_dim_x: Default::default(),
            block_dim_y: Default::default(),
            block_dim_z: Default::default(),
            shared_mem_bytes: Default::default(),
            param_count: Default::default(),
            p_params: ptr::null(),
            extra_count: Default::default(),
            p_extras: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CuLaunchInfoNVX<'a> {
    #[inline]
    pub fn function(mut self, value: &'a CuFunctionNVX) -> Self {
        self.function = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn grid_dim_x(mut self, value: u32) -> Self {
        self.grid_dim_x = value;
        self
    }
    #[inline]
    pub fn grid_dim_y(mut self, value: u32) -> Self {
        self.grid_dim_y = value;
        self
    }
    #[inline]
    pub fn grid_dim_z(mut self, value: u32) -> Self {
        self.grid_dim_z = value;
        self
    }
    #[inline]
    pub fn block_dim_x(mut self, value: u32) -> Self {
        self.block_dim_x = value;
        self
    }
    #[inline]
    pub fn block_dim_y(mut self, value: u32) -> Self {
        self.block_dim_y = value;
        self
    }
    #[inline]
    pub fn block_dim_z(mut self, value: u32) -> Self {
        self.block_dim_z = value;
        self
    }
    #[inline]
    pub fn shared_mem_bytes(mut self, value: u32) -> Self {
        self.shared_mem_bytes = value;
        self
    }
    #[inline]
    pub fn params(mut self, p_params: impl AsSlice<'a, &'a ()>) -> Self {
        self.p_params = p_params.as_slice().as_ptr().cast();
        self.param_count = p_params.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn extras(mut self, p_extras: impl AsSlice<'a, &'a ()>) -> Self {
        self.p_extras = p_extras.as_slice().as_ptr().cast();
        self.extra_count = p_extras.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewHandleInfoNVX.html>"]
#[doc(alias = "VkImageViewHandleInfoNVX")]
pub struct ImageViewHandleInfoNVX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_view: Option<ImageView>,
    pub descriptor_type: DescriptorType,
    pub sampler: Option<Sampler>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageViewHandleInfoNVX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageViewHandleInfoNVX;
}
unsafe impl<'a> Send for ImageViewHandleInfoNVX<'a> {}
unsafe impl<'a> Sync for ImageViewHandleInfoNVX<'a> {}
impl<'a> Default for ImageViewHandleInfoNVX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_view: Default::default(),
            descriptor_type: DescriptorType::Sampler,
            sampler: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageViewHandleInfoNVX<'a> {
    #[inline]
    pub fn image_view(mut self, value: &'a ImageView) -> Self {
        self.image_view = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn descriptor_type(mut self, value: DescriptorType) -> Self {
        self.descriptor_type = value;
        self
    }
    #[inline]
    pub fn sampler(mut self, value: Option<&'a Sampler>) -> Self {
        self.sampler = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewAddressPropertiesNVX.html>"]
#[doc(alias = "VkImageViewAddressPropertiesNVX")]
pub struct ImageViewAddressPropertiesNVX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_address: DeviceAddress,
    pub size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageViewAddressPropertiesNVX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageViewAddressPropertiesNVX;
}
unsafe impl<'a> Send for ImageViewAddressPropertiesNVX<'a> {}
unsafe impl<'a> Sync for ImageViewAddressPropertiesNVX<'a> {}
impl<'a> Default for ImageViewAddressPropertiesNVX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_address: Default::default(),
            size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageViewAddressPropertiesNVX<'a> {
    #[inline]
    pub fn device_address(mut self, value: DeviceAddress) -> Self {
        self.device_address = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTextureLODGatherFormatPropertiesAMD.html>"]
#[doc(alias = "VkTextureLODGatherFormatPropertiesAMD")]
pub struct TextureLODGatherFormatPropertiesAMD<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub supports_texture_gather_lodbias_amd: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for TextureLODGatherFormatPropertiesAMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::TextureLodGatherFormatPropertiesAMD;
}
unsafe impl<'a> Send for TextureLODGatherFormatPropertiesAMD<'a> {}
unsafe impl<'a> Sync for TextureLODGatherFormatPropertiesAMD<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageFormatProperties2<'b>>
    for TextureLODGatherFormatPropertiesAMD<'a>
{
}
impl<'a> Default for TextureLODGatherFormatPropertiesAMD<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            supports_texture_gather_lodbias_amd: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> TextureLODGatherFormatPropertiesAMD<'a> {
    #[inline]
    pub fn supports_texture_gather_lodbias_amd(mut self, value: impl Into<Bool32>) -> Self {
        self.supports_texture_gather_lodbias_amd = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderResourceUsageAMD.html>"]
#[doc(alias = "VkShaderResourceUsageAMD")]
pub struct ShaderResourceUsageAMD {
    pub num_used_vgprs: u32,
    pub num_used_sgprs: u32,
    pub lds_size_per_local_work_group: u32,
    pub lds_usage_size_in_bytes: usize,
    pub scratch_mem_usage_in_bytes: usize,
}
unsafe impl Send for ShaderResourceUsageAMD {}
unsafe impl Sync for ShaderResourceUsageAMD {}
impl Default for ShaderResourceUsageAMD {
    fn default() -> Self {
        Self {
            num_used_vgprs: Default::default(),
            num_used_sgprs: Default::default(),
            lds_size_per_local_work_group: Default::default(),
            lds_usage_size_in_bytes: Default::default(),
            scratch_mem_usage_in_bytes: Default::default(),
        }
    }
}
impl ShaderResourceUsageAMD {
    #[inline]
    pub fn num_used_vgprs(mut self, value: u32) -> Self {
        self.num_used_vgprs = value;
        self
    }
    #[inline]
    pub fn num_used_sgprs(mut self, value: u32) -> Self {
        self.num_used_sgprs = value;
        self
    }
    #[inline]
    pub fn lds_size_per_local_work_group(mut self, value: u32) -> Self {
        self.lds_size_per_local_work_group = value;
        self
    }
    #[inline]
    pub fn lds_usage_size_in_bytes(mut self, value: usize) -> Self {
        self.lds_usage_size_in_bytes = value;
        self
    }
    #[inline]
    pub fn scratch_mem_usage_in_bytes(mut self, value: usize) -> Self {
        self.scratch_mem_usage_in_bytes = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderStatisticsInfoAMD.html>"]
#[doc(alias = "VkShaderStatisticsInfoAMD")]
pub struct ShaderStatisticsInfoAMD {
    pub shader_stage_mask: ShaderStageFlags,
    pub resource_usage: ShaderResourceUsageAMD,
    pub num_physical_vgprs: u32,
    pub num_physical_sgprs: u32,
    pub num_available_vgprs: u32,
    pub num_available_sgprs: u32,
    pub compute_work_group_size: [u32; 3u16 as _],
}
unsafe impl Send for ShaderStatisticsInfoAMD {}
unsafe impl Sync for ShaderStatisticsInfoAMD {}
impl Default for ShaderStatisticsInfoAMD {
    fn default() -> Self {
        Self {
            shader_stage_mask: Default::default(),
            resource_usage: Default::default(),
            num_physical_vgprs: Default::default(),
            num_physical_sgprs: Default::default(),
            num_available_vgprs: Default::default(),
            num_available_sgprs: Default::default(),
            compute_work_group_size: array::from_fn(|_| Default::default()),
        }
    }
}
impl ShaderStatisticsInfoAMD {
    #[inline]
    pub fn shader_stage_mask(mut self, value: ShaderStageFlags) -> Self {
        self.shader_stage_mask = value;
        self
    }
    #[inline]
    pub fn resource_usage(mut self, value: ShaderResourceUsageAMD) -> Self {
        self.resource_usage = value;
        self
    }
    #[inline]
    pub fn num_physical_vgprs(mut self, value: u32) -> Self {
        self.num_physical_vgprs = value;
        self
    }
    #[inline]
    pub fn num_physical_sgprs(mut self, value: u32) -> Self {
        self.num_physical_sgprs = value;
        self
    }
    #[inline]
    pub fn num_available_vgprs(mut self, value: u32) -> Self {
        self.num_available_vgprs = value;
        self
    }
    #[inline]
    pub fn num_available_sgprs(mut self, value: u32) -> Self {
        self.num_available_sgprs = value;
        self
    }
    #[inline]
    pub fn compute_work_group_size(mut self, value: [u32; 3u16 as _]) -> Self {
        self.compute_work_group_size = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFragmentShadingRateAttachmentInfoKHR.html>"]
#[doc(alias = "VkRenderingFragmentShadingRateAttachmentInfoKHR")]
pub struct RenderingFragmentShadingRateAttachmentInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_view: Option<ImageView>,
    pub image_layout: ImageLayout,
    pub shading_rate_attachment_texel_size: Extent2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderingFragmentShadingRateAttachmentInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RenderingFragmentShadingRateAttachmentInfoKHR;
}
unsafe impl<'a> Send for RenderingFragmentShadingRateAttachmentInfoKHR<'a> {}
unsafe impl<'a> Sync for RenderingFragmentShadingRateAttachmentInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderingInfo<'b>>
    for RenderingFragmentShadingRateAttachmentInfoKHR<'a>
{
}
impl<'a> Default for RenderingFragmentShadingRateAttachmentInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_view: Default::default(),
            image_layout: ImageLayout::Undefined,
            shading_rate_attachment_texel_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderingFragmentShadingRateAttachmentInfoKHR<'a> {
    #[inline]
    pub fn image_view(mut self, value: Option<&'a ImageView>) -> Self {
        self.image_view = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn image_layout(mut self, value: ImageLayout) -> Self {
        self.image_layout = value;
        self
    }
    #[inline]
    pub fn shading_rate_attachment_texel_size(mut self, value: Extent2D) -> Self {
        self.shading_rate_attachment_texel_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFragmentDensityMapAttachmentInfoEXT.html>"]
#[doc(alias = "VkRenderingFragmentDensityMapAttachmentInfoEXT")]
pub struct RenderingFragmentDensityMapAttachmentInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_view: Option<ImageView>,
    pub image_layout: ImageLayout,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderingFragmentDensityMapAttachmentInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RenderingFragmentDensityMapAttachmentInfoEXT;
}
unsafe impl<'a> Send for RenderingFragmentDensityMapAttachmentInfoEXT<'a> {}
unsafe impl<'a> Sync for RenderingFragmentDensityMapAttachmentInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderingInfo<'b>>
    for RenderingFragmentDensityMapAttachmentInfoEXT<'a>
{
}
impl<'a> Default for RenderingFragmentDensityMapAttachmentInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_view: Default::default(),
            image_layout: ImageLayout::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderingFragmentDensityMapAttachmentInfoEXT<'a> {
    #[inline]
    pub fn image_view(mut self, value: &'a ImageView) -> Self {
        self.image_view = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn image_layout(mut self, value: ImageLayout) -> Self {
        self.image_layout = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentSampleCountInfoAMD.html>"]
#[doc(alias = "VkAttachmentSampleCountInfoAMD")]
pub struct AttachmentSampleCountInfoAMD<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) color_attachment_count: u32,
    pub(crate) p_color_attachment_samples: *const SampleCountFlags,
    pub depth_stencil_attachment_samples: SampleCountFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AttachmentSampleCountInfoAMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AttachmentSampleCountInfoAMD;
}
unsafe impl<'a> Send for AttachmentSampleCountInfoAMD<'a> {}
unsafe impl<'a> Sync for AttachmentSampleCountInfoAMD<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<CommandBufferInheritanceInfo<'b>>
    for AttachmentSampleCountInfoAMD<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for AttachmentSampleCountInfoAMD<'a>
{
}
impl<'a> Default for AttachmentSampleCountInfoAMD<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            color_attachment_count: Default::default(),
            p_color_attachment_samples: ptr::null(),
            depth_stencil_attachment_samples: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AttachmentSampleCountInfoAMD<'a> {
    #[inline]
    pub fn depth_stencil_attachment_samples(mut self, value: SampleCountFlags) -> Self {
        self.depth_stencil_attachment_samples = value;
        self
    }
    #[inline]
    pub fn color_attachment_samples(
        mut self,
        p_color_attachment_samples: impl AsSlice<'a, SampleCountFlags>,
    ) -> Self {
        self.p_color_attachment_samples = p_color_attachment_samples.as_slice().as_ptr().cast();
        self.color_attachment_count = p_color_attachment_samples.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type AttachmentSampleCountInfoNV<'a> = AttachmentSampleCountInfoAMD<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultiviewPerViewAttributesInfoNVX.html>"]
#[doc(alias = "VkMultiviewPerViewAttributesInfoNVX")]
pub struct MultiviewPerViewAttributesInfoNVX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub per_view_attributes: Bool32,
    pub per_view_attributes_position_xonly: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MultiviewPerViewAttributesInfoNVX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MultiviewPerViewAttributesInfoNVX;
}
unsafe impl<'a> Send for MultiviewPerViewAttributesInfoNVX<'a> {}
unsafe impl<'a> Sync for MultiviewPerViewAttributesInfoNVX<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<CommandBufferInheritanceInfo<'b>>
    for MultiviewPerViewAttributesInfoNVX<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for MultiviewPerViewAttributesInfoNVX<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<RenderingInfo<'b>>
    for MultiviewPerViewAttributesInfoNVX<'a>
{
}
impl<'a> Default for MultiviewPerViewAttributesInfoNVX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            per_view_attributes: Default::default(),
            per_view_attributes_position_xonly: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MultiviewPerViewAttributesInfoNVX<'a> {
    #[inline]
    pub fn per_view_attributes(mut self, value: impl Into<Bool32>) -> Self {
        self.per_view_attributes = value.into();
        self
    }
    #[inline]
    pub fn per_view_attributes_position_xonly(mut self, value: impl Into<Bool32>) -> Self {
        self.per_view_attributes_position_xonly = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStreamDescriptorSurfaceCreateInfoGGP.html>"]
#[doc(alias = "VkStreamDescriptorSurfaceCreateInfoGGP")]
pub struct StreamDescriptorSurfaceCreateInfoGGP<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub stream_descriptor: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for StreamDescriptorSurfaceCreateInfoGGP<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::StreamDescriptorSurfaceCreateInfoGGP;
}
unsafe impl<'a> Send for StreamDescriptorSurfaceCreateInfoGGP<'a> {}
unsafe impl<'a> Sync for StreamDescriptorSurfaceCreateInfoGGP<'a> {}
impl<'a> Default for StreamDescriptorSurfaceCreateInfoGGP<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            stream_descriptor: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> StreamDescriptorSurfaceCreateInfoGGP<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn stream_descriptor(mut self, value: VoidPtr) -> Self {
        self.stream_descriptor = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCornerSampledImageFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceCornerSampledImageFeaturesNV")]
pub struct PhysicalDeviceCornerSampledImageFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub corner_sampled_image: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCornerSampledImageFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceCornerSampledImageFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceCornerSampledImageFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCornerSampledImageFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceCornerSampledImageFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceCornerSampledImageFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceCornerSampledImageFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            corner_sampled_image: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCornerSampledImageFeaturesNV<'a> {
    #[inline]
    pub fn corner_sampled_image(mut self, value: impl Into<Bool32>) -> Self {
        self.corner_sampled_image = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalImageFormatPropertiesNV.html>"]
#[doc(alias = "VkExternalImageFormatPropertiesNV")]
pub struct ExternalImageFormatPropertiesNV {
    pub image_format_properties: ImageFormatProperties,
    pub external_memory_features: ExternalMemoryFeatureFlagsNV,
    pub export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNV,
    pub compatible_handle_types: ExternalMemoryHandleTypeFlagsNV,
}
unsafe impl Send for ExternalImageFormatPropertiesNV {}
unsafe impl Sync for ExternalImageFormatPropertiesNV {}
impl Default for ExternalImageFormatPropertiesNV {
    fn default() -> Self {
        Self {
            image_format_properties: Default::default(),
            external_memory_features: Default::default(),
            export_from_imported_handle_types: Default::default(),
            compatible_handle_types: Default::default(),
        }
    }
}
impl ExternalImageFormatPropertiesNV {
    #[inline]
    pub fn image_format_properties(mut self, value: ImageFormatProperties) -> Self {
        self.image_format_properties = value;
        self
    }
    #[inline]
    pub fn external_memory_features(mut self, value: ExternalMemoryFeatureFlagsNV) -> Self {
        self.external_memory_features = value;
        self
    }
    #[inline]
    pub fn export_from_imported_handle_types(
        mut self,
        value: ExternalMemoryHandleTypeFlagsNV,
    ) -> Self {
        self.export_from_imported_handle_types = value;
        self
    }
    #[inline]
    pub fn compatible_handle_types(mut self, value: ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.compatible_handle_types = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryImageCreateInfoNV.html>"]
#[doc(alias = "VkExternalMemoryImageCreateInfoNV")]
pub struct ExternalMemoryImageCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_types: ExternalMemoryHandleTypeFlagsNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExternalMemoryImageCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExternalMemoryImageCreateInfoNV;
}
unsafe impl<'a> Send for ExternalMemoryImageCreateInfoNV<'a> {}
unsafe impl<'a> Sync for ExternalMemoryImageCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>>
    for ExternalMemoryImageCreateInfoNV<'a>
{
}
impl<'a> Default for ExternalMemoryImageCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_types: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExternalMemoryImageCreateInfoNV<'a> {
    #[inline]
    pub fn handle_types(mut self, value: ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.handle_types = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryAllocateInfoNV.html>"]
#[doc(alias = "VkExportMemoryAllocateInfoNV")]
pub struct ExportMemoryAllocateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_types: ExternalMemoryHandleTypeFlagsNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportMemoryAllocateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportMemoryAllocateInfoNV;
}
unsafe impl<'a> Send for ExportMemoryAllocateInfoNV<'a> {}
unsafe impl<'a> Sync for ExportMemoryAllocateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>> for ExportMemoryAllocateInfoNV<'a> {}
impl<'a> Default for ExportMemoryAllocateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_types: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportMemoryAllocateInfoNV<'a> {
    #[inline]
    pub fn handle_types(mut self, value: ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.handle_types = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryWin32HandleInfoNV.html>"]
#[doc(alias = "VkImportMemoryWin32HandleInfoNV")]
pub struct ImportMemoryWin32HandleInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_type: ExternalMemoryHandleTypeFlagsNV,
    pub handle: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportMemoryWin32HandleInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportMemoryWin32HandleInfoNV;
}
unsafe impl<'a> Send for ImportMemoryWin32HandleInfoNV<'a> {}
unsafe impl<'a> Sync for ImportMemoryWin32HandleInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>>
    for ImportMemoryWin32HandleInfoNV<'a>
{
}
impl<'a> Default for ImportMemoryWin32HandleInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_type: Default::default(),
            handle: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportMemoryWin32HandleInfoNV<'a> {
    #[inline]
    pub fn handle_type(mut self, value: ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn handle(mut self, value: VoidPtr) -> Self {
        self.handle = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryWin32HandleInfoNV.html>"]
#[doc(alias = "VkExportMemoryWin32HandleInfoNV")]
pub struct ExportMemoryWin32HandleInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_attributes: *const VoidPtr,
    pub dw_access: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportMemoryWin32HandleInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportMemoryWin32HandleInfoNV;
}
unsafe impl<'a> Send for ExportMemoryWin32HandleInfoNV<'a> {}
unsafe impl<'a> Sync for ExportMemoryWin32HandleInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>>
    for ExportMemoryWin32HandleInfoNV<'a>
{
}
impl<'a> Default for ExportMemoryWin32HandleInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_attributes: ptr::null(),
            dw_access: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportMemoryWin32HandleInfoNV<'a> {
    #[inline]
    pub fn attributes(mut self, value: Option<&'a VoidPtr>) -> Self {
        self.p_attributes = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn dw_access(mut self, value: VoidPtr) -> Self {
        self.dw_access = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWin32KeyedMutexAcquireReleaseInfoNV.html>"]
#[doc(alias = "VkWin32KeyedMutexAcquireReleaseInfoNV")]
pub struct Win32KeyedMutexAcquireReleaseInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) acquire_count: u32,
    pub(crate) p_acquire_syncs: *const DeviceMemory,
    pub(crate) p_acquire_keys: *const u64,
    pub(crate) p_acquire_timeout_milliseconds: *const u32,
    pub(crate) release_count: u32,
    pub(crate) p_release_syncs: *const DeviceMemory,
    pub(crate) p_release_keys: *const u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for Win32KeyedMutexAcquireReleaseInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::Win32KeyedMutexAcquireReleaseInfoNV;
}
unsafe impl<'a> Send for Win32KeyedMutexAcquireReleaseInfoNV<'a> {}
unsafe impl<'a> Sync for Win32KeyedMutexAcquireReleaseInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo<'b>> for Win32KeyedMutexAcquireReleaseInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo2<'b>>
    for Win32KeyedMutexAcquireReleaseInfoNV<'a>
{
}
impl<'a> Default for Win32KeyedMutexAcquireReleaseInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            acquire_count: Default::default(),
            p_acquire_syncs: ptr::null(),
            p_acquire_keys: ptr::null(),
            p_acquire_timeout_milliseconds: ptr::null(),
            release_count: Default::default(),
            p_release_syncs: ptr::null(),
            p_release_keys: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> Win32KeyedMutexAcquireReleaseInfoNV<'a> {
    #[inline]
    pub fn acquire<V0: Alias<raw::DeviceMemory> + 'a>(
        mut self,
        p_acquire_syncs: impl AsSlice<'a, V0>,
        p_acquire_keys: impl AsSlice<'a, u64>,
        p_acquire_timeout_milliseconds: impl AsSlice<'a, u32>,
    ) -> Self {
        self.p_acquire_syncs = p_acquire_syncs.as_slice().as_ptr().cast();
        self.p_acquire_keys = p_acquire_keys.as_slice().as_ptr().cast();
        self.p_acquire_timeout_milliseconds =
            p_acquire_timeout_milliseconds.as_slice().as_ptr().cast();
        self.acquire_count = p_acquire_syncs.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn release<V0: Alias<raw::DeviceMemory> + 'a>(
        mut self,
        p_release_syncs: impl AsSlice<'a, V0>,
        p_release_keys: impl AsSlice<'a, u64>,
    ) -> Self {
        self.p_release_syncs = p_release_syncs.as_slice().as_ptr().cast();
        self.p_release_keys = p_release_keys.as_slice().as_ptr().cast();
        self.release_count = p_release_syncs.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationFlagsEXT.html>"]
#[doc(alias = "VkValidationFlagsEXT")]
pub struct ValidationFlagsEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) disabled_validation_check_count: u32,
    pub(crate) p_disabled_validation_checks: *const ValidationCheckEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ValidationFlagsEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ValidationFlagsEXT;
}
unsafe impl<'a> Send for ValidationFlagsEXT<'a> {}
unsafe impl<'a> Sync for ValidationFlagsEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<InstanceCreateInfo<'b>> for ValidationFlagsEXT<'a> {}
impl<'a> Default for ValidationFlagsEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            disabled_validation_check_count: Default::default(),
            p_disabled_validation_checks: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ValidationFlagsEXT<'a> {
    #[inline]
    pub fn disabled_validation_checks(
        mut self,
        p_disabled_validation_checks: impl AsSlice<'a, ValidationCheckEXT>,
    ) -> Self {
        self.p_disabled_validation_checks = p_disabled_validation_checks.as_slice().as_ptr().cast();
        self.disabled_validation_check_count = p_disabled_validation_checks.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViSurfaceCreateInfoNN.html>"]
#[doc(alias = "VkViSurfaceCreateInfoNN")]
pub struct ViSurfaceCreateInfoNN<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub window: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ViSurfaceCreateInfoNN<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ViSurfaceCreateInfoNN;
}
unsafe impl<'a> Send for ViSurfaceCreateInfoNN<'a> {}
unsafe impl<'a> Sync for ViSurfaceCreateInfoNN<'a> {}
impl<'a> Default for ViSurfaceCreateInfoNN<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            window: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ViSurfaceCreateInfoNN<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn window(mut self, value: VoidPtr) -> Self {
        self.window = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewASTCDecodeModeEXT.html>"]
#[doc(alias = "VkImageViewASTCDecodeModeEXT")]
pub struct ImageViewASTCDecodeModeEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub decode_mode: Format,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageViewASTCDecodeModeEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageViewAstcDecodeModeEXT;
}
unsafe impl<'a> Send for ImageViewASTCDecodeModeEXT<'a> {}
unsafe impl<'a> Sync for ImageViewASTCDecodeModeEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageViewCreateInfo<'b>> for ImageViewASTCDecodeModeEXT<'a> {}
impl<'a> Default for ImageViewASTCDecodeModeEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            decode_mode: Format::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageViewASTCDecodeModeEXT<'a> {
    #[inline]
    pub fn decode_mode(mut self, value: Format) -> Self {
        self.decode_mode = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceASTCDecodeFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceASTCDecodeFeaturesEXT")]
pub struct PhysicalDeviceASTCDecodeFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub decode_mode_shared_exponent: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceASTCDecodeFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceAstcDecodeFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceASTCDecodeFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceASTCDecodeFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceASTCDecodeFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceASTCDecodeFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceASTCDecodeFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            decode_mode_shared_exponent: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceASTCDecodeFeaturesEXT<'a> {
    #[inline]
    pub fn decode_mode_shared_exponent(mut self, value: impl Into<Bool32>) -> Self {
        self.decode_mode_shared_exponent = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineRobustnessFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDevicePipelineRobustnessFeaturesEXT")]
pub struct PhysicalDevicePipelineRobustnessFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline_robustness: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePipelineRobustnessFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePipelineRobustnessFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDevicePipelineRobustnessFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePipelineRobustnessFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePipelineRobustnessFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePipelineRobustnessFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDevicePipelineRobustnessFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline_robustness: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePipelineRobustnessFeaturesEXT<'a> {
    #[inline]
    pub fn pipeline_robustness(mut self, value: impl Into<Bool32>) -> Self {
        self.pipeline_robustness = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineRobustnessPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDevicePipelineRobustnessPropertiesEXT")]
pub struct PhysicalDevicePipelineRobustnessPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub default_robustness_storage_buffers: PipelineRobustnessBufferBehaviorEXT,
    pub default_robustness_uniform_buffers: PipelineRobustnessBufferBehaviorEXT,
    pub default_robustness_vertex_inputs: PipelineRobustnessBufferBehaviorEXT,
    pub default_robustness_images: PipelineRobustnessImageBehaviorEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePipelineRobustnessPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePipelineRobustnessPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDevicePipelineRobustnessPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePipelineRobustnessPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDevicePipelineRobustnessPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDevicePipelineRobustnessPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            default_robustness_storage_buffers: PipelineRobustnessBufferBehaviorEXT::DeviceDefault,
            default_robustness_uniform_buffers: PipelineRobustnessBufferBehaviorEXT::DeviceDefault,
            default_robustness_vertex_inputs: PipelineRobustnessBufferBehaviorEXT::DeviceDefault,
            default_robustness_images: PipelineRobustnessImageBehaviorEXT::DeviceDefault,
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePipelineRobustnessPropertiesEXT<'a> {
    #[inline]
    pub fn default_robustness_storage_buffers(
        mut self,
        value: PipelineRobustnessBufferBehaviorEXT,
    ) -> Self {
        self.default_robustness_storage_buffers = value;
        self
    }
    #[inline]
    pub fn default_robustness_uniform_buffers(
        mut self,
        value: PipelineRobustnessBufferBehaviorEXT,
    ) -> Self {
        self.default_robustness_uniform_buffers = value;
        self
    }
    #[inline]
    pub fn default_robustness_vertex_inputs(
        mut self,
        value: PipelineRobustnessBufferBehaviorEXT,
    ) -> Self {
        self.default_robustness_vertex_inputs = value;
        self
    }
    #[inline]
    pub fn default_robustness_images(mut self, value: PipelineRobustnessImageBehaviorEXT) -> Self {
        self.default_robustness_images = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRobustnessCreateInfoEXT.html>"]
#[doc(alias = "VkPipelineRobustnessCreateInfoEXT")]
pub struct PipelineRobustnessCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub storage_buffers: PipelineRobustnessBufferBehaviorEXT,
    pub uniform_buffers: PipelineRobustnessBufferBehaviorEXT,
    pub vertex_inputs: PipelineRobustnessBufferBehaviorEXT,
    pub images: PipelineRobustnessImageBehaviorEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineRobustnessCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineRobustnessCreateInfoEXT;
}
unsafe impl<'a> Send for PipelineRobustnessCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for PipelineRobustnessCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for PipelineRobustnessCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<ComputePipelineCreateInfo<'b>>
    for PipelineRobustnessCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<PipelineShaderStageCreateInfo<'b>>
    for PipelineRobustnessCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<RayTracingPipelineCreateInfoKHR<'b>>
    for PipelineRobustnessCreateInfoEXT<'a>
{
}
impl<'a> Default for PipelineRobustnessCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            storage_buffers: PipelineRobustnessBufferBehaviorEXT::DeviceDefault,
            uniform_buffers: PipelineRobustnessBufferBehaviorEXT::DeviceDefault,
            vertex_inputs: PipelineRobustnessBufferBehaviorEXT::DeviceDefault,
            images: PipelineRobustnessImageBehaviorEXT::DeviceDefault,
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineRobustnessCreateInfoEXT<'a> {
    #[inline]
    pub fn storage_buffers(mut self, value: PipelineRobustnessBufferBehaviorEXT) -> Self {
        self.storage_buffers = value;
        self
    }
    #[inline]
    pub fn uniform_buffers(mut self, value: PipelineRobustnessBufferBehaviorEXT) -> Self {
        self.uniform_buffers = value;
        self
    }
    #[inline]
    pub fn vertex_inputs(mut self, value: PipelineRobustnessBufferBehaviorEXT) -> Self {
        self.vertex_inputs = value;
        self
    }
    #[inline]
    pub fn images(mut self, value: PipelineRobustnessImageBehaviorEXT) -> Self {
        self.images = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryWin32HandleInfoKHR.html>"]
#[doc(alias = "VkImportMemoryWin32HandleInfoKHR")]
pub struct ImportMemoryWin32HandleInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub handle: VoidPtr,
    pub name: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportMemoryWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportMemoryWin32HandleInfoKHR;
}
unsafe impl<'a> Send for ImportMemoryWin32HandleInfoKHR<'a> {}
unsafe impl<'a> Sync for ImportMemoryWin32HandleInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>>
    for ImportMemoryWin32HandleInfoKHR<'a>
{
}
impl<'a> Default for ImportMemoryWin32HandleInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_type: Default::default(),
            handle: ptr::null(),
            name: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportMemoryWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn handle_type(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn handle(mut self, value: VoidPtr) -> Self {
        self.handle = value;
        self
    }
    #[inline]
    pub fn name(mut self, value: VoidPtr) -> Self {
        self.name = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryWin32HandleInfoKHR.html>"]
#[doc(alias = "VkExportMemoryWin32HandleInfoKHR")]
pub struct ExportMemoryWin32HandleInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_attributes: *const VoidPtr,
    pub dw_access: VoidPtr,
    pub name: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportMemoryWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportMemoryWin32HandleInfoKHR;
}
unsafe impl<'a> Send for ExportMemoryWin32HandleInfoKHR<'a> {}
unsafe impl<'a> Sync for ExportMemoryWin32HandleInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>>
    for ExportMemoryWin32HandleInfoKHR<'a>
{
}
impl<'a> Default for ExportMemoryWin32HandleInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_attributes: ptr::null(),
            dw_access: ptr::null(),
            name: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportMemoryWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn attributes(mut self, value: Option<&'a VoidPtr>) -> Self {
        self.p_attributes = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn dw_access(mut self, value: VoidPtr) -> Self {
        self.dw_access = value;
        self
    }
    #[inline]
    pub fn name(mut self, value: VoidPtr) -> Self {
        self.name = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryWin32HandlePropertiesKHR.html>"]
#[doc(alias = "VkMemoryWin32HandlePropertiesKHR")]
pub struct MemoryWin32HandlePropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory_type_bits: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryWin32HandlePropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryWin32HandlePropertiesKHR;
}
unsafe impl<'a> Send for MemoryWin32HandlePropertiesKHR<'a> {}
unsafe impl<'a> Sync for MemoryWin32HandlePropertiesKHR<'a> {}
impl<'a> Default for MemoryWin32HandlePropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory_type_bits: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryWin32HandlePropertiesKHR<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, value: u32) -> Self {
        self.memory_type_bits = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetWin32HandleInfoKHR.html>"]
#[doc(alias = "VkMemoryGetWin32HandleInfoKHR")]
pub struct MemoryGetWin32HandleInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory: Option<DeviceMemory>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryGetWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryGetWin32HandleInfoKHR;
}
unsafe impl<'a> Send for MemoryGetWin32HandleInfoKHR<'a> {}
unsafe impl<'a> Sync for MemoryGetWin32HandleInfoKHR<'a> {}
impl<'a> Default for MemoryGetWin32HandleInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory: Default::default(),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryGetWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryFdInfoKHR.html>"]
#[doc(alias = "VkImportMemoryFdInfoKHR")]
pub struct ImportMemoryFdInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub fd: c_int,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportMemoryFdInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportMemoryFdInfoKHR;
}
unsafe impl<'a> Send for ImportMemoryFdInfoKHR<'a> {}
unsafe impl<'a> Sync for ImportMemoryFdInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>> for ImportMemoryFdInfoKHR<'a> {}
impl<'a> Default for ImportMemoryFdInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_type: Default::default(),
            fd: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportMemoryFdInfoKHR<'a> {
    #[inline]
    pub fn handle_type(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn fd(mut self, value: c_int) -> Self {
        self.fd = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryFdPropertiesKHR.html>"]
#[doc(alias = "VkMemoryFdPropertiesKHR")]
pub struct MemoryFdPropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory_type_bits: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryFdPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryFdPropertiesKHR;
}
unsafe impl<'a> Send for MemoryFdPropertiesKHR<'a> {}
unsafe impl<'a> Sync for MemoryFdPropertiesKHR<'a> {}
impl<'a> Default for MemoryFdPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory_type_bits: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryFdPropertiesKHR<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, value: u32) -> Self {
        self.memory_type_bits = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetFdInfoKHR.html>"]
#[doc(alias = "VkMemoryGetFdInfoKHR")]
pub struct MemoryGetFdInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory: Option<DeviceMemory>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryGetFdInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryGetFdInfoKHR;
}
unsafe impl<'a> Send for MemoryGetFdInfoKHR<'a> {}
unsafe impl<'a> Sync for MemoryGetFdInfoKHR<'a> {}
impl<'a> Default for MemoryGetFdInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory: Default::default(),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryGetFdInfoKHR<'a> {
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWin32KeyedMutexAcquireReleaseInfoKHR.html>"]
#[doc(alias = "VkWin32KeyedMutexAcquireReleaseInfoKHR")]
pub struct Win32KeyedMutexAcquireReleaseInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) acquire_count: u32,
    pub(crate) p_acquire_syncs: *const DeviceMemory,
    pub(crate) p_acquire_keys: *const u64,
    pub(crate) p_acquire_timeouts: *const u32,
    pub(crate) release_count: u32,
    pub(crate) p_release_syncs: *const DeviceMemory,
    pub(crate) p_release_keys: *const u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for Win32KeyedMutexAcquireReleaseInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::Win32KeyedMutexAcquireReleaseInfoKHR;
}
unsafe impl<'a> Send for Win32KeyedMutexAcquireReleaseInfoKHR<'a> {}
unsafe impl<'a> Sync for Win32KeyedMutexAcquireReleaseInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo<'b>>
    for Win32KeyedMutexAcquireReleaseInfoKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo2<'b>>
    for Win32KeyedMutexAcquireReleaseInfoKHR<'a>
{
}
impl<'a> Default for Win32KeyedMutexAcquireReleaseInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            acquire_count: Default::default(),
            p_acquire_syncs: ptr::null(),
            p_acquire_keys: ptr::null(),
            p_acquire_timeouts: ptr::null(),
            release_count: Default::default(),
            p_release_syncs: ptr::null(),
            p_release_keys: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> Win32KeyedMutexAcquireReleaseInfoKHR<'a> {
    #[inline]
    pub fn acquire<V0: Alias<raw::DeviceMemory> + 'a>(
        mut self,
        p_acquire_syncs: impl AsSlice<'a, V0>,
        p_acquire_keys: impl AsSlice<'a, u64>,
        p_acquire_timeouts: impl AsSlice<'a, u32>,
    ) -> Self {
        self.p_acquire_syncs = p_acquire_syncs.as_slice().as_ptr().cast();
        self.p_acquire_keys = p_acquire_keys.as_slice().as_ptr().cast();
        self.p_acquire_timeouts = p_acquire_timeouts.as_slice().as_ptr().cast();
        self.acquire_count = p_acquire_syncs.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn release<V0: Alias<raw::DeviceMemory> + 'a>(
        mut self,
        p_release_syncs: impl AsSlice<'a, V0>,
        p_release_keys: impl AsSlice<'a, u64>,
    ) -> Self {
        self.p_release_syncs = p_release_syncs.as_slice().as_ptr().cast();
        self.p_release_keys = p_release_keys.as_slice().as_ptr().cast();
        self.release_count = p_release_syncs.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportSemaphoreWin32HandleInfoKHR.html>"]
#[doc(alias = "VkImportSemaphoreWin32HandleInfoKHR")]
pub struct ImportSemaphoreWin32HandleInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub semaphore: Option<Semaphore>,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub handle: VoidPtr,
    pub name: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportSemaphoreWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportSemaphoreWin32HandleInfoKHR;
}
unsafe impl<'a> Send for ImportSemaphoreWin32HandleInfoKHR<'a> {}
unsafe impl<'a> Sync for ImportSemaphoreWin32HandleInfoKHR<'a> {}
impl<'a> Default for ImportSemaphoreWin32HandleInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            semaphore: Default::default(),
            flags: Default::default(),
            handle_type: Default::default(),
            handle: ptr::null(),
            name: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportSemaphoreWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn semaphore(mut self, value: &'a Semaphore) -> Self {
        self.semaphore = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn flags(mut self, value: SemaphoreImportFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn handle(mut self, value: VoidPtr) -> Self {
        self.handle = value;
        self
    }
    #[inline]
    pub fn name(mut self, value: VoidPtr) -> Self {
        self.name = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportSemaphoreWin32HandleInfoKHR.html>"]
#[doc(alias = "VkExportSemaphoreWin32HandleInfoKHR")]
pub struct ExportSemaphoreWin32HandleInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_attributes: *const VoidPtr,
    pub dw_access: VoidPtr,
    pub name: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportSemaphoreWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportSemaphoreWin32HandleInfoKHR;
}
unsafe impl<'a> Send for ExportSemaphoreWin32HandleInfoKHR<'a> {}
unsafe impl<'a> Sync for ExportSemaphoreWin32HandleInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SemaphoreCreateInfo<'b>>
    for ExportSemaphoreWin32HandleInfoKHR<'a>
{
}
impl<'a> Default for ExportSemaphoreWin32HandleInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_attributes: ptr::null(),
            dw_access: ptr::null(),
            name: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportSemaphoreWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn attributes(mut self, value: Option<&'a VoidPtr>) -> Self {
        self.p_attributes = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn dw_access(mut self, value: VoidPtr) -> Self {
        self.dw_access = value;
        self
    }
    #[inline]
    pub fn name(mut self, value: VoidPtr) -> Self {
        self.name = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkD3D12FenceSubmitInfoKHR.html>"]
#[doc(alias = "VkD3D12FenceSubmitInfoKHR")]
pub struct D3D12FenceSubmitInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub wait_semaphore_values_count: u32,
    pub(crate) p_wait_semaphore_values: *const u64,
    pub signal_semaphore_values_count: u32,
    pub(crate) p_signal_semaphore_values: *const u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for D3D12FenceSubmitInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::D3D12FenceSubmitInfoKHR;
}
unsafe impl<'a> Send for D3D12FenceSubmitInfoKHR<'a> {}
unsafe impl<'a> Sync for D3D12FenceSubmitInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo<'b>> for D3D12FenceSubmitInfoKHR<'a> {}
impl<'a> Default for D3D12FenceSubmitInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            wait_semaphore_values_count: Default::default(),
            p_wait_semaphore_values: ptr::null(),
            signal_semaphore_values_count: Default::default(),
            p_signal_semaphore_values: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> D3D12FenceSubmitInfoKHR<'a> {
    #[inline]
    pub fn wait_semaphore_values_count(mut self, value: u32) -> Self {
        self.wait_semaphore_values_count = value;
        self
    }
    #[inline]
    pub fn signal_semaphore_values_count(mut self, value: u32) -> Self {
        self.signal_semaphore_values_count = value;
        self
    }
    #[inline]
    pub fn wait_semaphore_values(mut self, p_wait_semaphore_values: impl AsSlice<'a, u64>) -> Self {
        self.p_wait_semaphore_values = p_wait_semaphore_values.as_slice().as_ptr().cast();
        self.wait_semaphore_values_count = p_wait_semaphore_values.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn signal_semaphore_values(
        mut self,
        p_signal_semaphore_values: impl AsSlice<'a, u64>,
    ) -> Self {
        self.p_signal_semaphore_values = p_signal_semaphore_values.as_slice().as_ptr().cast();
        self.signal_semaphore_values_count = p_signal_semaphore_values.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreGetWin32HandleInfoKHR.html>"]
#[doc(alias = "VkSemaphoreGetWin32HandleInfoKHR")]
pub struct SemaphoreGetWin32HandleInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub semaphore: Option<Semaphore>,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SemaphoreGetWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SemaphoreGetWin32HandleInfoKHR;
}
unsafe impl<'a> Send for SemaphoreGetWin32HandleInfoKHR<'a> {}
unsafe impl<'a> Sync for SemaphoreGetWin32HandleInfoKHR<'a> {}
impl<'a> Default for SemaphoreGetWin32HandleInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            semaphore: Default::default(),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SemaphoreGetWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn semaphore(mut self, value: &'a Semaphore) -> Self {
        self.semaphore = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportSemaphoreFdInfoKHR.html>"]
#[doc(alias = "VkImportSemaphoreFdInfoKHR")]
pub struct ImportSemaphoreFdInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub semaphore: Option<Semaphore>,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub fd: c_int,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportSemaphoreFdInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportSemaphoreFdInfoKHR;
}
unsafe impl<'a> Send for ImportSemaphoreFdInfoKHR<'a> {}
unsafe impl<'a> Sync for ImportSemaphoreFdInfoKHR<'a> {}
impl<'a> Default for ImportSemaphoreFdInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            semaphore: Default::default(),
            flags: Default::default(),
            handle_type: Default::default(),
            fd: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportSemaphoreFdInfoKHR<'a> {
    #[inline]
    pub fn semaphore(mut self, value: &'a Semaphore) -> Self {
        self.semaphore = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn flags(mut self, value: SemaphoreImportFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn fd(mut self, value: c_int) -> Self {
        self.fd = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreGetFdInfoKHR.html>"]
#[doc(alias = "VkSemaphoreGetFdInfoKHR")]
pub struct SemaphoreGetFdInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub semaphore: Option<Semaphore>,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SemaphoreGetFdInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SemaphoreGetFdInfoKHR;
}
unsafe impl<'a> Send for SemaphoreGetFdInfoKHR<'a> {}
unsafe impl<'a> Sync for SemaphoreGetFdInfoKHR<'a> {}
impl<'a> Default for SemaphoreGetFdInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            semaphore: Default::default(),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SemaphoreGetFdInfoKHR<'a> {
    #[inline]
    pub fn semaphore(mut self, value: &'a Semaphore) -> Self {
        self.semaphore = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePushDescriptorPropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDevicePushDescriptorPropertiesKHR")]
pub struct PhysicalDevicePushDescriptorPropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_push_descriptors: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePushDescriptorPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDevicePushDescriptorPropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDevicePushDescriptorPropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePushDescriptorPropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDevicePushDescriptorPropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDevicePushDescriptorPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_push_descriptors: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePushDescriptorPropertiesKHR<'a> {
    #[inline]
    pub fn max_push_descriptors(mut self, value: u32) -> Self {
        self.max_push_descriptors = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkConditionalRenderingBeginInfoEXT.html>"]
#[doc(alias = "VkConditionalRenderingBeginInfoEXT")]
pub struct ConditionalRenderingBeginInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
    pub flags: ConditionalRenderingFlagsEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ConditionalRenderingBeginInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ConditionalRenderingBeginInfoEXT;
}
unsafe impl<'a> Send for ConditionalRenderingBeginInfoEXT<'a> {}
unsafe impl<'a> Sync for ConditionalRenderingBeginInfoEXT<'a> {}
impl<'a> Default for ConditionalRenderingBeginInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            buffer: Default::default(),
            offset: Default::default(),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ConditionalRenderingBeginInfoEXT<'a> {
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn offset(mut self, value: DeviceSize) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: ConditionalRenderingFlagsEXT) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceConditionalRenderingFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceConditionalRenderingFeaturesEXT")]
pub struct PhysicalDeviceConditionalRenderingFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub conditional_rendering: Bool32,
    pub inherited_conditional_rendering: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceConditionalRenderingFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceConditionalRenderingFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceConditionalRenderingFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceConditionalRenderingFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceConditionalRenderingFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceConditionalRenderingFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceConditionalRenderingFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            conditional_rendering: Default::default(),
            inherited_conditional_rendering: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceConditionalRenderingFeaturesEXT<'a> {
    #[inline]
    pub fn conditional_rendering(mut self, value: impl Into<Bool32>) -> Self {
        self.conditional_rendering = value.into();
        self
    }
    #[inline]
    pub fn inherited_conditional_rendering(mut self, value: impl Into<Bool32>) -> Self {
        self.inherited_conditional_rendering = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceConditionalRenderingInfoEXT.html>"]
#[doc(alias = "VkCommandBufferInheritanceConditionalRenderingInfoEXT")]
pub struct CommandBufferInheritanceConditionalRenderingInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub conditional_rendering_enable: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CommandBufferInheritanceConditionalRenderingInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::CommandBufferInheritanceConditionalRenderingInfoEXT;
}
unsafe impl<'a> Send for CommandBufferInheritanceConditionalRenderingInfoEXT<'a> {}
unsafe impl<'a> Sync for CommandBufferInheritanceConditionalRenderingInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<CommandBufferInheritanceInfo<'b>>
    for CommandBufferInheritanceConditionalRenderingInfoEXT<'a>
{
}
impl<'a> Default for CommandBufferInheritanceConditionalRenderingInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            conditional_rendering_enable: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CommandBufferInheritanceConditionalRenderingInfoEXT<'a> {
    #[inline]
    pub fn conditional_rendering_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.conditional_rendering_enable = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentRegionsKHR.html>"]
#[doc(alias = "VkPresentRegionsKHR")]
pub struct PresentRegionsKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub swapchain_count: u32,
    pub(crate) p_regions: *const PresentRegionKHR<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PresentRegionsKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PresentRegionsKHR;
}
unsafe impl<'a> Send for PresentRegionsKHR<'a> {}
unsafe impl<'a> Sync for PresentRegionsKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PresentInfoKHR<'b>> for PresentRegionsKHR<'a> {}
impl<'a> Default for PresentRegionsKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            swapchain_count: Default::default(),
            p_regions: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PresentRegionsKHR<'a> {
    #[inline]
    pub fn swapchain_count(mut self, value: u32) -> Self {
        self.swapchain_count = value;
        self
    }
    #[inline]
    pub fn regions(mut self, p_regions: impl AsSlice<'a, PresentRegionKHR<'a>>) -> Self {
        self.p_regions = p_regions.as_slice().as_ptr().cast();
        self.swapchain_count = p_regions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentRegionKHR.html>"]
#[doc(alias = "VkPresentRegionKHR")]
pub struct PresentRegionKHR<'a> {
    pub rectangle_count: u32,
    pub(crate) p_rectangles: *const RectLayerKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for PresentRegionKHR<'a> {}
unsafe impl<'a> Sync for PresentRegionKHR<'a> {}
impl<'a> Default for PresentRegionKHR<'a> {
    fn default() -> Self {
        Self {
            rectangle_count: Default::default(),
            p_rectangles: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PresentRegionKHR<'a> {
    #[inline]
    pub fn rectangle_count(mut self, value: u32) -> Self {
        self.rectangle_count = value;
        self
    }
    #[inline]
    pub fn rectangles(mut self, p_rectangles: impl AsSlice<'a, RectLayerKHR>) -> Self {
        self.p_rectangles = p_rectangles.as_slice().as_ptr().cast();
        self.rectangle_count = p_rectangles.as_slice().len() as _;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRectLayerKHR.html>"]
#[doc(alias = "VkRectLayerKHR")]
pub struct RectLayerKHR {
    pub offset: Offset2D,
    pub extent: Extent2D,
    pub layer: u32,
}
unsafe impl Send for RectLayerKHR {}
unsafe impl Sync for RectLayerKHR {}
impl Default for RectLayerKHR {
    fn default() -> Self {
        Self {
            offset: Default::default(),
            extent: Default::default(),
            layer: Default::default(),
        }
    }
}
impl RectLayerKHR {
    #[inline]
    pub fn offset(mut self, value: Offset2D) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn extent(mut self, value: Extent2D) -> Self {
        self.extent = value;
        self
    }
    #[inline]
    pub fn layer(mut self, value: u32) -> Self {
        self.layer = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViewportWScalingNV.html>"]
#[doc(alias = "VkViewportWScalingNV")]
pub struct ViewportWScalingNV {
    pub xcoeff: f32,
    pub ycoeff: f32,
}
unsafe impl Send for ViewportWScalingNV {}
unsafe impl Sync for ViewportWScalingNV {}
impl Default for ViewportWScalingNV {
    fn default() -> Self {
        Self {
            xcoeff: Default::default(),
            ycoeff: Default::default(),
        }
    }
}
impl ViewportWScalingNV {
    #[inline]
    pub fn xcoeff(mut self, value: f32) -> Self {
        self.xcoeff = value;
        self
    }
    #[inline]
    pub fn ycoeff(mut self, value: f32) -> Self {
        self.ycoeff = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportWScalingStateCreateInfoNV.html>"]
#[doc(alias = "VkPipelineViewportWScalingStateCreateInfoNV")]
pub struct PipelineViewportWScalingStateCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub viewport_wscaling_enable: Bool32,
    pub viewport_count: u32,
    pub(crate) p_viewport_wscalings: *const ViewportWScalingNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineViewportWScalingStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineViewportWScalingStateCreateInfoNV;
}
unsafe impl<'a> Send for PipelineViewportWScalingStateCreateInfoNV<'a> {}
unsafe impl<'a> Sync for PipelineViewportWScalingStateCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineViewportStateCreateInfo<'b>>
    for PipelineViewportWScalingStateCreateInfoNV<'a>
{
}
impl<'a> Default for PipelineViewportWScalingStateCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            viewport_wscaling_enable: Default::default(),
            viewport_count: Default::default(),
            p_viewport_wscalings: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineViewportWScalingStateCreateInfoNV<'a> {
    #[inline]
    pub fn viewport_wscaling_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.viewport_wscaling_enable = value.into();
        self
    }
    #[inline]
    pub fn viewport_count(mut self, value: u32) -> Self {
        self.viewport_count = value;
        self
    }
    #[inline]
    pub fn viewport_wscalings(
        mut self,
        p_viewport_wscalings: impl AsSlice<'a, ViewportWScalingNV>,
    ) -> Self {
        self.p_viewport_wscalings = p_viewport_wscalings.as_slice().as_ptr().cast();
        self.viewport_count = p_viewport_wscalings.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilities2EXT.html>"]
#[doc(alias = "VkSurfaceCapabilities2EXT")]
pub struct SurfaceCapabilities2EXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub min_image_count: u32,
    pub max_image_count: u32,
    pub current_extent: Extent2D,
    pub min_image_extent: Extent2D,
    pub max_image_extent: Extent2D,
    pub max_image_array_layers: u32,
    pub supported_transforms: SurfaceTransformFlagsKHR,
    pub current_transform: SurfaceTransformFlagsKHR,
    pub supported_composite_alpha: CompositeAlphaFlagsKHR,
    pub supported_usage_flags: ImageUsageFlags,
    pub supported_surface_counters: SurfaceCounterFlagsEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SurfaceCapabilities2EXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SurfaceCapabilities2EXT;
}
unsafe impl<'a> Send for SurfaceCapabilities2EXT<'a> {}
unsafe impl<'a> Sync for SurfaceCapabilities2EXT<'a> {}
impl<'a> Default for SurfaceCapabilities2EXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            min_image_count: Default::default(),
            max_image_count: Default::default(),
            current_extent: Default::default(),
            min_image_extent: Default::default(),
            max_image_extent: Default::default(),
            max_image_array_layers: Default::default(),
            supported_transforms: Default::default(),
            current_transform: Default::default(),
            supported_composite_alpha: Default::default(),
            supported_usage_flags: Default::default(),
            supported_surface_counters: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SurfaceCapabilities2EXT<'a> {
    #[inline]
    pub fn min_image_count(mut self, value: u32) -> Self {
        self.min_image_count = value;
        self
    }
    #[inline]
    pub fn max_image_count(mut self, value: u32) -> Self {
        self.max_image_count = value;
        self
    }
    #[inline]
    pub fn current_extent(mut self, value: Extent2D) -> Self {
        self.current_extent = value;
        self
    }
    #[inline]
    pub fn min_image_extent(mut self, value: Extent2D) -> Self {
        self.min_image_extent = value;
        self
    }
    #[inline]
    pub fn max_image_extent(mut self, value: Extent2D) -> Self {
        self.max_image_extent = value;
        self
    }
    #[inline]
    pub fn max_image_array_layers(mut self, value: u32) -> Self {
        self.max_image_array_layers = value;
        self
    }
    #[inline]
    pub fn supported_transforms(mut self, value: SurfaceTransformFlagsKHR) -> Self {
        self.supported_transforms = value;
        self
    }
    #[inline]
    pub fn current_transform(mut self, value: SurfaceTransformFlagsKHR) -> Self {
        self.current_transform = value;
        self
    }
    #[inline]
    pub fn supported_composite_alpha(mut self, value: CompositeAlphaFlagsKHR) -> Self {
        self.supported_composite_alpha = value;
        self
    }
    #[inline]
    pub fn supported_usage_flags(mut self, value: ImageUsageFlags) -> Self {
        self.supported_usage_flags = value;
        self
    }
    #[inline]
    pub fn supported_surface_counters(mut self, value: SurfaceCounterFlagsEXT) -> Self {
        self.supported_surface_counters = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPowerInfoEXT.html>"]
#[doc(alias = "VkDisplayPowerInfoEXT")]
pub struct DisplayPowerInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub power_state: DisplayPowerStateEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DisplayPowerInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DisplayPowerInfoEXT;
}
unsafe impl<'a> Send for DisplayPowerInfoEXT<'a> {}
unsafe impl<'a> Sync for DisplayPowerInfoEXT<'a> {}
impl<'a> Default for DisplayPowerInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            power_state: DisplayPowerStateEXT::Off,
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayPowerInfoEXT<'a> {
    #[inline]
    pub fn power_state(mut self, value: DisplayPowerStateEXT) -> Self {
        self.power_state = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceEventInfoEXT.html>"]
#[doc(alias = "VkDeviceEventInfoEXT")]
pub struct DeviceEventInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_event: DeviceEventTypeEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceEventInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceEventInfoEXT;
}
unsafe impl<'a> Send for DeviceEventInfoEXT<'a> {}
unsafe impl<'a> Sync for DeviceEventInfoEXT<'a> {}
impl<'a> Default for DeviceEventInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_event: DeviceEventTypeEXT::DisplayHotplug,
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceEventInfoEXT<'a> {
    #[inline]
    pub fn device_event(mut self, value: DeviceEventTypeEXT) -> Self {
        self.device_event = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayEventInfoEXT.html>"]
#[doc(alias = "VkDisplayEventInfoEXT")]
pub struct DisplayEventInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub display_event: DisplayEventTypeEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DisplayEventInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DisplayEventInfoEXT;
}
unsafe impl<'a> Send for DisplayEventInfoEXT<'a> {}
unsafe impl<'a> Sync for DisplayEventInfoEXT<'a> {}
impl<'a> Default for DisplayEventInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            display_event: DisplayEventTypeEXT::FirstPixelOut,
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayEventInfoEXT<'a> {
    #[inline]
    pub fn display_event(mut self, value: DisplayEventTypeEXT) -> Self {
        self.display_event = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainCounterCreateInfoEXT.html>"]
#[doc(alias = "VkSwapchainCounterCreateInfoEXT")]
pub struct SwapchainCounterCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub surface_counters: SurfaceCounterFlagsEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SwapchainCounterCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SwapchainCounterCreateInfoEXT;
}
unsafe impl<'a> Send for SwapchainCounterCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for SwapchainCounterCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SwapchainCreateInfoKHR<'b>>
    for SwapchainCounterCreateInfoEXT<'a>
{
}
impl<'a> Default for SwapchainCounterCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            surface_counters: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SwapchainCounterCreateInfoEXT<'a> {
    #[inline]
    pub fn surface_counters(mut self, value: SurfaceCounterFlagsEXT) -> Self {
        self.surface_counters = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRefreshCycleDurationGOOGLE.html>"]
#[doc(alias = "VkRefreshCycleDurationGOOGLE")]
pub struct RefreshCycleDurationGOOGLE {
    pub refresh_duration: u64,
}
unsafe impl Send for RefreshCycleDurationGOOGLE {}
unsafe impl Sync for RefreshCycleDurationGOOGLE {}
impl Default for RefreshCycleDurationGOOGLE {
    fn default() -> Self {
        Self {
            refresh_duration: Default::default(),
        }
    }
}
impl RefreshCycleDurationGOOGLE {
    #[inline]
    pub fn refresh_duration(mut self, value: u64) -> Self {
        self.refresh_duration = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPastPresentationTimingGOOGLE.html>"]
#[doc(alias = "VkPastPresentationTimingGOOGLE")]
pub struct PastPresentationTimingGOOGLE {
    pub present_id: u32,
    pub desired_present_time: u64,
    pub actual_present_time: u64,
    pub earliest_present_time: u64,
    pub present_margin: u64,
}
unsafe impl Send for PastPresentationTimingGOOGLE {}
unsafe impl Sync for PastPresentationTimingGOOGLE {}
impl Default for PastPresentationTimingGOOGLE {
    fn default() -> Self {
        Self {
            present_id: Default::default(),
            desired_present_time: Default::default(),
            actual_present_time: Default::default(),
            earliest_present_time: Default::default(),
            present_margin: Default::default(),
        }
    }
}
impl PastPresentationTimingGOOGLE {
    #[inline]
    pub fn present_id(mut self, value: u32) -> Self {
        self.present_id = value;
        self
    }
    #[inline]
    pub fn desired_present_time(mut self, value: u64) -> Self {
        self.desired_present_time = value;
        self
    }
    #[inline]
    pub fn actual_present_time(mut self, value: u64) -> Self {
        self.actual_present_time = value;
        self
    }
    #[inline]
    pub fn earliest_present_time(mut self, value: u64) -> Self {
        self.earliest_present_time = value;
        self
    }
    #[inline]
    pub fn present_margin(mut self, value: u64) -> Self {
        self.present_margin = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentTimesInfoGOOGLE.html>"]
#[doc(alias = "VkPresentTimesInfoGOOGLE")]
pub struct PresentTimesInfoGOOGLE<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub swapchain_count: u32,
    pub(crate) p_times: *const PresentTimeGOOGLE,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PresentTimesInfoGOOGLE<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PresentTimesInfoGOOGLE;
}
unsafe impl<'a> Send for PresentTimesInfoGOOGLE<'a> {}
unsafe impl<'a> Sync for PresentTimesInfoGOOGLE<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PresentInfoKHR<'b>> for PresentTimesInfoGOOGLE<'a> {}
impl<'a> Default for PresentTimesInfoGOOGLE<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            swapchain_count: Default::default(),
            p_times: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PresentTimesInfoGOOGLE<'a> {
    #[inline]
    pub fn swapchain_count(mut self, value: u32) -> Self {
        self.swapchain_count = value;
        self
    }
    #[inline]
    pub fn times(mut self, p_times: impl AsSlice<'a, PresentTimeGOOGLE>) -> Self {
        self.p_times = p_times.as_slice().as_ptr().cast();
        self.swapchain_count = p_times.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentTimeGOOGLE.html>"]
#[doc(alias = "VkPresentTimeGOOGLE")]
pub struct PresentTimeGOOGLE {
    pub present_id: u32,
    pub desired_present_time: u64,
}
unsafe impl Send for PresentTimeGOOGLE {}
unsafe impl Sync for PresentTimeGOOGLE {}
impl Default for PresentTimeGOOGLE {
    fn default() -> Self {
        Self {
            present_id: Default::default(),
            desired_present_time: Default::default(),
        }
    }
}
impl PresentTimeGOOGLE {
    #[inline]
    pub fn present_id(mut self, value: u32) -> Self {
        self.present_id = value;
        self
    }
    #[inline]
    pub fn desired_present_time(mut self, value: u64) -> Self {
        self.desired_present_time = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.html>"]
#[doc(alias = "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX")]
pub struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub per_view_position_all_components: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
}
unsafe impl<'a> Send for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'a>
{
}
impl<'a> Default for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            per_view_position_all_components: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX<'a> {
    #[inline]
    pub fn per_view_position_all_components(mut self, value: impl Into<Bool32>) -> Self {
        self.per_view_position_all_components = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViewportSwizzleNV.html>"]
#[doc(alias = "VkViewportSwizzleNV")]
pub struct ViewportSwizzleNV {
    pub x: ViewportCoordinateSwizzleNV,
    pub y: ViewportCoordinateSwizzleNV,
    pub z: ViewportCoordinateSwizzleNV,
    pub w: ViewportCoordinateSwizzleNV,
}
unsafe impl Send for ViewportSwizzleNV {}
unsafe impl Sync for ViewportSwizzleNV {}
impl Default for ViewportSwizzleNV {
    fn default() -> Self {
        Self {
            x: ViewportCoordinateSwizzleNV::PositiveX,
            y: ViewportCoordinateSwizzleNV::PositiveX,
            z: ViewportCoordinateSwizzleNV::PositiveX,
            w: ViewportCoordinateSwizzleNV::PositiveX,
        }
    }
}
impl ViewportSwizzleNV {
    #[inline]
    pub fn x(mut self, value: ViewportCoordinateSwizzleNV) -> Self {
        self.x = value;
        self
    }
    #[inline]
    pub fn y(mut self, value: ViewportCoordinateSwizzleNV) -> Self {
        self.y = value;
        self
    }
    #[inline]
    pub fn z(mut self, value: ViewportCoordinateSwizzleNV) -> Self {
        self.z = value;
        self
    }
    #[inline]
    pub fn w(mut self, value: ViewportCoordinateSwizzleNV) -> Self {
        self.w = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportSwizzleStateCreateInfoNV.html>"]
#[doc(alias = "VkPipelineViewportSwizzleStateCreateInfoNV")]
pub struct PipelineViewportSwizzleStateCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub(crate) viewport_count: u32,
    pub(crate) p_viewport_swizzles: *const ViewportSwizzleNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineViewportSwizzleStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineViewportSwizzleStateCreateInfoNV;
}
unsafe impl<'a> Send for PipelineViewportSwizzleStateCreateInfoNV<'a> {}
unsafe impl<'a> Sync for PipelineViewportSwizzleStateCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineViewportStateCreateInfo<'b>>
    for PipelineViewportSwizzleStateCreateInfoNV<'a>
{
}
impl<'a> Default for PipelineViewportSwizzleStateCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            viewport_count: Default::default(),
            p_viewport_swizzles: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineViewportSwizzleStateCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn viewport_swizzles(
        mut self,
        p_viewport_swizzles: impl AsSlice<'a, ViewportSwizzleNV>,
    ) -> Self {
        self.p_viewport_swizzles = p_viewport_swizzles.as_slice().as_ptr().cast();
        self.viewport_count = p_viewport_swizzles.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDiscardRectanglePropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceDiscardRectanglePropertiesEXT")]
pub struct PhysicalDeviceDiscardRectanglePropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_discard_rectangles: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDiscardRectanglePropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDiscardRectanglePropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceDiscardRectanglePropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDiscardRectanglePropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceDiscardRectanglePropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceDiscardRectanglePropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_discard_rectangles: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDiscardRectanglePropertiesEXT<'a> {
    #[inline]
    pub fn max_discard_rectangles(mut self, value: u32) -> Self {
        self.max_discard_rectangles = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDiscardRectangleStateCreateInfoEXT.html>"]
#[doc(alias = "VkPipelineDiscardRectangleStateCreateInfoEXT")]
pub struct PipelineDiscardRectangleStateCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub discard_rectangle_mode: DiscardRectangleModeEXT,
    pub(crate) discard_rectangle_count: u32,
    pub(crate) p_discard_rectangles: *const Rect2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineDiscardRectangleStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineDiscardRectangleStateCreateInfoEXT;
}
unsafe impl<'a> Send for PipelineDiscardRectangleStateCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for PipelineDiscardRectangleStateCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for PipelineDiscardRectangleStateCreateInfoEXT<'a>
{
}
impl<'a> Default for PipelineDiscardRectangleStateCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            discard_rectangle_mode: DiscardRectangleModeEXT::Inclusive,
            discard_rectangle_count: Default::default(),
            p_discard_rectangles: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineDiscardRectangleStateCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn discard_rectangle_mode(mut self, value: DiscardRectangleModeEXT) -> Self {
        self.discard_rectangle_mode = value;
        self
    }
    #[inline]
    pub fn discard_rectangles(mut self, p_discard_rectangles: impl AsSlice<'a, Rect2D>) -> Self {
        self.p_discard_rectangles = p_discard_rectangles.as_slice().as_ptr().cast();
        self.discard_rectangle_count = p_discard_rectangles.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceConservativeRasterizationPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceConservativeRasterizationPropertiesEXT")]
pub struct PhysicalDeviceConservativeRasterizationPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub primitive_overestimation_size: f32,
    pub max_extra_primitive_overestimation_size: f32,
    pub extra_primitive_overestimation_size_granularity: f32,
    pub primitive_underestimation: Bool32,
    pub conservative_point_and_line_rasterization: Bool32,
    pub degenerate_triangles_rasterized: Bool32,
    pub degenerate_lines_rasterized: Bool32,
    pub fully_covered_fragment_shader_input_variable: Bool32,
    pub conservative_rasterization_post_depth_coverage: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceConservativeRasterizationPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceConservativeRasterizationPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceConservativeRasterizationPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceConservativeRasterizationPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceConservativeRasterizationPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceConservativeRasterizationPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            primitive_overestimation_size: Default::default(),
            max_extra_primitive_overestimation_size: Default::default(),
            extra_primitive_overestimation_size_granularity: Default::default(),
            primitive_underestimation: Default::default(),
            conservative_point_and_line_rasterization: Default::default(),
            degenerate_triangles_rasterized: Default::default(),
            degenerate_lines_rasterized: Default::default(),
            fully_covered_fragment_shader_input_variable: Default::default(),
            conservative_rasterization_post_depth_coverage: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceConservativeRasterizationPropertiesEXT<'a> {
    #[inline]
    pub fn primitive_overestimation_size(mut self, value: f32) -> Self {
        self.primitive_overestimation_size = value;
        self
    }
    #[inline]
    pub fn max_extra_primitive_overestimation_size(mut self, value: f32) -> Self {
        self.max_extra_primitive_overestimation_size = value;
        self
    }
    #[inline]
    pub fn extra_primitive_overestimation_size_granularity(mut self, value: f32) -> Self {
        self.extra_primitive_overestimation_size_granularity = value;
        self
    }
    #[inline]
    pub fn primitive_underestimation(mut self, value: impl Into<Bool32>) -> Self {
        self.primitive_underestimation = value.into();
        self
    }
    #[inline]
    pub fn conservative_point_and_line_rasterization(mut self, value: impl Into<Bool32>) -> Self {
        self.conservative_point_and_line_rasterization = value.into();
        self
    }
    #[inline]
    pub fn degenerate_triangles_rasterized(mut self, value: impl Into<Bool32>) -> Self {
        self.degenerate_triangles_rasterized = value.into();
        self
    }
    #[inline]
    pub fn degenerate_lines_rasterized(mut self, value: impl Into<Bool32>) -> Self {
        self.degenerate_lines_rasterized = value.into();
        self
    }
    #[inline]
    pub fn fully_covered_fragment_shader_input_variable(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.fully_covered_fragment_shader_input_variable = value.into();
        self
    }
    #[inline]
    pub fn conservative_rasterization_post_depth_coverage(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.conservative_rasterization_post_depth_coverage = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationConservativeStateCreateInfoEXT.html>"]
#[doc(alias = "VkPipelineRasterizationConservativeStateCreateInfoEXT")]
pub struct PipelineRasterizationConservativeStateCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub conservative_rasterization_mode: ConservativeRasterizationModeEXT,
    pub extra_primitive_overestimation_size: f32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineRasterizationConservativeStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineRasterizationConservativeStateCreateInfoEXT;
}
unsafe impl<'a> Send for PipelineRasterizationConservativeStateCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for PipelineRasterizationConservativeStateCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineRasterizationStateCreateInfo<'b>>
    for PipelineRasterizationConservativeStateCreateInfoEXT<'a>
{
}
impl<'a> Default for PipelineRasterizationConservativeStateCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            conservative_rasterization_mode: ConservativeRasterizationModeEXT::Disabled,
            extra_primitive_overestimation_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineRasterizationConservativeStateCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn conservative_rasterization_mode(
        mut self,
        value: ConservativeRasterizationModeEXT,
    ) -> Self {
        self.conservative_rasterization_mode = value;
        self
    }
    #[inline]
    pub fn extra_primitive_overestimation_size(mut self, value: f32) -> Self {
        self.extra_primitive_overestimation_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthClipEnableFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceDepthClipEnableFeaturesEXT")]
pub struct PhysicalDeviceDepthClipEnableFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub depth_clip_enable: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDepthClipEnableFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceDepthClipEnableFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceDepthClipEnableFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDepthClipEnableFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDepthClipEnableFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDepthClipEnableFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceDepthClipEnableFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            depth_clip_enable: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDepthClipEnableFeaturesEXT<'a> {
    #[inline]
    pub fn depth_clip_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_clip_enable = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationDepthClipStateCreateInfoEXT.html>"]
#[doc(alias = "VkPipelineRasterizationDepthClipStateCreateInfoEXT")]
pub struct PipelineRasterizationDepthClipStateCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub depth_clip_enable: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineRasterizationDepthClipStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineRasterizationDepthClipStateCreateInfoEXT;
}
unsafe impl<'a> Send for PipelineRasterizationDepthClipStateCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for PipelineRasterizationDepthClipStateCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineRasterizationStateCreateInfo<'b>>
    for PipelineRasterizationDepthClipStateCreateInfoEXT<'a>
{
}
impl<'a> Default for PipelineRasterizationDepthClipStateCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            depth_clip_enable: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineRasterizationDepthClipStateCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn depth_clip_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_clip_enable = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkHdrMetadataEXT.html>"]
#[doc(alias = "VkHdrMetadataEXT")]
pub struct HdrMetadataEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub display_primary_red: XYColorEXT,
    pub display_primary_green: XYColorEXT,
    pub display_primary_blue: XYColorEXT,
    pub white_point: XYColorEXT,
    pub max_luminance: f32,
    pub min_luminance: f32,
    pub max_content_light_level: f32,
    pub max_frame_average_light_level: f32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for HdrMetadataEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::HdrMetadataEXT;
}
unsafe impl<'a> Send for HdrMetadataEXT<'a> {}
unsafe impl<'a> Sync for HdrMetadataEXT<'a> {}
impl<'a> Default for HdrMetadataEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            display_primary_red: Default::default(),
            display_primary_green: Default::default(),
            display_primary_blue: Default::default(),
            white_point: Default::default(),
            max_luminance: Default::default(),
            min_luminance: Default::default(),
            max_content_light_level: Default::default(),
            max_frame_average_light_level: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> HdrMetadataEXT<'a> {
    #[inline]
    pub fn display_primary_red(mut self, value: XYColorEXT) -> Self {
        self.display_primary_red = value;
        self
    }
    #[inline]
    pub fn display_primary_green(mut self, value: XYColorEXT) -> Self {
        self.display_primary_green = value;
        self
    }
    #[inline]
    pub fn display_primary_blue(mut self, value: XYColorEXT) -> Self {
        self.display_primary_blue = value;
        self
    }
    #[inline]
    pub fn white_point(mut self, value: XYColorEXT) -> Self {
        self.white_point = value;
        self
    }
    #[inline]
    pub fn max_luminance(mut self, value: f32) -> Self {
        self.max_luminance = value;
        self
    }
    #[inline]
    pub fn min_luminance(mut self, value: f32) -> Self {
        self.min_luminance = value;
        self
    }
    #[inline]
    pub fn max_content_light_level(mut self, value: f32) -> Self {
        self.max_content_light_level = value;
        self
    }
    #[inline]
    pub fn max_frame_average_light_level(mut self, value: f32) -> Self {
        self.max_frame_average_light_level = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXYColorEXT.html>"]
#[doc(alias = "VkXYColorEXT")]
pub struct XYColorEXT {
    pub x: f32,
    pub y: f32,
}
unsafe impl Send for XYColorEXT {}
unsafe impl Sync for XYColorEXT {}
impl Default for XYColorEXT {
    fn default() -> Self {
        Self {
            x: Default::default(),
            y: Default::default(),
        }
    }
}
impl XYColorEXT {
    #[inline]
    pub fn x(mut self, value: f32) -> Self {
        self.x = value;
        self
    }
    #[inline]
    pub fn y(mut self, value: f32) -> Self {
        self.y = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG.html>"]
#[doc(alias = "VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG")]
pub struct PhysicalDeviceRelaxedLineRasterizationFeaturesIMG<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub relaxed_line_rasterization: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRelaxedLineRasterizationFeaturesIMG<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceRelaxedLineRasterizationFeaturesIMG;
}
unsafe impl<'a> Send for PhysicalDeviceRelaxedLineRasterizationFeaturesIMG<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRelaxedLineRasterizationFeaturesIMG<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRelaxedLineRasterizationFeaturesIMG<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRelaxedLineRasterizationFeaturesIMG<'a>
{
}
impl<'a> Default for PhysicalDeviceRelaxedLineRasterizationFeaturesIMG<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            relaxed_line_rasterization: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRelaxedLineRasterizationFeaturesIMG<'a> {
    #[inline]
    pub fn relaxed_line_rasterization(mut self, value: impl Into<Bool32>) -> Self {
        self.relaxed_line_rasterization = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSharedPresentSurfaceCapabilitiesKHR.html>"]
#[doc(alias = "VkSharedPresentSurfaceCapabilitiesKHR")]
pub struct SharedPresentSurfaceCapabilitiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shared_present_supported_usage_flags: ImageUsageFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SharedPresentSurfaceCapabilitiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SharedPresentSurfaceCapabilitiesKHR;
}
unsafe impl<'a> Send for SharedPresentSurfaceCapabilitiesKHR<'a> {}
unsafe impl<'a> Sync for SharedPresentSurfaceCapabilitiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SurfaceCapabilities2KHR<'b>>
    for SharedPresentSurfaceCapabilitiesKHR<'a>
{
}
impl<'a> Default for SharedPresentSurfaceCapabilitiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shared_present_supported_usage_flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SharedPresentSurfaceCapabilitiesKHR<'a> {
    #[inline]
    pub fn shared_present_supported_usage_flags(mut self, value: ImageUsageFlags) -> Self {
        self.shared_present_supported_usage_flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportFenceWin32HandleInfoKHR.html>"]
#[doc(alias = "VkImportFenceWin32HandleInfoKHR")]
pub struct ImportFenceWin32HandleInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fence: Option<Fence>,
    pub flags: FenceImportFlags,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub handle: VoidPtr,
    pub name: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportFenceWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportFenceWin32HandleInfoKHR;
}
unsafe impl<'a> Send for ImportFenceWin32HandleInfoKHR<'a> {}
unsafe impl<'a> Sync for ImportFenceWin32HandleInfoKHR<'a> {}
impl<'a> Default for ImportFenceWin32HandleInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fence: Default::default(),
            flags: Default::default(),
            handle_type: Default::default(),
            handle: ptr::null(),
            name: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportFenceWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn fence(mut self, value: &'a Fence) -> Self {
        self.fence = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn flags(mut self, value: FenceImportFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalFenceHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn handle(mut self, value: VoidPtr) -> Self {
        self.handle = value;
        self
    }
    #[inline]
    pub fn name(mut self, value: VoidPtr) -> Self {
        self.name = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportFenceWin32HandleInfoKHR.html>"]
#[doc(alias = "VkExportFenceWin32HandleInfoKHR")]
pub struct ExportFenceWin32HandleInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_attributes: *const VoidPtr,
    pub dw_access: VoidPtr,
    pub name: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportFenceWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportFenceWin32HandleInfoKHR;
}
unsafe impl<'a> Send for ExportFenceWin32HandleInfoKHR<'a> {}
unsafe impl<'a> Sync for ExportFenceWin32HandleInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<FenceCreateInfo<'b>> for ExportFenceWin32HandleInfoKHR<'a> {}
impl<'a> Default for ExportFenceWin32HandleInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_attributes: ptr::null(),
            dw_access: ptr::null(),
            name: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportFenceWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn attributes(mut self, value: Option<&'a VoidPtr>) -> Self {
        self.p_attributes = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn dw_access(mut self, value: VoidPtr) -> Self {
        self.dw_access = value;
        self
    }
    #[inline]
    pub fn name(mut self, value: VoidPtr) -> Self {
        self.name = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceGetWin32HandleInfoKHR.html>"]
#[doc(alias = "VkFenceGetWin32HandleInfoKHR")]
pub struct FenceGetWin32HandleInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fence: Option<Fence>,
    pub handle_type: ExternalFenceHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for FenceGetWin32HandleInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FenceGetWin32HandleInfoKHR;
}
unsafe impl<'a> Send for FenceGetWin32HandleInfoKHR<'a> {}
unsafe impl<'a> Sync for FenceGetWin32HandleInfoKHR<'a> {}
impl<'a> Default for FenceGetWin32HandleInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fence: Default::default(),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> FenceGetWin32HandleInfoKHR<'a> {
    #[inline]
    pub fn fence(mut self, value: &'a Fence) -> Self {
        self.fence = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalFenceHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportFenceFdInfoKHR.html>"]
#[doc(alias = "VkImportFenceFdInfoKHR")]
pub struct ImportFenceFdInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fence: Option<Fence>,
    pub flags: FenceImportFlags,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub fd: c_int,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportFenceFdInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportFenceFdInfoKHR;
}
unsafe impl<'a> Send for ImportFenceFdInfoKHR<'a> {}
unsafe impl<'a> Sync for ImportFenceFdInfoKHR<'a> {}
impl<'a> Default for ImportFenceFdInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fence: Default::default(),
            flags: Default::default(),
            handle_type: Default::default(),
            fd: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportFenceFdInfoKHR<'a> {
    #[inline]
    pub fn fence(mut self, value: &'a Fence) -> Self {
        self.fence = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn flags(mut self, value: FenceImportFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalFenceHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn fd(mut self, value: c_int) -> Self {
        self.fd = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceGetFdInfoKHR.html>"]
#[doc(alias = "VkFenceGetFdInfoKHR")]
pub struct FenceGetFdInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fence: Option<Fence>,
    pub handle_type: ExternalFenceHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for FenceGetFdInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FenceGetFdInfoKHR;
}
unsafe impl<'a> Send for FenceGetFdInfoKHR<'a> {}
unsafe impl<'a> Sync for FenceGetFdInfoKHR<'a> {}
impl<'a> Default for FenceGetFdInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fence: Default::default(),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> FenceGetFdInfoKHR<'a> {
    #[inline]
    pub fn fence(mut self, value: &'a Fence) -> Self {
        self.fence = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalFenceHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePerformanceQueryFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDevicePerformanceQueryFeaturesKHR")]
pub struct PhysicalDevicePerformanceQueryFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub performance_counter_query_pools: Bool32,
    pub performance_counter_multiple_query_pools: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePerformanceQueryFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDevicePerformanceQueryFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDevicePerformanceQueryFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePerformanceQueryFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePerformanceQueryFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePerformanceQueryFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDevicePerformanceQueryFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            performance_counter_query_pools: Default::default(),
            performance_counter_multiple_query_pools: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePerformanceQueryFeaturesKHR<'a> {
    #[inline]
    pub fn performance_counter_query_pools(mut self, value: impl Into<Bool32>) -> Self {
        self.performance_counter_query_pools = value.into();
        self
    }
    #[inline]
    pub fn performance_counter_multiple_query_pools(mut self, value: impl Into<Bool32>) -> Self {
        self.performance_counter_multiple_query_pools = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePerformanceQueryPropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDevicePerformanceQueryPropertiesKHR")]
pub struct PhysicalDevicePerformanceQueryPropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub allow_command_buffer_query_copies: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePerformanceQueryPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePerformanceQueryPropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDevicePerformanceQueryPropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePerformanceQueryPropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDevicePerformanceQueryPropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDevicePerformanceQueryPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            allow_command_buffer_query_copies: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePerformanceQueryPropertiesKHR<'a> {
    #[inline]
    pub fn allow_command_buffer_query_copies(mut self, value: impl Into<Bool32>) -> Self {
        self.allow_command_buffer_query_copies = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceCounterKHR.html>"]
#[doc(alias = "VkPerformanceCounterKHR")]
pub struct PerformanceCounterKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub unit: PerformanceCounterUnitKHR,
    pub scope: PerformanceCounterScopeKHR,
    pub storage: PerformanceCounterStorageKHR,
    pub uuid: [u8; UUID_SIZE as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PerformanceCounterKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PerformanceCounterKHR;
}
unsafe impl<'a> Send for PerformanceCounterKHR<'a> {}
unsafe impl<'a> Sync for PerformanceCounterKHR<'a> {}
impl<'a> Default for PerformanceCounterKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            unit: PerformanceCounterUnitKHR::Generic,
            scope: PerformanceCounterScopeKHR::CommandBuffer,
            storage: PerformanceCounterStorageKHR::Int32,
            uuid: array::from_fn(|_| Default::default()),
            phantom: PhantomData,
        }
    }
}
impl<'a> PerformanceCounterKHR<'a> {
    #[inline]
    pub fn unit(mut self, value: PerformanceCounterUnitKHR) -> Self {
        self.unit = value;
        self
    }
    #[inline]
    pub fn scope(mut self, value: PerformanceCounterScopeKHR) -> Self {
        self.scope = value;
        self
    }
    #[inline]
    pub fn storage(mut self, value: PerformanceCounterStorageKHR) -> Self {
        self.storage = value;
        self
    }
    #[inline]
    pub fn uuid(mut self, value: [u8; UUID_SIZE as _]) -> Self {
        self.uuid = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceCounterDescriptionKHR.html>"]
#[doc(alias = "VkPerformanceCounterDescriptionKHR")]
pub struct PerformanceCounterDescriptionKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: PerformanceCounterDescriptionFlagsKHR,
    pub(crate) name: [c_char; MAX_DESCRIPTION_SIZE as _],
    pub(crate) category: [c_char; MAX_DESCRIPTION_SIZE as _],
    pub(crate) description: [c_char; MAX_DESCRIPTION_SIZE as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PerformanceCounterDescriptionKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PerformanceCounterDescriptionKHR;
}
unsafe impl<'a> Send for PerformanceCounterDescriptionKHR<'a> {}
unsafe impl<'a> Sync for PerformanceCounterDescriptionKHR<'a> {}
impl<'a> Default for PerformanceCounterDescriptionKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            name: array::from_fn(|_| Default::default()),
            category: array::from_fn(|_| Default::default()),
            description: array::from_fn(|_| Default::default()),
            phantom: PhantomData,
        }
    }
}
impl<'a> PerformanceCounterDescriptionKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: PerformanceCounterDescriptionFlagsKHR) -> Self {
        self.flags = value;
        self
    }
    pub fn get_name(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.name) }.as_slice(),
        )
        .unwrap()
    }
    pub fn get_category(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.category) }
                .as_slice(),
        )
        .unwrap()
    }
    pub fn get_description(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.description) }
                .as_slice(),
        )
        .unwrap()
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolPerformanceCreateInfoKHR.html>"]
#[doc(alias = "VkQueryPoolPerformanceCreateInfoKHR")]
pub struct QueryPoolPerformanceCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub queue_family_index: u32,
    pub(crate) counter_index_count: u32,
    pub(crate) p_counter_indices: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for QueryPoolPerformanceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QueryPoolPerformanceCreateInfoKHR;
}
unsafe impl<'a> Send for QueryPoolPerformanceCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for QueryPoolPerformanceCreateInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<QueryPoolCreateInfo<'b>>
    for QueryPoolPerformanceCreateInfoKHR<'a>
{
}
impl<'a> Default for QueryPoolPerformanceCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            queue_family_index: Default::default(),
            counter_index_count: Default::default(),
            p_counter_indices: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> QueryPoolPerformanceCreateInfoKHR<'a> {
    #[inline]
    pub fn queue_family_index(mut self, value: u32) -> Self {
        self.queue_family_index = value;
        self
    }
    #[inline]
    pub fn counter_indices(mut self, p_counter_indices: impl AsSlice<'a, u32>) -> Self {
        self.p_counter_indices = p_counter_indices.as_slice().as_ptr().cast();
        self.counter_index_count = p_counter_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceCounterResultKHR.html>"]
#[doc(alias = "VkPerformanceCounterResultKHR")]
pub union PerformanceCounterResultKHR {
    pub int32: i32,
    pub int64: i64,
    pub uint32: u32,
    pub uint64: u64,
    pub float32: f32,
    pub float64: f64,
}
impl Default for PerformanceCounterResultKHR {
    fn default() -> Self {
        Self {
            int32: Default::default(),
        }
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAcquireProfilingLockInfoKHR.html>"]
#[doc(alias = "VkAcquireProfilingLockInfoKHR")]
pub struct AcquireProfilingLockInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: AcquireProfilingLockFlagsKHR,
    pub timeout: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AcquireProfilingLockInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AcquireProfilingLockInfoKHR;
}
unsafe impl<'a> Send for AcquireProfilingLockInfoKHR<'a> {}
unsafe impl<'a> Sync for AcquireProfilingLockInfoKHR<'a> {}
impl<'a> Default for AcquireProfilingLockInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            timeout: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AcquireProfilingLockInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: AcquireProfilingLockFlagsKHR) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn timeout(mut self, value: u64) -> Self {
        self.timeout = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceQuerySubmitInfoKHR.html>"]
#[doc(alias = "VkPerformanceQuerySubmitInfoKHR")]
pub struct PerformanceQuerySubmitInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub counter_pass_index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PerformanceQuerySubmitInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PerformanceQuerySubmitInfoKHR;
}
unsafe impl<'a> Send for PerformanceQuerySubmitInfoKHR<'a> {}
unsafe impl<'a> Sync for PerformanceQuerySubmitInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo<'b>> for PerformanceQuerySubmitInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo2<'b>> for PerformanceQuerySubmitInfoKHR<'a> {}
impl<'a> Default for PerformanceQuerySubmitInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            counter_pass_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PerformanceQuerySubmitInfoKHR<'a> {
    #[inline]
    pub fn counter_pass_index(mut self, value: u32) -> Self {
        self.counter_pass_index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceQueryReservationInfoKHR.html>"]
#[doc(alias = "VkPerformanceQueryReservationInfoKHR")]
pub struct PerformanceQueryReservationInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_performance_queries_per_pool: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PerformanceQueryReservationInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PerformanceQueryReservationInfoKHR;
}
unsafe impl<'a> Send for PerformanceQueryReservationInfoKHR<'a> {}
unsafe impl<'a> Sync for PerformanceQueryReservationInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PerformanceQueryReservationInfoKHR<'a>
{
}
impl<'a> Default for PerformanceQueryReservationInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_performance_queries_per_pool: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PerformanceQueryReservationInfoKHR<'a> {
    #[inline]
    pub fn max_performance_queries_per_pool(mut self, value: u32) -> Self {
        self.max_performance_queries_per_pool = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSurfaceInfo2KHR.html>"]
#[doc(alias = "VkPhysicalDeviceSurfaceInfo2KHR")]
pub struct PhysicalDeviceSurfaceInfo2KHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub surface: Option<SurfaceKHR>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSurfaceInfo2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceSurfaceInfo2KHR;
}
unsafe impl<'a> Send for PhysicalDeviceSurfaceInfo2KHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSurfaceInfo2KHR<'a> {}
impl<'a> Default for PhysicalDeviceSurfaceInfo2KHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            surface: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSurfaceInfo2KHR<'a> {
    #[inline]
    pub fn surface(mut self, value: Option<&'a SurfaceKHR>) -> Self {
        self.surface = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilities2KHR.html>"]
#[doc(alias = "VkSurfaceCapabilities2KHR")]
pub struct SurfaceCapabilities2KHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub surface_capabilities: SurfaceCapabilitiesKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SurfaceCapabilities2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SurfaceCapabilities2KHR;
}
unsafe impl<'a> Send for SurfaceCapabilities2KHR<'a> {}
unsafe impl<'a> Sync for SurfaceCapabilities2KHR<'a> {}
impl<'a> Default for SurfaceCapabilities2KHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            surface_capabilities: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SurfaceCapabilities2KHR<'a> {
    #[inline]
    pub fn surface_capabilities(mut self, value: SurfaceCapabilitiesKHR) -> Self {
        self.surface_capabilities = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormat2KHR.html>"]
#[doc(alias = "VkSurfaceFormat2KHR")]
pub struct SurfaceFormat2KHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub surface_format: SurfaceFormatKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SurfaceFormat2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SurfaceFormat2KHR;
}
unsafe impl<'a> Send for SurfaceFormat2KHR<'a> {}
unsafe impl<'a> Sync for SurfaceFormat2KHR<'a> {}
impl<'a> Default for SurfaceFormat2KHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            surface_format: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SurfaceFormat2KHR<'a> {
    #[inline]
    pub fn surface_format(mut self, value: SurfaceFormatKHR) -> Self {
        self.surface_format = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayProperties2KHR.html>"]
#[doc(alias = "VkDisplayProperties2KHR")]
pub struct DisplayProperties2KHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub display_properties: DisplayPropertiesKHR<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DisplayProperties2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DisplayProperties2KHR;
}
unsafe impl<'a> Send for DisplayProperties2KHR<'a> {}
unsafe impl<'a> Sync for DisplayProperties2KHR<'a> {}
impl<'a> Default for DisplayProperties2KHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            display_properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayProperties2KHR<'a> {
    #[inline]
    pub fn display_properties(mut self, value: DisplayPropertiesKHR<'a>) -> Self {
        self.display_properties = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneProperties2KHR.html>"]
#[doc(alias = "VkDisplayPlaneProperties2KHR")]
pub struct DisplayPlaneProperties2KHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub display_plane_properties: DisplayPlanePropertiesKHR<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DisplayPlaneProperties2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DisplayPlaneProperties2KHR;
}
unsafe impl<'a> Send for DisplayPlaneProperties2KHR<'a> {}
unsafe impl<'a> Sync for DisplayPlaneProperties2KHR<'a> {}
impl<'a> Default for DisplayPlaneProperties2KHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            display_plane_properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayPlaneProperties2KHR<'a> {
    #[inline]
    pub fn display_plane_properties(mut self, value: DisplayPlanePropertiesKHR<'a>) -> Self {
        self.display_plane_properties = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeProperties2KHR.html>"]
#[doc(alias = "VkDisplayModeProperties2KHR")]
pub struct DisplayModeProperties2KHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub display_mode_properties: DisplayModePropertiesKHR<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DisplayModeProperties2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DisplayModeProperties2KHR;
}
unsafe impl<'a> Send for DisplayModeProperties2KHR<'a> {}
unsafe impl<'a> Sync for DisplayModeProperties2KHR<'a> {}
impl<'a> Default for DisplayModeProperties2KHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            display_mode_properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayModeProperties2KHR<'a> {
    #[inline]
    pub fn display_mode_properties(mut self, value: DisplayModePropertiesKHR<'a>) -> Self {
        self.display_mode_properties = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneInfo2KHR.html>"]
#[doc(alias = "VkDisplayPlaneInfo2KHR")]
pub struct DisplayPlaneInfo2KHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub mode: Option<DisplayModeKHR>,
    pub plane_index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DisplayPlaneInfo2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DisplayPlaneInfo2KHR;
}
unsafe impl<'a> Send for DisplayPlaneInfo2KHR<'a> {}
unsafe impl<'a> Sync for DisplayPlaneInfo2KHR<'a> {}
impl<'a> Default for DisplayPlaneInfo2KHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            mode: Default::default(),
            plane_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayPlaneInfo2KHR<'a> {
    #[inline]
    pub fn mode(mut self, value: &'a DisplayModeKHR) -> Self {
        self.mode = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn plane_index(mut self, value: u32) -> Self {
        self.plane_index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneCapabilities2KHR.html>"]
#[doc(alias = "VkDisplayPlaneCapabilities2KHR")]
pub struct DisplayPlaneCapabilities2KHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub capabilities: DisplayPlaneCapabilitiesKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DisplayPlaneCapabilities2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DisplayPlaneCapabilities2KHR;
}
unsafe impl<'a> Send for DisplayPlaneCapabilities2KHR<'a> {}
unsafe impl<'a> Sync for DisplayPlaneCapabilities2KHR<'a> {}
impl<'a> Default for DisplayPlaneCapabilities2KHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            capabilities: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayPlaneCapabilities2KHR<'a> {
    #[inline]
    pub fn capabilities(mut self, value: DisplayPlaneCapabilitiesKHR) -> Self {
        self.capabilities = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIOSSurfaceCreateInfoMVK.html>"]
#[doc(alias = "VkIOSSurfaceCreateInfoMVK")]
pub struct IOSSurfaceCreateInfoMVK<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub p_view: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for IOSSurfaceCreateInfoMVK<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IosSurfaceCreateInfoMVK;
}
unsafe impl<'a> Send for IOSSurfaceCreateInfoMVK<'a> {}
unsafe impl<'a> Sync for IOSSurfaceCreateInfoMVK<'a> {}
impl<'a> Default for IOSSurfaceCreateInfoMVK<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            p_view: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> IOSSurfaceCreateInfoMVK<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn view(mut self, value: VoidPtr) -> Self {
        self.p_view = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMacOSSurfaceCreateInfoMVK.html>"]
#[doc(alias = "VkMacOSSurfaceCreateInfoMVK")]
pub struct MacOSSurfaceCreateInfoMVK<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub p_view: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MacOSSurfaceCreateInfoMVK<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MacosSurfaceCreateInfoMVK;
}
unsafe impl<'a> Send for MacOSSurfaceCreateInfoMVK<'a> {}
unsafe impl<'a> Sync for MacOSSurfaceCreateInfoMVK<'a> {}
impl<'a> Default for MacOSSurfaceCreateInfoMVK<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            p_view: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MacOSSurfaceCreateInfoMVK<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn view(mut self, value: VoidPtr) -> Self {
        self.p_view = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsLabelEXT.html>"]
#[doc(alias = "VkDebugUtilsLabelEXT")]
pub struct DebugUtilsLabelEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_label_name: *const c_char,
    pub color: [f32; 4u16 as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DebugUtilsLabelEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DebugUtilsLabelEXT;
}
unsafe impl<'a> Send for DebugUtilsLabelEXT<'a> {}
unsafe impl<'a> Sync for DebugUtilsLabelEXT<'a> {}
impl<'a> Default for DebugUtilsLabelEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_label_name: ptr::null(),
            color: array::from_fn(|_| Default::default()),
            phantom: PhantomData,
        }
    }
}
impl<'a> DebugUtilsLabelEXT<'a> {
    #[inline]
    pub fn label_name(mut self, value: &'a CStr) -> Self {
        self.p_label_name = value.as_ptr();
        self
    }
    #[inline]
    pub fn color(mut self, value: [f32; 4u16 as _]) -> Self {
        self.color = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCallbackDataEXT.html>"]
#[doc(alias = "VkDebugUtilsMessengerCallbackDataEXT")]
pub struct DebugUtilsMessengerCallbackDataEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub p_message_id_name: *const c_char,
    pub message_id_number: i32,
    pub p_message: *const c_char,
    pub(crate) queue_label_count: u32,
    pub(crate) p_queue_labels: *const DebugUtilsLabelEXT<'a>,
    pub(crate) cmd_buf_label_count: u32,
    pub(crate) p_cmd_buf_labels: *const DebugUtilsLabelEXT<'a>,
    pub(crate) object_count: u32,
    pub(crate) p_objects: *const DebugUtilsObjectNameInfoEXT<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DebugUtilsMessengerCallbackDataEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DebugUtilsMessengerCallbackDataEXT;
}
unsafe impl<'a> Send for DebugUtilsMessengerCallbackDataEXT<'a> {}
unsafe impl<'a> Sync for DebugUtilsMessengerCallbackDataEXT<'a> {}
impl<'a> Default for DebugUtilsMessengerCallbackDataEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            p_message_id_name: ptr::null(),
            message_id_number: Default::default(),
            p_message: ptr::null(),
            queue_label_count: Default::default(),
            p_queue_labels: ptr::null(),
            cmd_buf_label_count: Default::default(),
            p_cmd_buf_labels: ptr::null(),
            object_count: Default::default(),
            p_objects: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DebugUtilsMessengerCallbackDataEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn message_id_name(mut self, value: Option<&'a CStr>) -> Self {
        self.p_message_id_name = value.map(|v| v.as_ptr()).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn message_id_number(mut self, value: i32) -> Self {
        self.message_id_number = value;
        self
    }
    #[inline]
    pub fn message(mut self, value: Option<&'a CStr>) -> Self {
        self.p_message = value.map(|v| v.as_ptr()).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn queue_labels(
        mut self,
        p_queue_labels: impl AsSlice<'a, DebugUtilsLabelEXT<'a>>,
    ) -> Self {
        self.p_queue_labels = p_queue_labels.as_slice().as_ptr().cast();
        self.queue_label_count = p_queue_labels.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn cmd_buf_labels(
        mut self,
        p_cmd_buf_labels: impl AsSlice<'a, DebugUtilsLabelEXT<'a>>,
    ) -> Self {
        self.p_cmd_buf_labels = p_cmd_buf_labels.as_slice().as_ptr().cast();
        self.cmd_buf_label_count = p_cmd_buf_labels.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn objects(mut self, p_objects: impl AsSlice<'a, DebugUtilsObjectNameInfoEXT<'a>>) -> Self {
        self.p_objects = p_objects.as_slice().as_ptr().cast();
        self.object_count = p_objects.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html>"]
#[doc(alias = "VkDebugUtilsMessengerCreateInfoEXT")]
pub struct DebugUtilsMessengerCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub message_severity: DebugUtilsMessageSeverityFlagsEXT,
    pub message_type: DebugUtilsMessageTypeFlagsEXT,
    pub pfn_user_callback: DebugUtilsMessengerCallbackEXT,
    pub p_user_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DebugUtilsMessengerCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DebugUtilsMessengerCreateInfoEXT;
}
unsafe impl<'a> Send for DebugUtilsMessengerCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for DebugUtilsMessengerCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<InstanceCreateInfo<'b>>
    for DebugUtilsMessengerCreateInfoEXT<'a>
{
}
impl<'a> Default for DebugUtilsMessengerCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            message_severity: Default::default(),
            message_type: Default::default(),
            pfn_user_callback: Default::default(),
            p_user_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DebugUtilsMessengerCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn message_severity(mut self, value: DebugUtilsMessageSeverityFlagsEXT) -> Self {
        self.message_severity = value;
        self
    }
    #[inline]
    pub fn message_type(mut self, value: DebugUtilsMessageTypeFlagsEXT) -> Self {
        self.message_type = value;
        self
    }
    #[inline]
    pub fn pfn_user_callback(mut self, value: DebugUtilsMessengerCallbackEXT) -> Self {
        self.pfn_user_callback = value;
        self
    }
    #[inline]
    pub fn user_data(mut self, value: VoidPtr) -> Self {
        self.p_user_data = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsObjectNameInfoEXT.html>"]
#[doc(alias = "VkDebugUtilsObjectNameInfoEXT")]
pub struct DebugUtilsObjectNameInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub p_object_name: *const c_char,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DebugUtilsObjectNameInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DebugUtilsObjectNameInfoEXT;
}
unsafe impl<'a> Send for DebugUtilsObjectNameInfoEXT<'a> {}
unsafe impl<'a> Sync for DebugUtilsObjectNameInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineShaderStageCreateInfo<'b>>
    for DebugUtilsObjectNameInfoEXT<'a>
{
}
impl<'a> Default for DebugUtilsObjectNameInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            object_type: ObjectType::Unknown,
            object_handle: Default::default(),
            p_object_name: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DebugUtilsObjectNameInfoEXT<'a> {
    #[inline]
    pub fn object_type(mut self, value: ObjectType) -> Self {
        self.object_type = value;
        self
    }
    #[inline]
    pub fn object_handle(mut self, value: u64) -> Self {
        self.object_handle = value;
        self
    }
    #[inline]
    pub fn object_name(mut self, value: Option<&'a CStr>) -> Self {
        self.p_object_name = value.map(|v| v.as_ptr()).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsObjectTagInfoEXT.html>"]
#[doc(alias = "VkDebugUtilsObjectTagInfoEXT")]
pub struct DebugUtilsObjectTagInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub tag_name: u64,
    pub(crate) tag_size: usize,
    pub(crate) p_tag: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DebugUtilsObjectTagInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DebugUtilsObjectTagInfoEXT;
}
unsafe impl<'a> Send for DebugUtilsObjectTagInfoEXT<'a> {}
unsafe impl<'a> Sync for DebugUtilsObjectTagInfoEXT<'a> {}
impl<'a> Default for DebugUtilsObjectTagInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            object_type: ObjectType::Unknown,
            object_handle: Default::default(),
            tag_name: Default::default(),
            tag_size: Default::default(),
            p_tag: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DebugUtilsObjectTagInfoEXT<'a> {
    #[inline]
    pub fn object_type(mut self, value: ObjectType) -> Self {
        self.object_type = value;
        self
    }
    #[inline]
    pub fn object_handle(mut self, value: u64) -> Self {
        self.object_handle = value;
        self
    }
    #[inline]
    pub fn tag_name(mut self, value: u64) -> Self {
        self.tag_name = value;
        self
    }
    #[inline]
    pub fn tag(mut self, p_tag: impl AsSlice<'a, u8>) -> Self {
        self.p_tag = p_tag.as_slice().as_ptr().cast();
        self.tag_size = p_tag.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferUsageANDROID.html>"]
#[doc(alias = "VkAndroidHardwareBufferUsageANDROID")]
pub struct AndroidHardwareBufferUsageANDROID<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub android_hardware_buffer_usage: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AndroidHardwareBufferUsageANDROID<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AndroidHardwareBufferUsageANDROID;
}
unsafe impl<'a> Send for AndroidHardwareBufferUsageANDROID<'a> {}
unsafe impl<'a> Sync for AndroidHardwareBufferUsageANDROID<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageFormatProperties2<'b>>
    for AndroidHardwareBufferUsageANDROID<'a>
{
}
impl<'a> Default for AndroidHardwareBufferUsageANDROID<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            android_hardware_buffer_usage: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AndroidHardwareBufferUsageANDROID<'a> {
    #[inline]
    pub fn android_hardware_buffer_usage(mut self, value: u64) -> Self {
        self.android_hardware_buffer_usage = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferPropertiesANDROID.html>"]
#[doc(alias = "VkAndroidHardwareBufferPropertiesANDROID")]
pub struct AndroidHardwareBufferPropertiesANDROID<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub allocation_size: DeviceSize,
    pub memory_type_bits: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AndroidHardwareBufferPropertiesANDROID<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AndroidHardwareBufferPropertiesANDROID;
}
unsafe impl<'a> Send for AndroidHardwareBufferPropertiesANDROID<'a> {}
unsafe impl<'a> Sync for AndroidHardwareBufferPropertiesANDROID<'a> {}
impl<'a> Default for AndroidHardwareBufferPropertiesANDROID<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            allocation_size: Default::default(),
            memory_type_bits: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AndroidHardwareBufferPropertiesANDROID<'a> {
    #[inline]
    pub fn allocation_size(mut self, value: DeviceSize) -> Self {
        self.allocation_size = value;
        self
    }
    #[inline]
    pub fn memory_type_bits(mut self, value: u32) -> Self {
        self.memory_type_bits = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferFormatPropertiesANDROID.html>"]
#[doc(alias = "VkAndroidHardwareBufferFormatPropertiesANDROID")]
pub struct AndroidHardwareBufferFormatPropertiesANDROID<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub format: Format,
    pub external_format: u64,
    pub format_features: FormatFeatureFlags,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_xchroma_offset: ChromaLocation,
    pub suggested_ychroma_offset: ChromaLocation,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AndroidHardwareBufferFormatPropertiesANDROID<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::AndroidHardwareBufferFormatPropertiesANDROID;
}
unsafe impl<'a> Send for AndroidHardwareBufferFormatPropertiesANDROID<'a> {}
unsafe impl<'a> Sync for AndroidHardwareBufferFormatPropertiesANDROID<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<AndroidHardwareBufferPropertiesANDROID<'b>>
    for AndroidHardwareBufferFormatPropertiesANDROID<'a>
{
}
impl<'a> Default for AndroidHardwareBufferFormatPropertiesANDROID<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            format: Format::Undefined,
            external_format: Default::default(),
            format_features: Default::default(),
            sampler_ycbcr_conversion_components: Default::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::RgbIdentity,
            suggested_ycbcr_range: SamplerYcbcrRange::ItuFull,
            suggested_xchroma_offset: ChromaLocation::CositedEven,
            suggested_ychroma_offset: ChromaLocation::CositedEven,
            phantom: PhantomData,
        }
    }
}
impl<'a> AndroidHardwareBufferFormatPropertiesANDROID<'a> {
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn external_format(mut self, value: u64) -> Self {
        self.external_format = value;
        self
    }
    #[inline]
    pub fn format_features(mut self, value: FormatFeatureFlags) -> Self {
        self.format_features = value;
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion_components(mut self, value: ComponentMapping) -> Self {
        self.sampler_ycbcr_conversion_components = value;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_model(mut self, value: SamplerYcbcrModelConversion) -> Self {
        self.suggested_ycbcr_model = value;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_range(mut self, value: SamplerYcbcrRange) -> Self {
        self.suggested_ycbcr_range = value;
        self
    }
    #[inline]
    pub fn suggested_xchroma_offset(mut self, value: ChromaLocation) -> Self {
        self.suggested_xchroma_offset = value;
        self
    }
    #[inline]
    pub fn suggested_ychroma_offset(mut self, value: ChromaLocation) -> Self {
        self.suggested_ychroma_offset = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportAndroidHardwareBufferInfoANDROID.html>"]
#[doc(alias = "VkImportAndroidHardwareBufferInfoANDROID")]
pub struct ImportAndroidHardwareBufferInfoANDROID<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub buffer: *const AHardwareBuffer,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportAndroidHardwareBufferInfoANDROID<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportAndroidHardwareBufferInfoANDROID;
}
unsafe impl<'a> Send for ImportAndroidHardwareBufferInfoANDROID<'a> {}
unsafe impl<'a> Sync for ImportAndroidHardwareBufferInfoANDROID<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>>
    for ImportAndroidHardwareBufferInfoANDROID<'a>
{
}
impl<'a> Default for ImportAndroidHardwareBufferInfoANDROID<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            buffer: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportAndroidHardwareBufferInfoANDROID<'a> {
    #[inline]
    pub fn buffer(mut self, value: &'a AHardwareBuffer) -> Self {
        self.buffer = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetAndroidHardwareBufferInfoANDROID.html>"]
#[doc(alias = "VkMemoryGetAndroidHardwareBufferInfoANDROID")]
pub struct MemoryGetAndroidHardwareBufferInfoANDROID<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory: Option<DeviceMemory>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryGetAndroidHardwareBufferInfoANDROID<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryGetAndroidHardwareBufferInfoANDROID;
}
unsafe impl<'a> Send for MemoryGetAndroidHardwareBufferInfoANDROID<'a> {}
unsafe impl<'a> Sync for MemoryGetAndroidHardwareBufferInfoANDROID<'a> {}
impl<'a> Default for MemoryGetAndroidHardwareBufferInfoANDROID<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryGetAndroidHardwareBufferInfoANDROID<'a> {
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFormatANDROID.html>"]
#[doc(alias = "VkExternalFormatANDROID")]
pub struct ExternalFormatANDROID<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub external_format: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExternalFormatANDROID<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExternalFormatANDROID;
}
unsafe impl<'a> Send for ExternalFormatANDROID<'a> {}
unsafe impl<'a> Sync for ExternalFormatANDROID<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>> for ExternalFormatANDROID<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SamplerYcbcrConversionCreateInfo<'b>>
    for ExternalFormatANDROID<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<AttachmentDescription2<'b>> for ExternalFormatANDROID<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for ExternalFormatANDROID<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<CommandBufferInheritanceInfo<'b>>
    for ExternalFormatANDROID<'a>
{
}
impl<'a> Default for ExternalFormatANDROID<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            external_format: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExternalFormatANDROID<'a> {
    #[inline]
    pub fn external_format(mut self, value: u64) -> Self {
        self.external_format = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/AHardwareBuffer.html>"]
pub type AHardwareBuffer = c_void;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferFormatProperties2ANDROID.html>"]
#[doc(alias = "VkAndroidHardwareBufferFormatProperties2ANDROID")]
pub struct AndroidHardwareBufferFormatProperties2ANDROID<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub format: Format,
    pub external_format: u64,
    pub format_features: u32,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_xchroma_offset: ChromaLocation,
    pub suggested_ychroma_offset: ChromaLocation,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AndroidHardwareBufferFormatProperties2ANDROID<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::AndroidHardwareBufferFormatProperties2ANDROID;
}
unsafe impl<'a> Send for AndroidHardwareBufferFormatProperties2ANDROID<'a> {}
unsafe impl<'a> Sync for AndroidHardwareBufferFormatProperties2ANDROID<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<AndroidHardwareBufferPropertiesANDROID<'b>>
    for AndroidHardwareBufferFormatProperties2ANDROID<'a>
{
}
impl<'a> Default for AndroidHardwareBufferFormatProperties2ANDROID<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            format: Format::Undefined,
            external_format: Default::default(),
            format_features: Default::default(),
            sampler_ycbcr_conversion_components: Default::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::RgbIdentity,
            suggested_ycbcr_range: SamplerYcbcrRange::ItuFull,
            suggested_xchroma_offset: ChromaLocation::CositedEven,
            suggested_ychroma_offset: ChromaLocation::CositedEven,
            phantom: PhantomData,
        }
    }
}
impl<'a> AndroidHardwareBufferFormatProperties2ANDROID<'a> {
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn external_format(mut self, value: u64) -> Self {
        self.external_format = value;
        self
    }
    #[inline]
    pub fn format_features(mut self, value: u32) -> Self {
        self.format_features = value;
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion_components(mut self, value: ComponentMapping) -> Self {
        self.sampler_ycbcr_conversion_components = value;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_model(mut self, value: SamplerYcbcrModelConversion) -> Self {
        self.suggested_ycbcr_model = value;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_range(mut self, value: SamplerYcbcrRange) -> Self {
        self.suggested_ycbcr_range = value;
        self
    }
    #[inline]
    pub fn suggested_xchroma_offset(mut self, value: ChromaLocation) -> Self {
        self.suggested_xchroma_offset = value;
        self
    }
    #[inline]
    pub fn suggested_ychroma_offset(mut self, value: ChromaLocation) -> Self {
        self.suggested_ychroma_offset = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderEnqueueFeaturesAMDX.html>"]
#[doc(alias = "VkPhysicalDeviceShaderEnqueueFeaturesAMDX")]
pub struct PhysicalDeviceShaderEnqueueFeaturesAMDX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_enqueue: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderEnqueueFeaturesAMDX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderEnqueueFeaturesAMDX;
}
unsafe impl<'a> Send for PhysicalDeviceShaderEnqueueFeaturesAMDX<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderEnqueueFeaturesAMDX<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderEnqueueFeaturesAMDX<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderEnqueueFeaturesAMDX<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderEnqueueFeaturesAMDX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_enqueue: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderEnqueueFeaturesAMDX<'a> {
    #[inline]
    pub fn shader_enqueue(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_enqueue = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderEnqueuePropertiesAMDX.html>"]
#[doc(alias = "VkPhysicalDeviceShaderEnqueuePropertiesAMDX")]
pub struct PhysicalDeviceShaderEnqueuePropertiesAMDX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_execution_graph_depth: u32,
    pub max_execution_graph_shader_output_nodes: u32,
    pub max_execution_graph_shader_payload_size: u32,
    pub max_execution_graph_shader_payload_count: u32,
    pub execution_graph_dispatch_address_alignment: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderEnqueuePropertiesAMDX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderEnqueuePropertiesAMDX;
}
unsafe impl<'a> Send for PhysicalDeviceShaderEnqueuePropertiesAMDX<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderEnqueuePropertiesAMDX<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceShaderEnqueuePropertiesAMDX<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderEnqueuePropertiesAMDX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_execution_graph_depth: Default::default(),
            max_execution_graph_shader_output_nodes: Default::default(),
            max_execution_graph_shader_payload_size: Default::default(),
            max_execution_graph_shader_payload_count: Default::default(),
            execution_graph_dispatch_address_alignment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderEnqueuePropertiesAMDX<'a> {
    #[inline]
    pub fn max_execution_graph_depth(mut self, value: u32) -> Self {
        self.max_execution_graph_depth = value;
        self
    }
    #[inline]
    pub fn max_execution_graph_shader_output_nodes(mut self, value: u32) -> Self {
        self.max_execution_graph_shader_output_nodes = value;
        self
    }
    #[inline]
    pub fn max_execution_graph_shader_payload_size(mut self, value: u32) -> Self {
        self.max_execution_graph_shader_payload_size = value;
        self
    }
    #[inline]
    pub fn max_execution_graph_shader_payload_count(mut self, value: u32) -> Self {
        self.max_execution_graph_shader_payload_count = value;
        self
    }
    #[inline]
    pub fn execution_graph_dispatch_address_alignment(mut self, value: u32) -> Self {
        self.execution_graph_dispatch_address_alignment = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExecutionGraphPipelineScratchSizeAMDX.html>"]
#[doc(alias = "VkExecutionGraphPipelineScratchSizeAMDX")]
pub struct ExecutionGraphPipelineScratchSizeAMDX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExecutionGraphPipelineScratchSizeAMDX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExecutionGraphPipelineScratchSizeAMDX;
}
unsafe impl<'a> Send for ExecutionGraphPipelineScratchSizeAMDX<'a> {}
unsafe impl<'a> Sync for ExecutionGraphPipelineScratchSizeAMDX<'a> {}
impl<'a> Default for ExecutionGraphPipelineScratchSizeAMDX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExecutionGraphPipelineScratchSizeAMDX<'a> {
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExecutionGraphPipelineCreateInfoAMDX.html>"]
#[doc(alias = "VkExecutionGraphPipelineCreateInfoAMDX")]
pub struct ExecutionGraphPipelineCreateInfoAMDX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    pub(crate) p_stages: *const PipelineShaderStageCreateInfo<'a>,
    pub p_library_info: *const PipelineLibraryCreateInfoKHR<'a>,
    pub layout: Option<PipelineLayout>,
    pub base_pipeline_handle: Option<Pipeline>,
    pub base_pipeline_index: i32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExecutionGraphPipelineCreateInfoAMDX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExecutionGraphPipelineCreateInfoAMDX;
}
unsafe impl<'a> Send for ExecutionGraphPipelineCreateInfoAMDX<'a> {}
unsafe impl<'a> Sync for ExecutionGraphPipelineCreateInfoAMDX<'a> {}
impl<'a> Default for ExecutionGraphPipelineCreateInfoAMDX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            stage_count: Default::default(),
            p_stages: ptr::null(),
            p_library_info: ptr::null(),
            layout: Default::default(),
            base_pipeline_handle: Default::default(),
            base_pipeline_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExecutionGraphPipelineCreateInfoAMDX<'a> {
    #[inline]
    pub fn flags(mut self, value: PipelineCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn stage_count(mut self, value: u32) -> Self {
        self.stage_count = value;
        self
    }
    #[inline]
    pub fn library_info(mut self, value: Option<&'a PipelineLibraryCreateInfoKHR<'a>>) -> Self {
        self.p_library_info = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn layout(mut self, value: &'a PipelineLayout) -> Self {
        self.layout = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, value: Option<&'a Pipeline>) -> Self {
        self.base_pipeline_handle = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, value: i32) -> Self {
        self.base_pipeline_index = value;
        self
    }
    #[inline]
    pub fn stages(mut self, p_stages: impl AsSlice<'a, PipelineShaderStageCreateInfo<'a>>) -> Self {
        self.p_stages = p_stages.as_slice().as_ptr().cast();
        self.stage_count = p_stages.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDispatchGraphInfoAMDX.html>"]
#[doc(alias = "VkDispatchGraphInfoAMDX")]
pub struct DispatchGraphInfoAMDX {
    pub node_index: u32,
    pub payload_count: u32,
    pub payloads: DeviceOrHostAddressConstAMDX,
    pub payload_stride: u64,
}
unsafe impl Send for DispatchGraphInfoAMDX {}
unsafe impl Sync for DispatchGraphInfoAMDX {}
impl Default for DispatchGraphInfoAMDX {
    fn default() -> Self {
        Self {
            node_index: Default::default(),
            payload_count: Default::default(),
            payloads: Default::default(),
            payload_stride: Default::default(),
        }
    }
}
impl DispatchGraphInfoAMDX {
    #[inline]
    pub fn node_index(mut self, value: u32) -> Self {
        self.node_index = value;
        self
    }
    #[inline]
    pub fn payload_count(mut self, value: u32) -> Self {
        self.payload_count = value;
        self
    }
    #[inline]
    pub fn payloads(mut self, value: DeviceOrHostAddressConstAMDX) -> Self {
        self.payloads = value;
        self
    }
    #[inline]
    pub fn payload_stride(mut self, value: u64) -> Self {
        self.payload_stride = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDispatchGraphCountInfoAMDX.html>"]
#[doc(alias = "VkDispatchGraphCountInfoAMDX")]
pub struct DispatchGraphCountInfoAMDX {
    pub count: u32,
    pub infos: DeviceOrHostAddressConstAMDX,
    pub stride: u64,
}
unsafe impl Send for DispatchGraphCountInfoAMDX {}
unsafe impl Sync for DispatchGraphCountInfoAMDX {}
impl Default for DispatchGraphCountInfoAMDX {
    fn default() -> Self {
        Self {
            count: Default::default(),
            infos: Default::default(),
            stride: Default::default(),
        }
    }
}
impl DispatchGraphCountInfoAMDX {
    #[inline]
    pub fn count(mut self, value: u32) -> Self {
        self.count = value;
        self
    }
    #[inline]
    pub fn infos(mut self, value: DeviceOrHostAddressConstAMDX) -> Self {
        self.infos = value;
        self
    }
    #[inline]
    pub fn stride(mut self, value: u64) -> Self {
        self.stride = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageNodeCreateInfoAMDX.html>"]
#[doc(alias = "VkPipelineShaderStageNodeCreateInfoAMDX")]
pub struct PipelineShaderStageNodeCreateInfoAMDX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_name: *const c_char,
    pub index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineShaderStageNodeCreateInfoAMDX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineShaderStageNodeCreateInfoAMDX;
}
unsafe impl<'a> Send for PipelineShaderStageNodeCreateInfoAMDX<'a> {}
unsafe impl<'a> Sync for PipelineShaderStageNodeCreateInfoAMDX<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineShaderStageCreateInfo<'b>>
    for PipelineShaderStageNodeCreateInfoAMDX<'a>
{
}
impl<'a> Default for PipelineShaderStageNodeCreateInfoAMDX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_name: ptr::null(),
            index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineShaderStageNodeCreateInfoAMDX<'a> {
    #[inline]
    pub fn name(mut self, value: Option<&'a CStr>) -> Self {
        self.p_name = value.map(|v| v.as_ptr()).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn index(mut self, value: u32) -> Self {
        self.index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceOrHostAddressConstAMDX.html>"]
#[doc(alias = "VkDeviceOrHostAddressConstAMDX")]
pub union DeviceOrHostAddressConstAMDX {
    pub device_address: DeviceAddress,
    pub host_address: VoidPtr,
}
impl Default for DeviceOrHostAddressConstAMDX {
    fn default() -> Self {
        Self {
            device_address: Default::default(),
        }
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleLocationEXT.html>"]
#[doc(alias = "VkSampleLocationEXT")]
pub struct SampleLocationEXT {
    pub x: f32,
    pub y: f32,
}
unsafe impl Send for SampleLocationEXT {}
unsafe impl Sync for SampleLocationEXT {}
impl Default for SampleLocationEXT {
    fn default() -> Self {
        Self {
            x: Default::default(),
            y: Default::default(),
        }
    }
}
impl SampleLocationEXT {
    #[inline]
    pub fn x(mut self, value: f32) -> Self {
        self.x = value;
        self
    }
    #[inline]
    pub fn y(mut self, value: f32) -> Self {
        self.y = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleLocationsInfoEXT.html>"]
#[doc(alias = "VkSampleLocationsInfoEXT")]
pub struct SampleLocationsInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub sample_locations_per_pixel: SampleCountFlags,
    pub sample_location_grid_size: Extent2D,
    pub(crate) sample_locations_count: u32,
    pub(crate) p_sample_locations: *const SampleLocationEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SampleLocationsInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SampleLocationsInfoEXT;
}
unsafe impl<'a> Send for SampleLocationsInfoEXT<'a> {}
unsafe impl<'a> Sync for SampleLocationsInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageMemoryBarrier<'b>> for SampleLocationsInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageMemoryBarrier2<'b>> for SampleLocationsInfoEXT<'a> {}
impl<'a> Default for SampleLocationsInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            sample_locations_per_pixel: Default::default(),
            sample_location_grid_size: Default::default(),
            sample_locations_count: Default::default(),
            p_sample_locations: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SampleLocationsInfoEXT<'a> {
    #[inline]
    pub fn sample_locations_per_pixel(mut self, value: SampleCountFlags) -> Self {
        self.sample_locations_per_pixel = value;
        self
    }
    #[inline]
    pub fn sample_location_grid_size(mut self, value: Extent2D) -> Self {
        self.sample_location_grid_size = value;
        self
    }
    #[inline]
    pub fn sample_locations(
        mut self,
        p_sample_locations: impl AsSlice<'a, SampleLocationEXT>,
    ) -> Self {
        self.p_sample_locations = p_sample_locations.as_slice().as_ptr().cast();
        self.sample_locations_count = p_sample_locations.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentSampleLocationsEXT.html>"]
#[doc(alias = "VkAttachmentSampleLocationsEXT")]
pub struct AttachmentSampleLocationsEXT<'a> {
    pub attachment_index: u32,
    pub sample_locations_info: SampleLocationsInfoEXT<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for AttachmentSampleLocationsEXT<'a> {}
unsafe impl<'a> Sync for AttachmentSampleLocationsEXT<'a> {}
impl<'a> Default for AttachmentSampleLocationsEXT<'a> {
    fn default() -> Self {
        Self {
            attachment_index: Default::default(),
            sample_locations_info: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AttachmentSampleLocationsEXT<'a> {
    #[inline]
    pub fn attachment_index(mut self, value: u32) -> Self {
        self.attachment_index = value;
        self
    }
    #[inline]
    pub fn sample_locations_info(mut self, value: SampleLocationsInfoEXT<'a>) -> Self {
        self.sample_locations_info = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassSampleLocationsEXT.html>"]
#[doc(alias = "VkSubpassSampleLocationsEXT")]
pub struct SubpassSampleLocationsEXT<'a> {
    pub subpass_index: u32,
    pub sample_locations_info: SampleLocationsInfoEXT<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for SubpassSampleLocationsEXT<'a> {}
unsafe impl<'a> Sync for SubpassSampleLocationsEXT<'a> {}
impl<'a> Default for SubpassSampleLocationsEXT<'a> {
    fn default() -> Self {
        Self {
            subpass_index: Default::default(),
            sample_locations_info: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubpassSampleLocationsEXT<'a> {
    #[inline]
    pub fn subpass_index(mut self, value: u32) -> Self {
        self.subpass_index = value;
        self
    }
    #[inline]
    pub fn sample_locations_info(mut self, value: SampleLocationsInfoEXT<'a>) -> Self {
        self.sample_locations_info = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassSampleLocationsBeginInfoEXT.html>"]
#[doc(alias = "VkRenderPassSampleLocationsBeginInfoEXT")]
pub struct RenderPassSampleLocationsBeginInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) attachment_initial_sample_locations_count: u32,
    pub(crate) p_attachment_initial_sample_locations: *const AttachmentSampleLocationsEXT<'a>,
    pub(crate) post_subpass_sample_locations_count: u32,
    pub(crate) p_post_subpass_sample_locations: *const SubpassSampleLocationsEXT<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassSampleLocationsBeginInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassSampleLocationsBeginInfoEXT;
}
unsafe impl<'a> Send for RenderPassSampleLocationsBeginInfoEXT<'a> {}
unsafe impl<'a> Sync for RenderPassSampleLocationsBeginInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderPassBeginInfo<'b>>
    for RenderPassSampleLocationsBeginInfoEXT<'a>
{
}
impl<'a> Default for RenderPassSampleLocationsBeginInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            attachment_initial_sample_locations_count: Default::default(),
            p_attachment_initial_sample_locations: ptr::null(),
            post_subpass_sample_locations_count: Default::default(),
            p_post_subpass_sample_locations: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassSampleLocationsBeginInfoEXT<'a> {
    #[inline]
    pub fn attachment_initial_sample_locations(
        mut self,
        p_attachment_initial_sample_locations: impl AsSlice<'a, AttachmentSampleLocationsEXT<'a>>,
    ) -> Self {
        self.p_attachment_initial_sample_locations = p_attachment_initial_sample_locations
            .as_slice()
            .as_ptr()
            .cast();
        self.attachment_initial_sample_locations_count =
            p_attachment_initial_sample_locations.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn post_subpass_sample_locations(
        mut self,
        p_post_subpass_sample_locations: impl AsSlice<'a, SubpassSampleLocationsEXT<'a>>,
    ) -> Self {
        self.p_post_subpass_sample_locations =
            p_post_subpass_sample_locations.as_slice().as_ptr().cast();
        self.post_subpass_sample_locations_count =
            p_post_subpass_sample_locations.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineSampleLocationsStateCreateInfoEXT.html>"]
#[doc(alias = "VkPipelineSampleLocationsStateCreateInfoEXT")]
pub struct PipelineSampleLocationsStateCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub sample_locations_enable: Bool32,
    pub sample_locations_info: SampleLocationsInfoEXT<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineSampleLocationsStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineSampleLocationsStateCreateInfoEXT;
}
unsafe impl<'a> Send for PipelineSampleLocationsStateCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for PipelineSampleLocationsStateCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineMultisampleStateCreateInfo<'b>>
    for PipelineSampleLocationsStateCreateInfoEXT<'a>
{
}
impl<'a> Default for PipelineSampleLocationsStateCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            sample_locations_enable: Default::default(),
            sample_locations_info: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineSampleLocationsStateCreateInfoEXT<'a> {
    #[inline]
    pub fn sample_locations_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.sample_locations_enable = value.into();
        self
    }
    #[inline]
    pub fn sample_locations_info(mut self, value: SampleLocationsInfoEXT<'a>) -> Self {
        self.sample_locations_info = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSampleLocationsPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceSampleLocationsPropertiesEXT")]
pub struct PhysicalDeviceSampleLocationsPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub sample_location_sample_counts: SampleCountFlags,
    pub max_sample_location_grid_size: Extent2D,
    pub sample_location_coordinate_range: [f32; 2u16 as _],
    pub sample_location_sub_pixel_bits: u32,
    pub variable_sample_locations: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSampleLocationsPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceSampleLocationsPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceSampleLocationsPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSampleLocationsPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceSampleLocationsPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceSampleLocationsPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            sample_location_sample_counts: Default::default(),
            max_sample_location_grid_size: Default::default(),
            sample_location_coordinate_range: array::from_fn(|_| Default::default()),
            sample_location_sub_pixel_bits: Default::default(),
            variable_sample_locations: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSampleLocationsPropertiesEXT<'a> {
    #[inline]
    pub fn sample_location_sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.sample_location_sample_counts = value;
        self
    }
    #[inline]
    pub fn max_sample_location_grid_size(mut self, value: Extent2D) -> Self {
        self.max_sample_location_grid_size = value;
        self
    }
    #[inline]
    pub fn sample_location_coordinate_range(mut self, value: [f32; 2u16 as _]) -> Self {
        self.sample_location_coordinate_range = value;
        self
    }
    #[inline]
    pub fn sample_location_sub_pixel_bits(mut self, value: u32) -> Self {
        self.sample_location_sub_pixel_bits = value;
        self
    }
    #[inline]
    pub fn variable_sample_locations(mut self, value: impl Into<Bool32>) -> Self {
        self.variable_sample_locations = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultisamplePropertiesEXT.html>"]
#[doc(alias = "VkMultisamplePropertiesEXT")]
pub struct MultisamplePropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_sample_location_grid_size: Extent2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MultisamplePropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MultisamplePropertiesEXT;
}
unsafe impl<'a> Send for MultisamplePropertiesEXT<'a> {}
unsafe impl<'a> Sync for MultisamplePropertiesEXT<'a> {}
impl<'a> Default for MultisamplePropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_sample_location_grid_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MultisamplePropertiesEXT<'a> {
    #[inline]
    pub fn max_sample_location_grid_size(mut self, value: Extent2D) -> Self {
        self.max_sample_location_grid_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT")]
pub struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub advanced_blend_coherent_operations: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceBlendOperationAdvancedFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            advanced_blend_coherent_operations: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'a> {
    #[inline]
    pub fn advanced_blend_coherent_operations(mut self, value: impl Into<Bool32>) -> Self {
        self.advanced_blend_coherent_operations = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT")]
pub struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub advanced_blend_max_color_attachments: u32,
    pub advanced_blend_independent_blend: Bool32,
    pub advanced_blend_non_premultiplied_src_color: Bool32,
    pub advanced_blend_non_premultiplied_dst_color: Bool32,
    pub advanced_blend_correlated_overlap: Bool32,
    pub advanced_blend_all_operations: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceBlendOperationAdvancedPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceBlendOperationAdvancedPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceBlendOperationAdvancedPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceBlendOperationAdvancedPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceBlendOperationAdvancedPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceBlendOperationAdvancedPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            advanced_blend_max_color_attachments: Default::default(),
            advanced_blend_independent_blend: Default::default(),
            advanced_blend_non_premultiplied_src_color: Default::default(),
            advanced_blend_non_premultiplied_dst_color: Default::default(),
            advanced_blend_correlated_overlap: Default::default(),
            advanced_blend_all_operations: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceBlendOperationAdvancedPropertiesEXT<'a> {
    #[inline]
    pub fn advanced_blend_max_color_attachments(mut self, value: u32) -> Self {
        self.advanced_blend_max_color_attachments = value;
        self
    }
    #[inline]
    pub fn advanced_blend_independent_blend(mut self, value: impl Into<Bool32>) -> Self {
        self.advanced_blend_independent_blend = value.into();
        self
    }
    #[inline]
    pub fn advanced_blend_non_premultiplied_src_color(mut self, value: impl Into<Bool32>) -> Self {
        self.advanced_blend_non_premultiplied_src_color = value.into();
        self
    }
    #[inline]
    pub fn advanced_blend_non_premultiplied_dst_color(mut self, value: impl Into<Bool32>) -> Self {
        self.advanced_blend_non_premultiplied_dst_color = value.into();
        self
    }
    #[inline]
    pub fn advanced_blend_correlated_overlap(mut self, value: impl Into<Bool32>) -> Self {
        self.advanced_blend_correlated_overlap = value.into();
        self
    }
    #[inline]
    pub fn advanced_blend_all_operations(mut self, value: impl Into<Bool32>) -> Self {
        self.advanced_blend_all_operations = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendAdvancedStateCreateInfoEXT.html>"]
#[doc(alias = "VkPipelineColorBlendAdvancedStateCreateInfoEXT")]
pub struct PipelineColorBlendAdvancedStateCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src_premultiplied: Bool32,
    pub dst_premultiplied: Bool32,
    pub blend_overlap: BlendOverlapEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineColorBlendAdvancedStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineColorBlendAdvancedStateCreateInfoEXT;
}
unsafe impl<'a> Send for PipelineColorBlendAdvancedStateCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for PipelineColorBlendAdvancedStateCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineColorBlendStateCreateInfo<'b>>
    for PipelineColorBlendAdvancedStateCreateInfoEXT<'a>
{
}
impl<'a> Default for PipelineColorBlendAdvancedStateCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src_premultiplied: Default::default(),
            dst_premultiplied: Default::default(),
            blend_overlap: BlendOverlapEXT::Uncorrelated,
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineColorBlendAdvancedStateCreateInfoEXT<'a> {
    #[inline]
    pub fn src_premultiplied(mut self, value: impl Into<Bool32>) -> Self {
        self.src_premultiplied = value.into();
        self
    }
    #[inline]
    pub fn dst_premultiplied(mut self, value: impl Into<Bool32>) -> Self {
        self.dst_premultiplied = value.into();
        self
    }
    #[inline]
    pub fn blend_overlap(mut self, value: BlendOverlapEXT) -> Self {
        self.blend_overlap = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageToColorStateCreateInfoNV.html>"]
#[doc(alias = "VkPipelineCoverageToColorStateCreateInfoNV")]
pub struct PipelineCoverageToColorStateCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub coverage_to_color_enable: Bool32,
    pub coverage_to_color_location: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineCoverageToColorStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineCoverageToColorStateCreateInfoNV;
}
unsafe impl<'a> Send for PipelineCoverageToColorStateCreateInfoNV<'a> {}
unsafe impl<'a> Sync for PipelineCoverageToColorStateCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineMultisampleStateCreateInfo<'b>>
    for PipelineCoverageToColorStateCreateInfoNV<'a>
{
}
impl<'a> Default for PipelineCoverageToColorStateCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            coverage_to_color_enable: Default::default(),
            coverage_to_color_location: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineCoverageToColorStateCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn coverage_to_color_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.coverage_to_color_enable = value.into();
        self
    }
    #[inline]
    pub fn coverage_to_color_location(mut self, value: u32) -> Self {
        self.coverage_to_color_location = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceOrHostAddressKHR.html>"]
#[doc(alias = "VkDeviceOrHostAddressKHR")]
pub union DeviceOrHostAddressKHR {
    pub device_address: DeviceAddress,
    pub host_address: VoidPtr,
}
impl Default for DeviceOrHostAddressKHR {
    fn default() -> Self {
        Self {
            device_address: Default::default(),
        }
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceOrHostAddressConstKHR.html>"]
#[doc(alias = "VkDeviceOrHostAddressConstKHR")]
pub union DeviceOrHostAddressConstKHR {
    pub device_address: DeviceAddress,
    pub host_address: VoidPtr,
}
impl Default for DeviceOrHostAddressConstKHR {
    fn default() -> Self {
        Self {
            device_address: Default::default(),
        }
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureBuildRangeInfoKHR.html>"]
#[doc(alias = "VkAccelerationStructureBuildRangeInfoKHR")]
pub struct AccelerationStructureBuildRangeInfoKHR {
    pub primitive_count: u32,
    pub primitive_offset: u32,
    pub first_vertex: u32,
    pub transform_offset: u32,
}
unsafe impl Send for AccelerationStructureBuildRangeInfoKHR {}
unsafe impl Sync for AccelerationStructureBuildRangeInfoKHR {}
impl Default for AccelerationStructureBuildRangeInfoKHR {
    fn default() -> Self {
        Self {
            primitive_count: Default::default(),
            primitive_offset: Default::default(),
            first_vertex: Default::default(),
            transform_offset: Default::default(),
        }
    }
}
impl AccelerationStructureBuildRangeInfoKHR {
    #[inline]
    pub fn primitive_count(mut self, value: u32) -> Self {
        self.primitive_count = value;
        self
    }
    #[inline]
    pub fn primitive_offset(mut self, value: u32) -> Self {
        self.primitive_offset = value;
        self
    }
    #[inline]
    pub fn first_vertex(mut self, value: u32) -> Self {
        self.first_vertex = value;
        self
    }
    #[inline]
    pub fn transform_offset(mut self, value: u32) -> Self {
        self.transform_offset = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAabbPositionsKHR.html>"]
#[doc(alias = "VkAabbPositionsKHR")]
pub struct AabbPositionsKHR {
    pub min_x: f32,
    pub min_y: f32,
    pub min_z: f32,
    pub max_x: f32,
    pub max_y: f32,
    pub max_z: f32,
}
unsafe impl Send for AabbPositionsKHR {}
unsafe impl Sync for AabbPositionsKHR {}
impl Default for AabbPositionsKHR {
    fn default() -> Self {
        Self {
            min_x: Default::default(),
            min_y: Default::default(),
            min_z: Default::default(),
            max_x: Default::default(),
            max_y: Default::default(),
            max_z: Default::default(),
        }
    }
}
impl AabbPositionsKHR {
    #[inline]
    pub fn min_x(mut self, value: f32) -> Self {
        self.min_x = value;
        self
    }
    #[inline]
    pub fn min_y(mut self, value: f32) -> Self {
        self.min_y = value;
        self
    }
    #[inline]
    pub fn min_z(mut self, value: f32) -> Self {
        self.min_z = value;
        self
    }
    #[inline]
    pub fn max_x(mut self, value: f32) -> Self {
        self.max_x = value;
        self
    }
    #[inline]
    pub fn max_y(mut self, value: f32) -> Self {
        self.max_y = value;
        self
    }
    #[inline]
    pub fn max_z(mut self, value: f32) -> Self {
        self.max_z = value;
        self
    }
}
pub type AabbPositionsNV = AabbPositionsKHR;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryTrianglesDataKHR.html>"]
#[doc(alias = "VkAccelerationStructureGeometryTrianglesDataKHR")]
pub struct AccelerationStructureGeometryTrianglesDataKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub vertex_format: Format,
    pub vertex_data: DeviceOrHostAddressConstKHR,
    pub vertex_stride: DeviceSize,
    pub max_vertex: u32,
    pub index_type: IndexType,
    pub index_data: DeviceOrHostAddressConstKHR,
    pub transform_data: DeviceOrHostAddressConstKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureGeometryTrianglesDataKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::AccelerationStructureGeometryTrianglesDataKHR;
}
unsafe impl<'a> Send for AccelerationStructureGeometryTrianglesDataKHR<'a> {}
unsafe impl<'a> Sync for AccelerationStructureGeometryTrianglesDataKHR<'a> {}
impl<'a> Default for AccelerationStructureGeometryTrianglesDataKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            vertex_format: Format::Undefined,
            vertex_data: Default::default(),
            vertex_stride: Default::default(),
            max_vertex: Default::default(),
            index_type: IndexType::Uint16,
            index_data: Default::default(),
            transform_data: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureGeometryTrianglesDataKHR<'a> {
    #[inline]
    pub fn vertex_format(mut self, value: Format) -> Self {
        self.vertex_format = value;
        self
    }
    #[inline]
    pub fn vertex_data(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.vertex_data = value;
        self
    }
    #[inline]
    pub fn vertex_stride(mut self, value: DeviceSize) -> Self {
        self.vertex_stride = value;
        self
    }
    #[inline]
    pub fn max_vertex(mut self, value: u32) -> Self {
        self.max_vertex = value;
        self
    }
    #[inline]
    pub fn index_type(mut self, value: IndexType) -> Self {
        self.index_type = value;
        self
    }
    #[inline]
    pub fn index_data(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.index_data = value;
        self
    }
    #[inline]
    pub fn transform_data(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.transform_data = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTransformMatrixKHR.html>"]
#[doc(alias = "VkTransformMatrixKHR")]
pub struct TransformMatrixKHR {
    pub matrix: [[f32; 4u8 as _]; 3u8 as _],
}
unsafe impl Send for TransformMatrixKHR {}
unsafe impl Sync for TransformMatrixKHR {}
impl Default for TransformMatrixKHR {
    fn default() -> Self {
        Self {
            matrix: Default::default(),
        }
    }
}
impl TransformMatrixKHR {
    #[inline]
    pub fn matrix(mut self, value: [[f32; 4u8 as _]; 3u8 as _]) -> Self {
        self.matrix = value;
        self
    }
}
pub type TransformMatrixNV = TransformMatrixKHR;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html>"]
#[doc(alias = "VkAccelerationStructureBuildGeometryInfoKHR")]
pub struct AccelerationStructureBuildGeometryInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ty: AccelerationStructureTypeKHR,
    pub flags: BuildAccelerationStructureFlagsKHR,
    pub mode: BuildAccelerationStructureModeKHR,
    pub src_acceleration_structure: Option<AccelerationStructureKHR>,
    pub dst_acceleration_structure: Option<AccelerationStructureKHR>,
    pub geometry_count: u32,
    pub(crate) p_geometries: *const AccelerationStructureGeometryKHR<'a>,
    pub(crate) pp_geometries: *const *const AccelerationStructureGeometryKHR<'a>,
    pub scratch_data: DeviceOrHostAddressKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureBuildGeometryInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AccelerationStructureBuildGeometryInfoKHR;
}
unsafe impl<'a> Send for AccelerationStructureBuildGeometryInfoKHR<'a> {}
unsafe impl<'a> Sync for AccelerationStructureBuildGeometryInfoKHR<'a> {}
impl<'a> Default for AccelerationStructureBuildGeometryInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ty: AccelerationStructureTypeKHR::TopLevel,
            flags: Default::default(),
            mode: BuildAccelerationStructureModeKHR::Build,
            src_acceleration_structure: Default::default(),
            dst_acceleration_structure: Default::default(),
            geometry_count: Default::default(),
            p_geometries: ptr::null(),
            pp_geometries: ptr::null(),
            scratch_data: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureBuildGeometryInfoKHR<'a> {
    #[inline]
    pub fn ty(mut self, value: AccelerationStructureTypeKHR) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: BuildAccelerationStructureFlagsKHR) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn mode(mut self, value: BuildAccelerationStructureModeKHR) -> Self {
        self.mode = value;
        self
    }
    #[inline]
    pub fn src_acceleration_structure(
        mut self,
        value: Option<&'a AccelerationStructureKHR>,
    ) -> Self {
        self.src_acceleration_structure = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn dst_acceleration_structure(
        mut self,
        value: Option<&'a AccelerationStructureKHR>,
    ) -> Self {
        self.dst_acceleration_structure = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn geometry_count(mut self, value: u32) -> Self {
        self.geometry_count = value;
        self
    }
    #[inline]
    pub fn scratch_data(mut self, value: DeviceOrHostAddressKHR) -> Self {
        self.scratch_data = value;
        self
    }
    #[inline]
    pub fn geometry(
        mut self,
        p_geometries: Option<impl AsSlice<'a, AccelerationStructureGeometryKHR<'a>>>,
        pp_geometries: Option<impl AsSlice<'a, &'a AccelerationStructureGeometryKHR<'a>>>,
    ) -> Self {
        self.p_geometries = p_geometries
            .map(|p| p.as_slice().as_ptr().cast())
            .unwrap_or(ptr::null());
        self.pp_geometries = pp_geometries
            .map(|p| p.as_slice().as_ptr().cast())
            .unwrap_or(ptr::null());
        self.geometry_count = p_geometries.map(|p| p.as_slice().len()).unwrap_or_default() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryAabbsDataKHR.html>"]
#[doc(alias = "VkAccelerationStructureGeometryAabbsDataKHR")]
pub struct AccelerationStructureGeometryAabbsDataKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub data: DeviceOrHostAddressConstKHR,
    pub stride: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureGeometryAabbsDataKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AccelerationStructureGeometryAabbsDataKHR;
}
unsafe impl<'a> Send for AccelerationStructureGeometryAabbsDataKHR<'a> {}
unsafe impl<'a> Sync for AccelerationStructureGeometryAabbsDataKHR<'a> {}
impl<'a> Default for AccelerationStructureGeometryAabbsDataKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            data: Default::default(),
            stride: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureGeometryAabbsDataKHR<'a> {
    #[inline]
    pub fn data(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.data = value;
        self
    }
    #[inline]
    pub fn stride(mut self, value: DeviceSize) -> Self {
        self.stride = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureInstanceKHR.html>"]
#[doc(alias = "VkAccelerationStructureInstanceKHR")]
pub struct AccelerationStructureInstanceKHR {
    pub transform: TransformMatrixKHR,
    pub instance_custom_index: [u8; 3u8 as _],
    pub mask: [u8; 1u8 as _],
    pub instance_shader_binding_table_record_offset: [u8; 3u8 as _],
    pub flags: [u8; 1u8 as _],
    pub acceleration_structure_reference: u64,
}
unsafe impl Send for AccelerationStructureInstanceKHR {}
unsafe impl Sync for AccelerationStructureInstanceKHR {}
impl Default for AccelerationStructureInstanceKHR {
    fn default() -> Self {
        Self {
            transform: Default::default(),
            instance_custom_index: Default::default(),
            mask: Default::default(),
            instance_shader_binding_table_record_offset: Default::default(),
            flags: Default::default(),
            acceleration_structure_reference: Default::default(),
        }
    }
}
impl AccelerationStructureInstanceKHR {
    #[inline]
    pub fn transform(mut self, value: TransformMatrixKHR) -> Self {
        self.transform = value;
        self
    }
    #[inline]
    pub fn instance_custom_index(mut self, value: u32) -> Self {
        self.instance_custom_index = (value as u32).to_ne_bytes()[..3usize].try_into().unwrap();
        self
    }
    #[inline]
    pub fn mask(mut self, value: u32) -> Self {
        self.mask = (value as u32).to_ne_bytes()[..1usize].try_into().unwrap();
        self
    }
    #[inline]
    pub fn instance_shader_binding_table_record_offset(mut self, value: u32) -> Self {
        self.instance_shader_binding_table_record_offset =
            (value as u32).to_ne_bytes()[..3usize].try_into().unwrap();
        self
    }
    #[inline]
    pub fn flags(mut self, value: GeometryInstanceFlagsKHR) -> Self {
        self.flags = value.bits().to_ne_bytes()[..1usize].try_into().unwrap();
        self
    }
    #[inline]
    pub fn acceleration_structure_reference(mut self, value: u64) -> Self {
        self.acceleration_structure_reference = value;
        self
    }
}
pub type AccelerationStructureInstanceNV = AccelerationStructureInstanceKHR;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryInstancesDataKHR.html>"]
#[doc(alias = "VkAccelerationStructureGeometryInstancesDataKHR")]
pub struct AccelerationStructureGeometryInstancesDataKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub array_of_pointers: Bool32,
    pub data: DeviceOrHostAddressConstKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureGeometryInstancesDataKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::AccelerationStructureGeometryInstancesDataKHR;
}
unsafe impl<'a> Send for AccelerationStructureGeometryInstancesDataKHR<'a> {}
unsafe impl<'a> Sync for AccelerationStructureGeometryInstancesDataKHR<'a> {}
impl<'a> Default for AccelerationStructureGeometryInstancesDataKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            array_of_pointers: Default::default(),
            data: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureGeometryInstancesDataKHR<'a> {
    #[inline]
    pub fn array_of_pointers(mut self, value: impl Into<Bool32>) -> Self {
        self.array_of_pointers = value.into();
        self
    }
    #[inline]
    pub fn data(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.data = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryDataKHR.html>"]
#[doc(alias = "VkAccelerationStructureGeometryDataKHR")]
pub union AccelerationStructureGeometryDataKHR<'a> {
    pub triangles: ManuallyDrop<AccelerationStructureGeometryTrianglesDataKHR<'a>>,
    pub aabbs: ManuallyDrop<AccelerationStructureGeometryAabbsDataKHR<'a>>,
    pub instances: ManuallyDrop<AccelerationStructureGeometryInstancesDataKHR<'a>>,
}
impl<'a> Default for AccelerationStructureGeometryDataKHR<'a> {
    fn default() -> Self {
        Self {
            triangles: ManuallyDrop::new(Default::default()),
        }
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryKHR.html>"]
#[doc(alias = "VkAccelerationStructureGeometryKHR")]
pub struct AccelerationStructureGeometryKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub geometry_type: GeometryTypeKHR,
    pub geometry: AccelerationStructureGeometryDataKHR<'a>,
    pub flags: GeometryFlagsKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureGeometryKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AccelerationStructureGeometryKHR;
}
unsafe impl<'a> Send for AccelerationStructureGeometryKHR<'a> {}
unsafe impl<'a> Sync for AccelerationStructureGeometryKHR<'a> {}
impl<'a> Default for AccelerationStructureGeometryKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            geometry_type: GeometryTypeKHR::Triangles,
            geometry: Default::default(),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureGeometryKHR<'a> {
    #[inline]
    pub fn geometry_type(mut self, value: GeometryTypeKHR) -> Self {
        self.geometry_type = value;
        self
    }
    #[inline]
    pub fn geometry(mut self, value: AccelerationStructureGeometryDataKHR<'a>) -> Self {
        self.geometry = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: GeometryFlagsKHR) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureCreateInfoKHR.html>"]
#[doc(alias = "VkAccelerationStructureCreateInfoKHR")]
pub struct AccelerationStructureCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub create_flags: AccelerationStructureCreateFlagsKHR,
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub ty: AccelerationStructureTypeKHR,
    pub device_address: DeviceAddress,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AccelerationStructureCreateInfoKHR;
}
unsafe impl<'a> Send for AccelerationStructureCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for AccelerationStructureCreateInfoKHR<'a> {}
impl<'a> Default for AccelerationStructureCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            create_flags: Default::default(),
            buffer: Default::default(),
            offset: Default::default(),
            size: Default::default(),
            ty: AccelerationStructureTypeKHR::TopLevel,
            device_address: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureCreateInfoKHR<'a> {
    #[inline]
    pub fn create_flags(mut self, value: AccelerationStructureCreateFlagsKHR) -> Self {
        self.create_flags = value;
        self
    }
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn offset(mut self, value: DeviceSize) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn ty(mut self, value: AccelerationStructureTypeKHR) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn device_address(mut self, value: DeviceAddress) -> Self {
        self.device_address = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetAccelerationStructureKHR.html>"]
#[doc(alias = "VkWriteDescriptorSetAccelerationStructureKHR")]
pub struct WriteDescriptorSetAccelerationStructureKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub acceleration_structure_count: u32,
    pub(crate) p_acceleration_structures: *const AccelerationStructureKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for WriteDescriptorSetAccelerationStructureKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::WriteDescriptorSetAccelerationStructureKHR;
}
unsafe impl<'a> Send for WriteDescriptorSetAccelerationStructureKHR<'a> {}
unsafe impl<'a> Sync for WriteDescriptorSetAccelerationStructureKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<WriteDescriptorSet<'b>>
    for WriteDescriptorSetAccelerationStructureKHR<'a>
{
}
impl<'a> Default for WriteDescriptorSetAccelerationStructureKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            acceleration_structure_count: Default::default(),
            p_acceleration_structures: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> WriteDescriptorSetAccelerationStructureKHR<'a> {
    #[inline]
    pub fn acceleration_structure_count(mut self, value: u32) -> Self {
        self.acceleration_structure_count = value;
        self
    }
    #[inline]
    pub fn acceleration_structures<V0: Alias<raw::AccelerationStructureKHR> + 'a>(
        mut self,
        p_acceleration_structures: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_acceleration_structures = p_acceleration_structures.as_slice().as_ptr().cast();
        self.acceleration_structure_count = p_acceleration_structures.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceAccelerationStructureFeaturesKHR")]
pub struct PhysicalDeviceAccelerationStructureFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub acceleration_structure: Bool32,
    pub acceleration_structure_capture_replay: Bool32,
    pub acceleration_structure_indirect_build: Bool32,
    pub acceleration_structure_host_commands: Bool32,
    pub descriptor_binding_acceleration_structure_update_after_bind: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceAccelerationStructureFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceAccelerationStructureFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceAccelerationStructureFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceAccelerationStructureFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceAccelerationStructureFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceAccelerationStructureFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceAccelerationStructureFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            acceleration_structure: Default::default(),
            acceleration_structure_capture_replay: Default::default(),
            acceleration_structure_indirect_build: Default::default(),
            acceleration_structure_host_commands: Default::default(),
            descriptor_binding_acceleration_structure_update_after_bind: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceAccelerationStructureFeaturesKHR<'a> {
    #[inline]
    pub fn acceleration_structure(mut self, value: impl Into<Bool32>) -> Self {
        self.acceleration_structure = value.into();
        self
    }
    #[inline]
    pub fn acceleration_structure_capture_replay(mut self, value: impl Into<Bool32>) -> Self {
        self.acceleration_structure_capture_replay = value.into();
        self
    }
    #[inline]
    pub fn acceleration_structure_indirect_build(mut self, value: impl Into<Bool32>) -> Self {
        self.acceleration_structure_indirect_build = value.into();
        self
    }
    #[inline]
    pub fn acceleration_structure_host_commands(mut self, value: impl Into<Bool32>) -> Self {
        self.acceleration_structure_host_commands = value.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_acceleration_structure_update_after_bind(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.descriptor_binding_acceleration_structure_update_after_bind = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAccelerationStructurePropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceAccelerationStructurePropertiesKHR")]
pub struct PhysicalDeviceAccelerationStructurePropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_geometry_count: u64,
    pub max_instance_count: u64,
    pub max_primitive_count: u64,
    pub max_per_stage_descriptor_acceleration_structures: u32,
    pub max_per_stage_descriptor_update_after_bind_acceleration_structures: u32,
    pub max_descriptor_set_acceleration_structures: u32,
    pub max_descriptor_set_update_after_bind_acceleration_structures: u32,
    pub min_acceleration_structure_scratch_offset_alignment: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceAccelerationStructurePropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceAccelerationStructurePropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceAccelerationStructurePropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceAccelerationStructurePropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceAccelerationStructurePropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceAccelerationStructurePropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_geometry_count: Default::default(),
            max_instance_count: Default::default(),
            max_primitive_count: Default::default(),
            max_per_stage_descriptor_acceleration_structures: Default::default(),
            max_per_stage_descriptor_update_after_bind_acceleration_structures: Default::default(),
            max_descriptor_set_acceleration_structures: Default::default(),
            max_descriptor_set_update_after_bind_acceleration_structures: Default::default(),
            min_acceleration_structure_scratch_offset_alignment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceAccelerationStructurePropertiesKHR<'a> {
    #[inline]
    pub fn max_geometry_count(mut self, value: u64) -> Self {
        self.max_geometry_count = value;
        self
    }
    #[inline]
    pub fn max_instance_count(mut self, value: u64) -> Self {
        self.max_instance_count = value;
        self
    }
    #[inline]
    pub fn max_primitive_count(mut self, value: u64) -> Self {
        self.max_primitive_count = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_acceleration_structures(mut self, value: u32) -> Self {
        self.max_per_stage_descriptor_acceleration_structures = value;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_acceleration_structures(
        mut self,
        value: u32,
    ) -> Self {
        self.max_per_stage_descriptor_update_after_bind_acceleration_structures = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_acceleration_structures(mut self, value: u32) -> Self {
        self.max_descriptor_set_acceleration_structures = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_acceleration_structures(
        mut self,
        value: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_acceleration_structures = value;
        self
    }
    #[inline]
    pub fn min_acceleration_structure_scratch_offset_alignment(mut self, value: u32) -> Self {
        self.min_acceleration_structure_scratch_offset_alignment = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureDeviceAddressInfoKHR.html>"]
#[doc(alias = "VkAccelerationStructureDeviceAddressInfoKHR")]
pub struct AccelerationStructureDeviceAddressInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub acceleration_structure: Option<AccelerationStructureKHR>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureDeviceAddressInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AccelerationStructureDeviceAddressInfoKHR;
}
unsafe impl<'a> Send for AccelerationStructureDeviceAddressInfoKHR<'a> {}
unsafe impl<'a> Sync for AccelerationStructureDeviceAddressInfoKHR<'a> {}
impl<'a> Default for AccelerationStructureDeviceAddressInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            acceleration_structure: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureDeviceAddressInfoKHR<'a> {
    #[inline]
    pub fn acceleration_structure(mut self, value: &'a AccelerationStructureKHR) -> Self {
        self.acceleration_structure = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureVersionInfoKHR.html>"]
#[doc(alias = "VkAccelerationStructureVersionInfoKHR")]
pub struct AccelerationStructureVersionInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) p_version_data: *const u8,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureVersionInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AccelerationStructureVersionInfoKHR;
}
unsafe impl<'a> Send for AccelerationStructureVersionInfoKHR<'a> {}
unsafe impl<'a> Sync for AccelerationStructureVersionInfoKHR<'a> {}
impl<'a> Default for AccelerationStructureVersionInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_version_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureVersionInfoKHR<'a> {
    #[inline]
    pub fn version_data(mut self, value: &'a [u8; (2 * UUID_SIZE) as _]) -> Self {
        self.p_version_data = value.as_ptr();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyAccelerationStructureToMemoryInfoKHR.html>"]
#[doc(alias = "VkCopyAccelerationStructureToMemoryInfoKHR")]
pub struct CopyAccelerationStructureToMemoryInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src: Option<AccelerationStructureKHR>,
    pub dst: DeviceOrHostAddressKHR,
    pub mode: CopyAccelerationStructureModeKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyAccelerationStructureToMemoryInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyAccelerationStructureToMemoryInfoKHR;
}
unsafe impl<'a> Send for CopyAccelerationStructureToMemoryInfoKHR<'a> {}
unsafe impl<'a> Sync for CopyAccelerationStructureToMemoryInfoKHR<'a> {}
impl<'a> Default for CopyAccelerationStructureToMemoryInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src: Default::default(),
            dst: Default::default(),
            mode: CopyAccelerationStructureModeKHR::Clone,
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyAccelerationStructureToMemoryInfoKHR<'a> {
    #[inline]
    pub fn src(mut self, value: &'a AccelerationStructureKHR) -> Self {
        self.src = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst(mut self, value: DeviceOrHostAddressKHR) -> Self {
        self.dst = value;
        self
    }
    #[inline]
    pub fn mode(mut self, value: CopyAccelerationStructureModeKHR) -> Self {
        self.mode = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMemoryToAccelerationStructureInfoKHR.html>"]
#[doc(alias = "VkCopyMemoryToAccelerationStructureInfoKHR")]
pub struct CopyMemoryToAccelerationStructureInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src: DeviceOrHostAddressConstKHR,
    pub dst: Option<AccelerationStructureKHR>,
    pub mode: CopyAccelerationStructureModeKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyMemoryToAccelerationStructureInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyMemoryToAccelerationStructureInfoKHR;
}
unsafe impl<'a> Send for CopyMemoryToAccelerationStructureInfoKHR<'a> {}
unsafe impl<'a> Sync for CopyMemoryToAccelerationStructureInfoKHR<'a> {}
impl<'a> Default for CopyMemoryToAccelerationStructureInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src: Default::default(),
            dst: Default::default(),
            mode: CopyAccelerationStructureModeKHR::Clone,
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyMemoryToAccelerationStructureInfoKHR<'a> {
    #[inline]
    pub fn src(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.src = value;
        self
    }
    #[inline]
    pub fn dst(mut self, value: &'a AccelerationStructureKHR) -> Self {
        self.dst = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn mode(mut self, value: CopyAccelerationStructureModeKHR) -> Self {
        self.mode = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyAccelerationStructureInfoKHR.html>"]
#[doc(alias = "VkCopyAccelerationStructureInfoKHR")]
pub struct CopyAccelerationStructureInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src: Option<AccelerationStructureKHR>,
    pub dst: Option<AccelerationStructureKHR>,
    pub mode: CopyAccelerationStructureModeKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyAccelerationStructureInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyAccelerationStructureInfoKHR;
}
unsafe impl<'a> Send for CopyAccelerationStructureInfoKHR<'a> {}
unsafe impl<'a> Sync for CopyAccelerationStructureInfoKHR<'a> {}
impl<'a> Default for CopyAccelerationStructureInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src: Default::default(),
            dst: Default::default(),
            mode: CopyAccelerationStructureModeKHR::Clone,
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyAccelerationStructureInfoKHR<'a> {
    #[inline]
    pub fn src(mut self, value: &'a AccelerationStructureKHR) -> Self {
        self.src = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst(mut self, value: &'a AccelerationStructureKHR) -> Self {
        self.dst = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn mode(mut self, value: CopyAccelerationStructureModeKHR) -> Self {
        self.mode = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureBuildSizesInfoKHR.html>"]
#[doc(alias = "VkAccelerationStructureBuildSizesInfoKHR")]
pub struct AccelerationStructureBuildSizesInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub acceleration_structure_size: DeviceSize,
    pub update_scratch_size: DeviceSize,
    pub build_scratch_size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureBuildSizesInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AccelerationStructureBuildSizesInfoKHR;
}
unsafe impl<'a> Send for AccelerationStructureBuildSizesInfoKHR<'a> {}
unsafe impl<'a> Sync for AccelerationStructureBuildSizesInfoKHR<'a> {}
impl<'a> Default for AccelerationStructureBuildSizesInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            acceleration_structure_size: Default::default(),
            update_scratch_size: Default::default(),
            build_scratch_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureBuildSizesInfoKHR<'a> {
    #[inline]
    pub fn acceleration_structure_size(mut self, value: DeviceSize) -> Self {
        self.acceleration_structure_size = value;
        self
    }
    #[inline]
    pub fn update_scratch_size(mut self, value: DeviceSize) -> Self {
        self.update_scratch_size = value;
        self
    }
    #[inline]
    pub fn build_scratch_size(mut self, value: DeviceSize) -> Self {
        self.build_scratch_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingShaderGroupCreateInfoKHR.html>"]
#[doc(alias = "VkRayTracingShaderGroupCreateInfoKHR")]
pub struct RayTracingShaderGroupCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ty: RayTracingShaderGroupTypeKHR,
    pub general_shader: u32,
    pub closest_hit_shader: u32,
    pub any_hit_shader: u32,
    pub intersection_shader: u32,
    pub p_shader_group_capture_replay_handle: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RayTracingShaderGroupCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RayTracingShaderGroupCreateInfoKHR;
}
unsafe impl<'a> Send for RayTracingShaderGroupCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for RayTracingShaderGroupCreateInfoKHR<'a> {}
impl<'a> Default for RayTracingShaderGroupCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ty: RayTracingShaderGroupTypeKHR::General,
            general_shader: Default::default(),
            closest_hit_shader: Default::default(),
            any_hit_shader: Default::default(),
            intersection_shader: Default::default(),
            p_shader_group_capture_replay_handle: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RayTracingShaderGroupCreateInfoKHR<'a> {
    #[inline]
    pub fn ty(mut self, value: RayTracingShaderGroupTypeKHR) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn general_shader(mut self, value: u32) -> Self {
        self.general_shader = value;
        self
    }
    #[inline]
    pub fn closest_hit_shader(mut self, value: u32) -> Self {
        self.closest_hit_shader = value;
        self
    }
    #[inline]
    pub fn any_hit_shader(mut self, value: u32) -> Self {
        self.any_hit_shader = value;
        self
    }
    #[inline]
    pub fn intersection_shader(mut self, value: u32) -> Self {
        self.intersection_shader = value;
        self
    }
    #[inline]
    pub fn shader_group_capture_replay_handle(mut self, value: VoidPtr) -> Self {
        self.p_shader_group_capture_replay_handle = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingPipelineCreateInfoKHR.html>"]
#[doc(alias = "VkRayTracingPipelineCreateInfoKHR")]
pub struct RayTracingPipelineCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: PipelineCreateFlags,
    pub(crate) stage_count: u32,
    pub(crate) p_stages: *const PipelineShaderStageCreateInfo<'a>,
    pub(crate) group_count: u32,
    pub(crate) p_groups: *const RayTracingShaderGroupCreateInfoKHR<'a>,
    pub max_pipeline_ray_recursion_depth: u32,
    pub p_library_info: *const PipelineLibraryCreateInfoKHR<'a>,
    pub p_library_interface: *const RayTracingPipelineInterfaceCreateInfoKHR<'a>,
    pub p_dynamic_state: *const PipelineDynamicStateCreateInfo<'a>,
    pub layout: Option<PipelineLayout>,
    pub base_pipeline_handle: Option<Pipeline>,
    pub base_pipeline_index: i32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RayTracingPipelineCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RayTracingPipelineCreateInfoKHR;
}
unsafe impl<'a> Send for RayTracingPipelineCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for RayTracingPipelineCreateInfoKHR<'a> {}
impl<'a> Default for RayTracingPipelineCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            stage_count: Default::default(),
            p_stages: ptr::null(),
            group_count: Default::default(),
            p_groups: ptr::null(),
            max_pipeline_ray_recursion_depth: Default::default(),
            p_library_info: ptr::null(),
            p_library_interface: ptr::null(),
            p_dynamic_state: ptr::null(),
            layout: Default::default(),
            base_pipeline_handle: Default::default(),
            base_pipeline_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RayTracingPipelineCreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: PipelineCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn max_pipeline_ray_recursion_depth(mut self, value: u32) -> Self {
        self.max_pipeline_ray_recursion_depth = value;
        self
    }
    #[inline]
    pub fn library_info(mut self, value: Option<&'a PipelineLibraryCreateInfoKHR<'a>>) -> Self {
        self.p_library_info = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn library_interface(
        mut self,
        value: Option<&'a RayTracingPipelineInterfaceCreateInfoKHR<'a>>,
    ) -> Self {
        self.p_library_interface = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn dynamic_state(mut self, value: Option<&'a PipelineDynamicStateCreateInfo<'a>>) -> Self {
        self.p_dynamic_state = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn layout(mut self, value: &'a PipelineLayout) -> Self {
        self.layout = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, value: Option<&'a Pipeline>) -> Self {
        self.base_pipeline_handle = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, value: i32) -> Self {
        self.base_pipeline_index = value;
        self
    }
    #[inline]
    pub fn stages(mut self, p_stages: impl AsSlice<'a, PipelineShaderStageCreateInfo<'a>>) -> Self {
        self.p_stages = p_stages.as_slice().as_ptr().cast();
        self.stage_count = p_stages.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn groups(
        mut self,
        p_groups: impl AsSlice<'a, RayTracingShaderGroupCreateInfoKHR<'a>>,
    ) -> Self {
        self.p_groups = p_groups.as_slice().as_ptr().cast();
        self.group_count = p_groups.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceRayTracingPipelineFeaturesKHR")]
pub struct PhysicalDeviceRayTracingPipelineFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ray_tracing_pipeline: Bool32,
    pub ray_tracing_pipeline_shader_group_handle_capture_replay: Bool32,
    pub ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: Bool32,
    pub ray_tracing_pipeline_trace_rays_indirect: Bool32,
    pub ray_traversal_primitive_culling: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRayTracingPipelineFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceRayTracingPipelineFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceRayTracingPipelineFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRayTracingPipelineFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRayTracingPipelineFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRayTracingPipelineFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceRayTracingPipelineFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ray_tracing_pipeline: Default::default(),
            ray_tracing_pipeline_shader_group_handle_capture_replay: Default::default(),
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: Default::default(),
            ray_tracing_pipeline_trace_rays_indirect: Default::default(),
            ray_traversal_primitive_culling: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRayTracingPipelineFeaturesKHR<'a> {
    #[inline]
    pub fn ray_tracing_pipeline(mut self, value: impl Into<Bool32>) -> Self {
        self.ray_tracing_pipeline = value.into();
        self
    }
    #[inline]
    pub fn ray_tracing_pipeline_shader_group_handle_capture_replay(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.ray_tracing_pipeline_shader_group_handle_capture_replay = value.into();
        self
    }
    #[inline]
    pub fn ray_tracing_pipeline_shader_group_handle_capture_replay_mixed(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed = value.into();
        self
    }
    #[inline]
    pub fn ray_tracing_pipeline_trace_rays_indirect(mut self, value: impl Into<Bool32>) -> Self {
        self.ray_tracing_pipeline_trace_rays_indirect = value.into();
        self
    }
    #[inline]
    pub fn ray_traversal_primitive_culling(mut self, value: impl Into<Bool32>) -> Self {
        self.ray_traversal_primitive_culling = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPipelinePropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceRayTracingPipelinePropertiesKHR")]
pub struct PhysicalDeviceRayTracingPipelinePropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_group_handle_size: u32,
    pub max_ray_recursion_depth: u32,
    pub max_shader_group_stride: u32,
    pub shader_group_base_alignment: u32,
    pub shader_group_handle_capture_replay_size: u32,
    pub max_ray_dispatch_invocation_count: u32,
    pub shader_group_handle_alignment: u32,
    pub max_ray_hit_attribute_size: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRayTracingPipelinePropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceRayTracingPipelinePropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceRayTracingPipelinePropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRayTracingPipelinePropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceRayTracingPipelinePropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceRayTracingPipelinePropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_group_handle_size: Default::default(),
            max_ray_recursion_depth: Default::default(),
            max_shader_group_stride: Default::default(),
            shader_group_base_alignment: Default::default(),
            shader_group_handle_capture_replay_size: Default::default(),
            max_ray_dispatch_invocation_count: Default::default(),
            shader_group_handle_alignment: Default::default(),
            max_ray_hit_attribute_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRayTracingPipelinePropertiesKHR<'a> {
    #[inline]
    pub fn shader_group_handle_size(mut self, value: u32) -> Self {
        self.shader_group_handle_size = value;
        self
    }
    #[inline]
    pub fn max_ray_recursion_depth(mut self, value: u32) -> Self {
        self.max_ray_recursion_depth = value;
        self
    }
    #[inline]
    pub fn max_shader_group_stride(mut self, value: u32) -> Self {
        self.max_shader_group_stride = value;
        self
    }
    #[inline]
    pub fn shader_group_base_alignment(mut self, value: u32) -> Self {
        self.shader_group_base_alignment = value;
        self
    }
    #[inline]
    pub fn shader_group_handle_capture_replay_size(mut self, value: u32) -> Self {
        self.shader_group_handle_capture_replay_size = value;
        self
    }
    #[inline]
    pub fn max_ray_dispatch_invocation_count(mut self, value: u32) -> Self {
        self.max_ray_dispatch_invocation_count = value;
        self
    }
    #[inline]
    pub fn shader_group_handle_alignment(mut self, value: u32) -> Self {
        self.shader_group_handle_alignment = value;
        self
    }
    #[inline]
    pub fn max_ray_hit_attribute_size(mut self, value: u32) -> Self {
        self.max_ray_hit_attribute_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStridedDeviceAddressRegionKHR.html>"]
#[doc(alias = "VkStridedDeviceAddressRegionKHR")]
pub struct StridedDeviceAddressRegionKHR {
    pub device_address: DeviceAddress,
    pub stride: DeviceSize,
    pub size: DeviceSize,
}
unsafe impl Send for StridedDeviceAddressRegionKHR {}
unsafe impl Sync for StridedDeviceAddressRegionKHR {}
impl Default for StridedDeviceAddressRegionKHR {
    fn default() -> Self {
        Self {
            device_address: Default::default(),
            stride: Default::default(),
            size: Default::default(),
        }
    }
}
impl StridedDeviceAddressRegionKHR {
    #[inline]
    pub fn device_address(mut self, value: DeviceAddress) -> Self {
        self.device_address = value;
        self
    }
    #[inline]
    pub fn stride(mut self, value: DeviceSize) -> Self {
        self.stride = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTraceRaysIndirectCommandKHR.html>"]
#[doc(alias = "VkTraceRaysIndirectCommandKHR")]
pub struct TraceRaysIndirectCommandKHR {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
unsafe impl Send for TraceRaysIndirectCommandKHR {}
unsafe impl Sync for TraceRaysIndirectCommandKHR {}
impl Default for TraceRaysIndirectCommandKHR {
    fn default() -> Self {
        Self {
            width: Default::default(),
            height: Default::default(),
            depth: Default::default(),
        }
    }
}
impl TraceRaysIndirectCommandKHR {
    #[inline]
    pub fn width(mut self, value: u32) -> Self {
        self.width = value;
        self
    }
    #[inline]
    pub fn height(mut self, value: u32) -> Self {
        self.height = value;
        self
    }
    #[inline]
    pub fn depth(mut self, value: u32) -> Self {
        self.depth = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingPipelineInterfaceCreateInfoKHR.html>"]
#[doc(alias = "VkRayTracingPipelineInterfaceCreateInfoKHR")]
pub struct RayTracingPipelineInterfaceCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_pipeline_ray_payload_size: u32,
    pub max_pipeline_ray_hit_attribute_size: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RayTracingPipelineInterfaceCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RayTracingPipelineInterfaceCreateInfoKHR;
}
unsafe impl<'a> Send for RayTracingPipelineInterfaceCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for RayTracingPipelineInterfaceCreateInfoKHR<'a> {}
impl<'a> Default for RayTracingPipelineInterfaceCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_pipeline_ray_payload_size: Default::default(),
            max_pipeline_ray_hit_attribute_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RayTracingPipelineInterfaceCreateInfoKHR<'a> {
    #[inline]
    pub fn max_pipeline_ray_payload_size(mut self, value: u32) -> Self {
        self.max_pipeline_ray_payload_size = value;
        self
    }
    #[inline]
    pub fn max_pipeline_ray_hit_attribute_size(mut self, value: u32) -> Self {
        self.max_pipeline_ray_hit_attribute_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayQueryFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceRayQueryFeaturesKHR")]
pub struct PhysicalDeviceRayQueryFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ray_query: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRayQueryFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceRayQueryFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceRayQueryFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRayQueryFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRayQueryFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRayQueryFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceRayQueryFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ray_query: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRayQueryFeaturesKHR<'a> {
    #[inline]
    pub fn ray_query(mut self, value: impl Into<Bool32>) -> Self {
        self.ray_query = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageModulationStateCreateInfoNV.html>"]
#[doc(alias = "VkPipelineCoverageModulationStateCreateInfoNV")]
pub struct PipelineCoverageModulationStateCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub coverage_modulation_mode: CoverageModulationModeNV,
    pub coverage_modulation_table_enable: Bool32,
    pub coverage_modulation_table_count: u32,
    pub(crate) p_coverage_modulation_table: *const f32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineCoverageModulationStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineCoverageModulationStateCreateInfoNV;
}
unsafe impl<'a> Send for PipelineCoverageModulationStateCreateInfoNV<'a> {}
unsafe impl<'a> Sync for PipelineCoverageModulationStateCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineMultisampleStateCreateInfo<'b>>
    for PipelineCoverageModulationStateCreateInfoNV<'a>
{
}
impl<'a> Default for PipelineCoverageModulationStateCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            coverage_modulation_mode: CoverageModulationModeNV::None,
            coverage_modulation_table_enable: Default::default(),
            coverage_modulation_table_count: Default::default(),
            p_coverage_modulation_table: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineCoverageModulationStateCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn coverage_modulation_mode(mut self, value: CoverageModulationModeNV) -> Self {
        self.coverage_modulation_mode = value;
        self
    }
    #[inline]
    pub fn coverage_modulation_table_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.coverage_modulation_table_enable = value.into();
        self
    }
    #[inline]
    pub fn coverage_modulation_table_count(mut self, value: u32) -> Self {
        self.coverage_modulation_table_count = value;
        self
    }
    #[inline]
    pub fn coverage_modulation_table(
        mut self,
        p_coverage_modulation_table: impl AsSlice<'a, f32>,
    ) -> Self {
        self.p_coverage_modulation_table = p_coverage_modulation_table.as_slice().as_ptr().cast();
        self.coverage_modulation_table_count = p_coverage_modulation_table.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceShaderSMBuiltinsPropertiesNV")]
pub struct PhysicalDeviceShaderSMBuiltinsPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_smcount: u32,
    pub shader_warps_per_sm: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderSMBuiltinsPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderSmBuiltinsPropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceShaderSMBuiltinsPropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderSMBuiltinsPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceShaderSMBuiltinsPropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderSMBuiltinsPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_smcount: Default::default(),
            shader_warps_per_sm: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderSMBuiltinsPropertiesNV<'a> {
    #[inline]
    pub fn shader_smcount(mut self, value: u32) -> Self {
        self.shader_smcount = value;
        self
    }
    #[inline]
    pub fn shader_warps_per_sm(mut self, value: u32) -> Self {
        self.shader_warps_per_sm = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV")]
pub struct PhysicalDeviceShaderSMBuiltinsFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_smbuiltins: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderSMBuiltinsFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderSmBuiltinsFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceShaderSMBuiltinsFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderSMBuiltinsFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderSMBuiltinsFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderSMBuiltinsFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderSMBuiltinsFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_smbuiltins: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderSMBuiltinsFeaturesNV<'a> {
    #[inline]
    pub fn shader_smbuiltins(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_smbuiltins = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrmFormatModifierPropertiesListEXT.html>"]
#[doc(alias = "VkDrmFormatModifierPropertiesListEXT")]
pub struct DrmFormatModifierPropertiesListEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub drm_format_modifier_count: u32,
    pub(crate) p_drm_format_modifier_properties: *const DrmFormatModifierPropertiesEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DrmFormatModifierPropertiesListEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DrmFormatModifierPropertiesListEXT;
}
unsafe impl<'a> Send for DrmFormatModifierPropertiesListEXT<'a> {}
unsafe impl<'a> Sync for DrmFormatModifierPropertiesListEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<FormatProperties2<'b>>
    for DrmFormatModifierPropertiesListEXT<'a>
{
}
impl<'a> Default for DrmFormatModifierPropertiesListEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            drm_format_modifier_count: Default::default(),
            p_drm_format_modifier_properties: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DrmFormatModifierPropertiesListEXT<'a> {
    #[inline]
    pub fn drm_format_modifier_count(mut self, value: u32) -> Self {
        self.drm_format_modifier_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrmFormatModifierPropertiesEXT.html>"]
#[doc(alias = "VkDrmFormatModifierPropertiesEXT")]
pub struct DrmFormatModifierPropertiesEXT {
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub drm_format_modifier_tiling_features: FormatFeatureFlags,
}
unsafe impl Send for DrmFormatModifierPropertiesEXT {}
unsafe impl Sync for DrmFormatModifierPropertiesEXT {}
impl Default for DrmFormatModifierPropertiesEXT {
    fn default() -> Self {
        Self {
            drm_format_modifier: Default::default(),
            drm_format_modifier_plane_count: Default::default(),
            drm_format_modifier_tiling_features: Default::default(),
        }
    }
}
impl DrmFormatModifierPropertiesEXT {
    #[inline]
    pub fn drm_format_modifier(mut self, value: u64) -> Self {
        self.drm_format_modifier = value;
        self
    }
    #[inline]
    pub fn drm_format_modifier_plane_count(mut self, value: u32) -> Self {
        self.drm_format_modifier_plane_count = value;
        self
    }
    #[inline]
    pub fn drm_format_modifier_tiling_features(mut self, value: FormatFeatureFlags) -> Self {
        self.drm_format_modifier_tiling_features = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageDrmFormatModifierInfoEXT.html>"]
#[doc(alias = "VkPhysicalDeviceImageDrmFormatModifierInfoEXT")]
pub struct PhysicalDeviceImageDrmFormatModifierInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub drm_format_modifier: u64,
    pub sharing_mode: SharingMode,
    pub(crate) queue_family_index_count: u32,
    pub(crate) p_queue_family_indices: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageDrmFormatModifierInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceImageDrmFormatModifierInfoEXT;
}
unsafe impl<'a> Send for PhysicalDeviceImageDrmFormatModifierInfoEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageDrmFormatModifierInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceImageFormatInfo2<'b>>
    for PhysicalDeviceImageDrmFormatModifierInfoEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceImageDrmFormatModifierInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            drm_format_modifier: Default::default(),
            sharing_mode: SharingMode::Exclusive,
            queue_family_index_count: Default::default(),
            p_queue_family_indices: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageDrmFormatModifierInfoEXT<'a> {
    #[inline]
    pub fn drm_format_modifier(mut self, value: u64) -> Self {
        self.drm_format_modifier = value;
        self
    }
    #[inline]
    pub fn sharing_mode(mut self, value: SharingMode) -> Self {
        self.sharing_mode = value;
        self
    }
    #[inline]
    pub fn queue_family_indices(mut self, p_queue_family_indices: impl AsSlice<'a, u32>) -> Self {
        self.p_queue_family_indices = p_queue_family_indices.as_slice().as_ptr().cast();
        self.queue_family_index_count = p_queue_family_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageDrmFormatModifierListCreateInfoEXT.html>"]
#[doc(alias = "VkImageDrmFormatModifierListCreateInfoEXT")]
pub struct ImageDrmFormatModifierListCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) drm_format_modifier_count: u32,
    pub(crate) p_drm_format_modifiers: *const u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageDrmFormatModifierListCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageDrmFormatModifierListCreateInfoEXT;
}
unsafe impl<'a> Send for ImageDrmFormatModifierListCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for ImageDrmFormatModifierListCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>>
    for ImageDrmFormatModifierListCreateInfoEXT<'a>
{
}
impl<'a> Default for ImageDrmFormatModifierListCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            drm_format_modifier_count: Default::default(),
            p_drm_format_modifiers: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageDrmFormatModifierListCreateInfoEXT<'a> {
    #[inline]
    pub fn drm_format_modifiers(mut self, p_drm_format_modifiers: impl AsSlice<'a, u64>) -> Self {
        self.p_drm_format_modifiers = p_drm_format_modifiers.as_slice().as_ptr().cast();
        self.drm_format_modifier_count = p_drm_format_modifiers.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageDrmFormatModifierExplicitCreateInfoEXT.html>"]
#[doc(alias = "VkImageDrmFormatModifierExplicitCreateInfoEXT")]
pub struct ImageDrmFormatModifierExplicitCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub drm_format_modifier: u64,
    pub(crate) drm_format_modifier_plane_count: u32,
    pub(crate) p_plane_layouts: *const SubresourceLayout,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageDrmFormatModifierExplicitCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ImageDrmFormatModifierExplicitCreateInfoEXT;
}
unsafe impl<'a> Send for ImageDrmFormatModifierExplicitCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for ImageDrmFormatModifierExplicitCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>>
    for ImageDrmFormatModifierExplicitCreateInfoEXT<'a>
{
}
impl<'a> Default for ImageDrmFormatModifierExplicitCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            drm_format_modifier: Default::default(),
            drm_format_modifier_plane_count: Default::default(),
            p_plane_layouts: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageDrmFormatModifierExplicitCreateInfoEXT<'a> {
    #[inline]
    pub fn drm_format_modifier(mut self, value: u64) -> Self {
        self.drm_format_modifier = value;
        self
    }
    #[inline]
    pub fn plane_layouts(mut self, p_plane_layouts: impl AsSlice<'a, SubresourceLayout>) -> Self {
        self.p_plane_layouts = p_plane_layouts.as_slice().as_ptr().cast();
        self.drm_format_modifier_plane_count = p_plane_layouts.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageDrmFormatModifierPropertiesEXT.html>"]
#[doc(alias = "VkImageDrmFormatModifierPropertiesEXT")]
pub struct ImageDrmFormatModifierPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub drm_format_modifier: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageDrmFormatModifierPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageDrmFormatModifierPropertiesEXT;
}
unsafe impl<'a> Send for ImageDrmFormatModifierPropertiesEXT<'a> {}
unsafe impl<'a> Sync for ImageDrmFormatModifierPropertiesEXT<'a> {}
impl<'a> Default for ImageDrmFormatModifierPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            drm_format_modifier: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageDrmFormatModifierPropertiesEXT<'a> {
    #[inline]
    pub fn drm_format_modifier(mut self, value: u64) -> Self {
        self.drm_format_modifier = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrmFormatModifierPropertiesList2EXT.html>"]
#[doc(alias = "VkDrmFormatModifierPropertiesList2EXT")]
pub struct DrmFormatModifierPropertiesList2EXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub drm_format_modifier_count: u32,
    pub(crate) p_drm_format_modifier_properties: *const DrmFormatModifierProperties2EXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DrmFormatModifierPropertiesList2EXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DrmFormatModifierPropertiesList2EXT;
}
unsafe impl<'a> Send for DrmFormatModifierPropertiesList2EXT<'a> {}
unsafe impl<'a> Sync for DrmFormatModifierPropertiesList2EXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<FormatProperties2<'b>>
    for DrmFormatModifierPropertiesList2EXT<'a>
{
}
impl<'a> Default for DrmFormatModifierPropertiesList2EXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            drm_format_modifier_count: Default::default(),
            p_drm_format_modifier_properties: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DrmFormatModifierPropertiesList2EXT<'a> {
    #[inline]
    pub fn drm_format_modifier_count(mut self, value: u32) -> Self {
        self.drm_format_modifier_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrmFormatModifierProperties2EXT.html>"]
#[doc(alias = "VkDrmFormatModifierProperties2EXT")]
pub struct DrmFormatModifierProperties2EXT {
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub drm_format_modifier_tiling_features: u32,
}
unsafe impl Send for DrmFormatModifierProperties2EXT {}
unsafe impl Sync for DrmFormatModifierProperties2EXT {}
impl Default for DrmFormatModifierProperties2EXT {
    fn default() -> Self {
        Self {
            drm_format_modifier: Default::default(),
            drm_format_modifier_plane_count: Default::default(),
            drm_format_modifier_tiling_features: Default::default(),
        }
    }
}
impl DrmFormatModifierProperties2EXT {
    #[inline]
    pub fn drm_format_modifier(mut self, value: u64) -> Self {
        self.drm_format_modifier = value;
        self
    }
    #[inline]
    pub fn drm_format_modifier_plane_count(mut self, value: u32) -> Self {
        self.drm_format_modifier_plane_count = value;
        self
    }
    #[inline]
    pub fn drm_format_modifier_tiling_features(mut self, value: u32) -> Self {
        self.drm_format_modifier_tiling_features = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationCacheCreateInfoEXT.html>"]
#[doc(alias = "VkValidationCacheCreateInfoEXT")]
pub struct ValidationCacheCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub(crate) initial_data_size: usize,
    pub(crate) p_initial_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ValidationCacheCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ValidationCacheCreateInfoEXT;
}
unsafe impl<'a> Send for ValidationCacheCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for ValidationCacheCreateInfoEXT<'a> {}
impl<'a> Default for ValidationCacheCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            initial_data_size: Default::default(),
            p_initial_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ValidationCacheCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn initial_data(mut self, p_initial_data: impl AsSlice<'a, u8>) -> Self {
        self.p_initial_data = p_initial_data.as_slice().as_ptr().cast();
        self.initial_data_size = p_initial_data.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleValidationCacheCreateInfoEXT.html>"]
#[doc(alias = "VkShaderModuleValidationCacheCreateInfoEXT")]
pub struct ShaderModuleValidationCacheCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub validation_cache: Option<ValidationCacheEXT>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ShaderModuleValidationCacheCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ShaderModuleValidationCacheCreateInfoEXT;
}
unsafe impl<'a> Send for ShaderModuleValidationCacheCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for ShaderModuleValidationCacheCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ShaderModuleCreateInfo<'b>>
    for ShaderModuleValidationCacheCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<PipelineShaderStageCreateInfo<'b>>
    for ShaderModuleValidationCacheCreateInfoEXT<'a>
{
}
impl<'a> Default for ShaderModuleValidationCacheCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            validation_cache: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ShaderModuleValidationCacheCreateInfoEXT<'a> {
    #[inline]
    pub fn validation_cache(mut self, value: &'a ValidationCacheEXT) -> Self {
        self.validation_cache = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDevicePortabilitySubsetFeaturesKHR")]
pub struct PhysicalDevicePortabilitySubsetFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub constant_alpha_color_blend_factors: Bool32,
    pub events: Bool32,
    pub image_view_format_reinterpretation: Bool32,
    pub image_view_format_swizzle: Bool32,
    pub image_view2_don3_dimage: Bool32,
    pub multisample_array_image: Bool32,
    pub mutable_comparison_samplers: Bool32,
    pub point_polygons: Bool32,
    pub sampler_mip_lod_bias: Bool32,
    pub separate_stencil_mask_ref: Bool32,
    pub shader_sample_rate_interpolation_functions: Bool32,
    pub tessellation_isolines: Bool32,
    pub tessellation_point_mode: Bool32,
    pub triangle_fans: Bool32,
    pub vertex_attribute_access_beyond_stride: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePortabilitySubsetFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDevicePortabilitySubsetFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDevicePortabilitySubsetFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePortabilitySubsetFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePortabilitySubsetFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePortabilitySubsetFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDevicePortabilitySubsetFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            constant_alpha_color_blend_factors: Default::default(),
            events: Default::default(),
            image_view_format_reinterpretation: Default::default(),
            image_view_format_swizzle: Default::default(),
            image_view2_don3_dimage: Default::default(),
            multisample_array_image: Default::default(),
            mutable_comparison_samplers: Default::default(),
            point_polygons: Default::default(),
            sampler_mip_lod_bias: Default::default(),
            separate_stencil_mask_ref: Default::default(),
            shader_sample_rate_interpolation_functions: Default::default(),
            tessellation_isolines: Default::default(),
            tessellation_point_mode: Default::default(),
            triangle_fans: Default::default(),
            vertex_attribute_access_beyond_stride: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePortabilitySubsetFeaturesKHR<'a> {
    #[inline]
    pub fn constant_alpha_color_blend_factors(mut self, value: impl Into<Bool32>) -> Self {
        self.constant_alpha_color_blend_factors = value.into();
        self
    }
    #[inline]
    pub fn events(mut self, value: impl Into<Bool32>) -> Self {
        self.events = value.into();
        self
    }
    #[inline]
    pub fn image_view_format_reinterpretation(mut self, value: impl Into<Bool32>) -> Self {
        self.image_view_format_reinterpretation = value.into();
        self
    }
    #[inline]
    pub fn image_view_format_swizzle(mut self, value: impl Into<Bool32>) -> Self {
        self.image_view_format_swizzle = value.into();
        self
    }
    #[inline]
    pub fn image_view2_don3_dimage(mut self, value: impl Into<Bool32>) -> Self {
        self.image_view2_don3_dimage = value.into();
        self
    }
    #[inline]
    pub fn multisample_array_image(mut self, value: impl Into<Bool32>) -> Self {
        self.multisample_array_image = value.into();
        self
    }
    #[inline]
    pub fn mutable_comparison_samplers(mut self, value: impl Into<Bool32>) -> Self {
        self.mutable_comparison_samplers = value.into();
        self
    }
    #[inline]
    pub fn point_polygons(mut self, value: impl Into<Bool32>) -> Self {
        self.point_polygons = value.into();
        self
    }
    #[inline]
    pub fn sampler_mip_lod_bias(mut self, value: impl Into<Bool32>) -> Self {
        self.sampler_mip_lod_bias = value.into();
        self
    }
    #[inline]
    pub fn separate_stencil_mask_ref(mut self, value: impl Into<Bool32>) -> Self {
        self.separate_stencil_mask_ref = value.into();
        self
    }
    #[inline]
    pub fn shader_sample_rate_interpolation_functions(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_sample_rate_interpolation_functions = value.into();
        self
    }
    #[inline]
    pub fn tessellation_isolines(mut self, value: impl Into<Bool32>) -> Self {
        self.tessellation_isolines = value.into();
        self
    }
    #[inline]
    pub fn tessellation_point_mode(mut self, value: impl Into<Bool32>) -> Self {
        self.tessellation_point_mode = value.into();
        self
    }
    #[inline]
    pub fn triangle_fans(mut self, value: impl Into<Bool32>) -> Self {
        self.triangle_fans = value.into();
        self
    }
    #[inline]
    pub fn vertex_attribute_access_beyond_stride(mut self, value: impl Into<Bool32>) -> Self {
        self.vertex_attribute_access_beyond_stride = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetPropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDevicePortabilitySubsetPropertiesKHR")]
pub struct PhysicalDevicePortabilitySubsetPropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub min_vertex_input_binding_stride_alignment: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePortabilitySubsetPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePortabilitySubsetPropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDevicePortabilitySubsetPropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePortabilitySubsetPropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDevicePortabilitySubsetPropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDevicePortabilitySubsetPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            min_vertex_input_binding_stride_alignment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePortabilitySubsetPropertiesKHR<'a> {
    #[inline]
    pub fn min_vertex_input_binding_stride_alignment(mut self, value: u32) -> Self {
        self.min_vertex_input_binding_stride_alignment = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShadingRatePaletteNV.html>"]
#[doc(alias = "VkShadingRatePaletteNV")]
pub struct ShadingRatePaletteNV<'a> {
    pub(crate) shading_rate_palette_entry_count: u32,
    pub(crate) p_shading_rate_palette_entries: *const ShadingRatePaletteEntryNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for ShadingRatePaletteNV<'a> {}
unsafe impl<'a> Sync for ShadingRatePaletteNV<'a> {}
impl<'a> Default for ShadingRatePaletteNV<'a> {
    fn default() -> Self {
        Self {
            shading_rate_palette_entry_count: Default::default(),
            p_shading_rate_palette_entries: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ShadingRatePaletteNV<'a> {
    #[inline]
    pub fn shading_rate_palette_entries(
        mut self,
        p_shading_rate_palette_entries: impl AsSlice<'a, ShadingRatePaletteEntryNV>,
    ) -> Self {
        self.p_shading_rate_palette_entries =
            p_shading_rate_palette_entries.as_slice().as_ptr().cast();
        self.shading_rate_palette_entry_count =
            p_shading_rate_palette_entries.as_slice().len() as _;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportShadingRateImageStateCreateInfoNV.html>"]
#[doc(alias = "VkPipelineViewportShadingRateImageStateCreateInfoNV")]
pub struct PipelineViewportShadingRateImageStateCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shading_rate_image_enable: Bool32,
    pub(crate) viewport_count: u32,
    pub(crate) p_shading_rate_palettes: *const ShadingRatePaletteNV<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineViewportShadingRateImageStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineViewportShadingRateImageStateCreateInfoNV;
}
unsafe impl<'a> Send for PipelineViewportShadingRateImageStateCreateInfoNV<'a> {}
unsafe impl<'a> Sync for PipelineViewportShadingRateImageStateCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineViewportStateCreateInfo<'b>>
    for PipelineViewportShadingRateImageStateCreateInfoNV<'a>
{
}
impl<'a> Default for PipelineViewportShadingRateImageStateCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shading_rate_image_enable: Default::default(),
            viewport_count: Default::default(),
            p_shading_rate_palettes: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineViewportShadingRateImageStateCreateInfoNV<'a> {
    #[inline]
    pub fn shading_rate_image_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.shading_rate_image_enable = value.into();
        self
    }
    #[inline]
    pub fn shading_rate_palettes(
        mut self,
        p_shading_rate_palettes: impl AsSlice<'a, ShadingRatePaletteNV<'a>>,
    ) -> Self {
        self.p_shading_rate_palettes = p_shading_rate_palettes.as_slice().as_ptr().cast();
        self.viewport_count = p_shading_rate_palettes.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShadingRateImageFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceShadingRateImageFeaturesNV")]
pub struct PhysicalDeviceShadingRateImageFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shading_rate_image: Bool32,
    pub shading_rate_coarse_sample_order: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShadingRateImageFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShadingRateImageFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceShadingRateImageFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShadingRateImageFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShadingRateImageFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShadingRateImageFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceShadingRateImageFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shading_rate_image: Default::default(),
            shading_rate_coarse_sample_order: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShadingRateImageFeaturesNV<'a> {
    #[inline]
    pub fn shading_rate_image(mut self, value: impl Into<Bool32>) -> Self {
        self.shading_rate_image = value.into();
        self
    }
    #[inline]
    pub fn shading_rate_coarse_sample_order(mut self, value: impl Into<Bool32>) -> Self {
        self.shading_rate_coarse_sample_order = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShadingRateImagePropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceShadingRateImagePropertiesNV")]
pub struct PhysicalDeviceShadingRateImagePropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shading_rate_texel_size: Extent2D,
    pub shading_rate_palette_size: u32,
    pub shading_rate_max_coarse_samples: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShadingRateImagePropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShadingRateImagePropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceShadingRateImagePropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShadingRateImagePropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceShadingRateImagePropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceShadingRateImagePropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shading_rate_texel_size: Default::default(),
            shading_rate_palette_size: Default::default(),
            shading_rate_max_coarse_samples: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShadingRateImagePropertiesNV<'a> {
    #[inline]
    pub fn shading_rate_texel_size(mut self, value: Extent2D) -> Self {
        self.shading_rate_texel_size = value;
        self
    }
    #[inline]
    pub fn shading_rate_palette_size(mut self, value: u32) -> Self {
        self.shading_rate_palette_size = value;
        self
    }
    #[inline]
    pub fn shading_rate_max_coarse_samples(mut self, value: u32) -> Self {
        self.shading_rate_max_coarse_samples = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCoarseSampleLocationNV.html>"]
#[doc(alias = "VkCoarseSampleLocationNV")]
pub struct CoarseSampleLocationNV {
    pub pixel_x: u32,
    pub pixel_y: u32,
    pub sample: u32,
}
unsafe impl Send for CoarseSampleLocationNV {}
unsafe impl Sync for CoarseSampleLocationNV {}
impl Default for CoarseSampleLocationNV {
    fn default() -> Self {
        Self {
            pixel_x: Default::default(),
            pixel_y: Default::default(),
            sample: Default::default(),
        }
    }
}
impl CoarseSampleLocationNV {
    #[inline]
    pub fn pixel_x(mut self, value: u32) -> Self {
        self.pixel_x = value;
        self
    }
    #[inline]
    pub fn pixel_y(mut self, value: u32) -> Self {
        self.pixel_y = value;
        self
    }
    #[inline]
    pub fn sample(mut self, value: u32) -> Self {
        self.sample = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCoarseSampleOrderCustomNV.html>"]
#[doc(alias = "VkCoarseSampleOrderCustomNV")]
pub struct CoarseSampleOrderCustomNV<'a> {
    pub shading_rate: ShadingRatePaletteEntryNV,
    pub sample_count: u32,
    pub(crate) sample_location_count: u32,
    pub(crate) p_sample_locations: *const CoarseSampleLocationNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for CoarseSampleOrderCustomNV<'a> {}
unsafe impl<'a> Sync for CoarseSampleOrderCustomNV<'a> {}
impl<'a> Default for CoarseSampleOrderCustomNV<'a> {
    fn default() -> Self {
        Self {
            shading_rate: ShadingRatePaletteEntryNV::NoInvocations,
            sample_count: Default::default(),
            sample_location_count: Default::default(),
            p_sample_locations: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CoarseSampleOrderCustomNV<'a> {
    #[inline]
    pub fn shading_rate(mut self, value: ShadingRatePaletteEntryNV) -> Self {
        self.shading_rate = value;
        self
    }
    #[inline]
    pub fn sample_count(mut self, value: u32) -> Self {
        self.sample_count = value;
        self
    }
    #[inline]
    pub fn sample_locations(
        mut self,
        p_sample_locations: impl AsSlice<'a, CoarseSampleLocationNV>,
    ) -> Self {
        self.p_sample_locations = p_sample_locations.as_slice().as_ptr().cast();
        self.sample_location_count = p_sample_locations.as_slice().len() as _;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.html>"]
#[doc(alias = "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV")]
pub struct PipelineViewportCoarseSampleOrderStateCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub sample_order_type: CoarseSampleOrderTypeNV,
    pub(crate) custom_sample_order_count: u32,
    pub(crate) p_custom_sample_orders: *const CoarseSampleOrderCustomNV<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineViewportCoarseSampleOrderStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineViewportCoarseSampleOrderStateCreateInfoNV;
}
unsafe impl<'a> Send for PipelineViewportCoarseSampleOrderStateCreateInfoNV<'a> {}
unsafe impl<'a> Sync for PipelineViewportCoarseSampleOrderStateCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineViewportStateCreateInfo<'b>>
    for PipelineViewportCoarseSampleOrderStateCreateInfoNV<'a>
{
}
impl<'a> Default for PipelineViewportCoarseSampleOrderStateCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            sample_order_type: CoarseSampleOrderTypeNV::Default,
            custom_sample_order_count: Default::default(),
            p_custom_sample_orders: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineViewportCoarseSampleOrderStateCreateInfoNV<'a> {
    #[inline]
    pub fn sample_order_type(mut self, value: CoarseSampleOrderTypeNV) -> Self {
        self.sample_order_type = value;
        self
    }
    #[inline]
    pub fn custom_sample_orders(
        mut self,
        p_custom_sample_orders: impl AsSlice<'a, CoarseSampleOrderCustomNV<'a>>,
    ) -> Self {
        self.p_custom_sample_orders = p_custom_sample_orders.as_slice().as_ptr().cast();
        self.custom_sample_order_count = p_custom_sample_orders.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingShaderGroupCreateInfoNV.html>"]
#[doc(alias = "VkRayTracingShaderGroupCreateInfoNV")]
pub struct RayTracingShaderGroupCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ty: RayTracingShaderGroupTypeKHR,
    pub general_shader: u32,
    pub closest_hit_shader: u32,
    pub any_hit_shader: u32,
    pub intersection_shader: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RayTracingShaderGroupCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RayTracingShaderGroupCreateInfoNV;
}
unsafe impl<'a> Send for RayTracingShaderGroupCreateInfoNV<'a> {}
unsafe impl<'a> Sync for RayTracingShaderGroupCreateInfoNV<'a> {}
impl<'a> Default for RayTracingShaderGroupCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ty: RayTracingShaderGroupTypeKHR::General,
            general_shader: Default::default(),
            closest_hit_shader: Default::default(),
            any_hit_shader: Default::default(),
            intersection_shader: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RayTracingShaderGroupCreateInfoNV<'a> {
    #[inline]
    pub fn ty(mut self, value: RayTracingShaderGroupTypeKHR) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn general_shader(mut self, value: u32) -> Self {
        self.general_shader = value;
        self
    }
    #[inline]
    pub fn closest_hit_shader(mut self, value: u32) -> Self {
        self.closest_hit_shader = value;
        self
    }
    #[inline]
    pub fn any_hit_shader(mut self, value: u32) -> Self {
        self.any_hit_shader = value;
        self
    }
    #[inline]
    pub fn intersection_shader(mut self, value: u32) -> Self {
        self.intersection_shader = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingPipelineCreateInfoNV.html>"]
#[doc(alias = "VkRayTracingPipelineCreateInfoNV")]
pub struct RayTracingPipelineCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: PipelineCreateFlags,
    pub(crate) stage_count: u32,
    pub(crate) p_stages: *const PipelineShaderStageCreateInfo<'a>,
    pub(crate) group_count: u32,
    pub(crate) p_groups: *const RayTracingShaderGroupCreateInfoNV<'a>,
    pub max_recursion_depth: u32,
    pub layout: Option<PipelineLayout>,
    pub base_pipeline_handle: Option<Pipeline>,
    pub base_pipeline_index: i32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RayTracingPipelineCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RayTracingPipelineCreateInfoNV;
}
unsafe impl<'a> Send for RayTracingPipelineCreateInfoNV<'a> {}
unsafe impl<'a> Sync for RayTracingPipelineCreateInfoNV<'a> {}
impl<'a> Default for RayTracingPipelineCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            stage_count: Default::default(),
            p_stages: ptr::null(),
            group_count: Default::default(),
            p_groups: ptr::null(),
            max_recursion_depth: Default::default(),
            layout: Default::default(),
            base_pipeline_handle: Default::default(),
            base_pipeline_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RayTracingPipelineCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, value: PipelineCreateFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn max_recursion_depth(mut self, value: u32) -> Self {
        self.max_recursion_depth = value;
        self
    }
    #[inline]
    pub fn layout(mut self, value: &'a PipelineLayout) -> Self {
        self.layout = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, value: Option<&'a Pipeline>) -> Self {
        self.base_pipeline_handle = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, value: i32) -> Self {
        self.base_pipeline_index = value;
        self
    }
    #[inline]
    pub fn stages(mut self, p_stages: impl AsSlice<'a, PipelineShaderStageCreateInfo<'a>>) -> Self {
        self.p_stages = p_stages.as_slice().as_ptr().cast();
        self.stage_count = p_stages.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn groups(
        mut self,
        p_groups: impl AsSlice<'a, RayTracingShaderGroupCreateInfoNV<'a>>,
    ) -> Self {
        self.p_groups = p_groups.as_slice().as_ptr().cast();
        self.group_count = p_groups.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeometryTrianglesNV.html>"]
#[doc(alias = "VkGeometryTrianglesNV")]
pub struct GeometryTrianglesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub vertex_data: Option<Buffer>,
    pub vertex_offset: DeviceSize,
    pub vertex_count: u32,
    pub vertex_stride: DeviceSize,
    pub vertex_format: Format,
    pub index_data: Option<Buffer>,
    pub index_offset: DeviceSize,
    pub index_count: u32,
    pub index_type: IndexType,
    pub transform_data: Option<Buffer>,
    pub transform_offset: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for GeometryTrianglesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GeometryTrianglesNV;
}
unsafe impl<'a> Send for GeometryTrianglesNV<'a> {}
unsafe impl<'a> Sync for GeometryTrianglesNV<'a> {}
impl<'a> Default for GeometryTrianglesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            vertex_data: Default::default(),
            vertex_offset: Default::default(),
            vertex_count: Default::default(),
            vertex_stride: Default::default(),
            vertex_format: Format::Undefined,
            index_data: Default::default(),
            index_offset: Default::default(),
            index_count: Default::default(),
            index_type: IndexType::Uint16,
            transform_data: Default::default(),
            transform_offset: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> GeometryTrianglesNV<'a> {
    #[inline]
    pub fn vertex_data(mut self, value: Option<&'a Buffer>) -> Self {
        self.vertex_data = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn vertex_offset(mut self, value: DeviceSize) -> Self {
        self.vertex_offset = value;
        self
    }
    #[inline]
    pub fn vertex_count(mut self, value: u32) -> Self {
        self.vertex_count = value;
        self
    }
    #[inline]
    pub fn vertex_stride(mut self, value: DeviceSize) -> Self {
        self.vertex_stride = value;
        self
    }
    #[inline]
    pub fn vertex_format(mut self, value: Format) -> Self {
        self.vertex_format = value;
        self
    }
    #[inline]
    pub fn index_data(mut self, value: Option<&'a Buffer>) -> Self {
        self.index_data = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn index_offset(mut self, value: DeviceSize) -> Self {
        self.index_offset = value;
        self
    }
    #[inline]
    pub fn index_count(mut self, value: u32) -> Self {
        self.index_count = value;
        self
    }
    #[inline]
    pub fn index_type(mut self, value: IndexType) -> Self {
        self.index_type = value;
        self
    }
    #[inline]
    pub fn transform_data(mut self, value: Option<&'a Buffer>) -> Self {
        self.transform_data = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn transform_offset(mut self, value: DeviceSize) -> Self {
        self.transform_offset = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeometryAABBNV.html>"]
#[doc(alias = "VkGeometryAABBNV")]
pub struct GeometryAABBNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub aabb_data: Option<Buffer>,
    pub num_aabbs: u32,
    pub stride: u32,
    pub offset: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for GeometryAABBNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GeometryAabbNV;
}
unsafe impl<'a> Send for GeometryAABBNV<'a> {}
unsafe impl<'a> Sync for GeometryAABBNV<'a> {}
impl<'a> Default for GeometryAABBNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            aabb_data: Default::default(),
            num_aabbs: Default::default(),
            stride: Default::default(),
            offset: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> GeometryAABBNV<'a> {
    #[inline]
    pub fn aabb_data(mut self, value: Option<&'a Buffer>) -> Self {
        self.aabb_data = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn num_aabbs(mut self, value: u32) -> Self {
        self.num_aabbs = value;
        self
    }
    #[inline]
    pub fn stride(mut self, value: u32) -> Self {
        self.stride = value;
        self
    }
    #[inline]
    pub fn offset(mut self, value: DeviceSize) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeometryDataNV.html>"]
#[doc(alias = "VkGeometryDataNV")]
pub struct GeometryDataNV<'a> {
    pub triangles: GeometryTrianglesNV<'a>,
    pub aabbs: GeometryAABBNV<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for GeometryDataNV<'a> {}
unsafe impl<'a> Sync for GeometryDataNV<'a> {}
impl<'a> Default for GeometryDataNV<'a> {
    fn default() -> Self {
        Self {
            triangles: Default::default(),
            aabbs: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> GeometryDataNV<'a> {
    #[inline]
    pub fn triangles(mut self, value: GeometryTrianglesNV<'a>) -> Self {
        self.triangles = value;
        self
    }
    #[inline]
    pub fn aabbs(mut self, value: GeometryAABBNV<'a>) -> Self {
        self.aabbs = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeometryNV.html>"]
#[doc(alias = "VkGeometryNV")]
pub struct GeometryNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub geometry_type: GeometryTypeKHR,
    pub geometry: GeometryDataNV<'a>,
    pub flags: GeometryFlagsKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for GeometryNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GeometryNV;
}
unsafe impl<'a> Send for GeometryNV<'a> {}
unsafe impl<'a> Sync for GeometryNV<'a> {}
impl<'a> Default for GeometryNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            geometry_type: GeometryTypeKHR::Triangles,
            geometry: Default::default(),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> GeometryNV<'a> {
    #[inline]
    pub fn geometry_type(mut self, value: GeometryTypeKHR) -> Self {
        self.geometry_type = value;
        self
    }
    #[inline]
    pub fn geometry(mut self, value: GeometryDataNV<'a>) -> Self {
        self.geometry = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: GeometryFlagsKHR) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureInfoNV.html>"]
#[doc(alias = "VkAccelerationStructureInfoNV")]
pub struct AccelerationStructureInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ty: AccelerationStructureTypeNV,
    pub flags: BuildAccelerationStructureFlagsNV,
    pub instance_count: u32,
    pub(crate) geometry_count: u32,
    pub(crate) p_geometries: *const GeometryNV<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AccelerationStructureInfoNV;
}
unsafe impl<'a> Send for AccelerationStructureInfoNV<'a> {}
unsafe impl<'a> Sync for AccelerationStructureInfoNV<'a> {}
impl<'a> Default for AccelerationStructureInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ty: AccelerationStructureTypeKHR::TopLevel,
            flags: Default::default(),
            instance_count: Default::default(),
            geometry_count: Default::default(),
            p_geometries: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureInfoNV<'a> {
    #[inline]
    pub fn ty(mut self, value: AccelerationStructureTypeNV) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: BuildAccelerationStructureFlagsNV) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn instance_count(mut self, value: u32) -> Self {
        self.instance_count = value;
        self
    }
    #[inline]
    pub fn geometries(mut self, p_geometries: impl AsSlice<'a, GeometryNV<'a>>) -> Self {
        self.p_geometries = p_geometries.as_slice().as_ptr().cast();
        self.geometry_count = p_geometries.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureCreateInfoNV.html>"]
#[doc(alias = "VkAccelerationStructureCreateInfoNV")]
pub struct AccelerationStructureCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub compacted_size: DeviceSize,
    pub info: AccelerationStructureInfoNV<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AccelerationStructureCreateInfoNV;
}
unsafe impl<'a> Send for AccelerationStructureCreateInfoNV<'a> {}
unsafe impl<'a> Sync for AccelerationStructureCreateInfoNV<'a> {}
impl<'a> Default for AccelerationStructureCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            compacted_size: Default::default(),
            info: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureCreateInfoNV<'a> {
    #[inline]
    pub fn compacted_size(mut self, value: DeviceSize) -> Self {
        self.compacted_size = value;
        self
    }
    #[inline]
    pub fn info(mut self, value: AccelerationStructureInfoNV<'a>) -> Self {
        self.info = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindAccelerationStructureMemoryInfoNV.html>"]
#[doc(alias = "VkBindAccelerationStructureMemoryInfoNV")]
pub struct BindAccelerationStructureMemoryInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub acceleration_structure: Option<AccelerationStructureNV>,
    pub memory: Option<DeviceMemory>,
    pub memory_offset: DeviceSize,
    pub(crate) device_index_count: u32,
    pub(crate) p_device_indices: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BindAccelerationStructureMemoryInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BindAccelerationStructureMemoryInfoNV;
}
unsafe impl<'a> Send for BindAccelerationStructureMemoryInfoNV<'a> {}
unsafe impl<'a> Sync for BindAccelerationStructureMemoryInfoNV<'a> {}
impl<'a> Default for BindAccelerationStructureMemoryInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            acceleration_structure: Default::default(),
            memory: Default::default(),
            memory_offset: Default::default(),
            device_index_count: Default::default(),
            p_device_indices: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BindAccelerationStructureMemoryInfoNV<'a> {
    #[inline]
    pub fn acceleration_structure(mut self, value: &'a AccelerationStructureNV) -> Self {
        self.acceleration_structure = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn memory_offset(mut self, value: DeviceSize) -> Self {
        self.memory_offset = value;
        self
    }
    #[inline]
    pub fn device_indices(mut self, p_device_indices: impl AsSlice<'a, u32>) -> Self {
        self.p_device_indices = p_device_indices.as_slice().as_ptr().cast();
        self.device_index_count = p_device_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetAccelerationStructureNV.html>"]
#[doc(alias = "VkWriteDescriptorSetAccelerationStructureNV")]
pub struct WriteDescriptorSetAccelerationStructureNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub acceleration_structure_count: u32,
    pub(crate) p_acceleration_structures: *const AccelerationStructureNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for WriteDescriptorSetAccelerationStructureNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::WriteDescriptorSetAccelerationStructureNV;
}
unsafe impl<'a> Send for WriteDescriptorSetAccelerationStructureNV<'a> {}
unsafe impl<'a> Sync for WriteDescriptorSetAccelerationStructureNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<WriteDescriptorSet<'b>>
    for WriteDescriptorSetAccelerationStructureNV<'a>
{
}
impl<'a> Default for WriteDescriptorSetAccelerationStructureNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            acceleration_structure_count: Default::default(),
            p_acceleration_structures: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> WriteDescriptorSetAccelerationStructureNV<'a> {
    #[inline]
    pub fn acceleration_structure_count(mut self, value: u32) -> Self {
        self.acceleration_structure_count = value;
        self
    }
    #[inline]
    pub fn acceleration_structures<V0: Alias<raw::AccelerationStructureNV> + 'a>(
        mut self,
        p_acceleration_structures: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_acceleration_structures = p_acceleration_structures.as_slice().as_ptr().cast();
        self.acceleration_structure_count = p_acceleration_structures.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMemoryRequirementsInfoNV.html>"]
#[doc(alias = "VkAccelerationStructureMemoryRequirementsInfoNV")]
pub struct AccelerationStructureMemoryRequirementsInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ty: AccelerationStructureMemoryRequirementsTypeNV,
    pub acceleration_structure: Option<AccelerationStructureNV>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureMemoryRequirementsInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::AccelerationStructureMemoryRequirementsInfoNV;
}
unsafe impl<'a> Send for AccelerationStructureMemoryRequirementsInfoNV<'a> {}
unsafe impl<'a> Sync for AccelerationStructureMemoryRequirementsInfoNV<'a> {}
impl<'a> Default for AccelerationStructureMemoryRequirementsInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ty: AccelerationStructureMemoryRequirementsTypeNV::Object,
            acceleration_structure: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureMemoryRequirementsInfoNV<'a> {
    #[inline]
    pub fn ty(mut self, value: AccelerationStructureMemoryRequirementsTypeNV) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn acceleration_structure(mut self, value: &'a AccelerationStructureNV) -> Self {
        self.acceleration_structure = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceRayTracingPropertiesNV")]
pub struct PhysicalDeviceRayTracingPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_group_handle_size: u32,
    pub max_recursion_depth: u32,
    pub max_shader_group_stride: u32,
    pub shader_group_base_alignment: u32,
    pub max_geometry_count: u64,
    pub max_instance_count: u64,
    pub max_triangle_count: u64,
    pub max_descriptor_set_acceleration_structures: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRayTracingPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceRayTracingPropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceRayTracingPropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRayTracingPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceRayTracingPropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceRayTracingPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_group_handle_size: Default::default(),
            max_recursion_depth: Default::default(),
            max_shader_group_stride: Default::default(),
            shader_group_base_alignment: Default::default(),
            max_geometry_count: Default::default(),
            max_instance_count: Default::default(),
            max_triangle_count: Default::default(),
            max_descriptor_set_acceleration_structures: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRayTracingPropertiesNV<'a> {
    #[inline]
    pub fn shader_group_handle_size(mut self, value: u32) -> Self {
        self.shader_group_handle_size = value;
        self
    }
    #[inline]
    pub fn max_recursion_depth(mut self, value: u32) -> Self {
        self.max_recursion_depth = value;
        self
    }
    #[inline]
    pub fn max_shader_group_stride(mut self, value: u32) -> Self {
        self.max_shader_group_stride = value;
        self
    }
    #[inline]
    pub fn shader_group_base_alignment(mut self, value: u32) -> Self {
        self.shader_group_base_alignment = value;
        self
    }
    #[inline]
    pub fn max_geometry_count(mut self, value: u64) -> Self {
        self.max_geometry_count = value;
        self
    }
    #[inline]
    pub fn max_instance_count(mut self, value: u64) -> Self {
        self.max_instance_count = value;
        self
    }
    #[inline]
    pub fn max_triangle_count(mut self, value: u64) -> Self {
        self.max_triangle_count = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_acceleration_structures(mut self, value: u32) -> Self {
        self.max_descriptor_set_acceleration_structures = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV")]
pub struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub representative_fragment_test: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceRepresentativeFragmentTestFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            representative_fragment_test: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'a> {
    #[inline]
    pub fn representative_fragment_test(mut self, value: impl Into<Bool32>) -> Self {
        self.representative_fragment_test = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRepresentativeFragmentTestStateCreateInfoNV.html>"]
#[doc(alias = "VkPipelineRepresentativeFragmentTestStateCreateInfoNV")]
pub struct PipelineRepresentativeFragmentTestStateCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub representative_fragment_test_enable: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineRepresentativeFragmentTestStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineRepresentativeFragmentTestStateCreateInfoNV;
}
unsafe impl<'a> Send for PipelineRepresentativeFragmentTestStateCreateInfoNV<'a> {}
unsafe impl<'a> Sync for PipelineRepresentativeFragmentTestStateCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for PipelineRepresentativeFragmentTestStateCreateInfoNV<'a>
{
}
impl<'a> Default for PipelineRepresentativeFragmentTestStateCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            representative_fragment_test_enable: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineRepresentativeFragmentTestStateCreateInfoNV<'a> {
    #[inline]
    pub fn representative_fragment_test_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.representative_fragment_test_enable = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageViewImageFormatInfoEXT.html>"]
#[doc(alias = "VkPhysicalDeviceImageViewImageFormatInfoEXT")]
pub struct PhysicalDeviceImageViewImageFormatInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_view_type: ImageViewType,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageViewImageFormatInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceImageViewImageFormatInfoEXT;
}
unsafe impl<'a> Send for PhysicalDeviceImageViewImageFormatInfoEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageViewImageFormatInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceImageFormatInfo2<'b>>
    for PhysicalDeviceImageViewImageFormatInfoEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceImageViewImageFormatInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_view_type: ImageViewType::Type1D,
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageViewImageFormatInfoEXT<'a> {
    #[inline]
    pub fn image_view_type(mut self, value: ImageViewType) -> Self {
        self.image_view_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFilterCubicImageViewImageFormatPropertiesEXT.html>"]
#[doc(alias = "VkFilterCubicImageViewImageFormatPropertiesEXT")]
pub struct FilterCubicImageViewImageFormatPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub filter_cubic: Bool32,
    pub filter_cubic_minmax: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for FilterCubicImageViewImageFormatPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::FilterCubicImageViewImageFormatPropertiesEXT;
}
unsafe impl<'a> Send for FilterCubicImageViewImageFormatPropertiesEXT<'a> {}
unsafe impl<'a> Sync for FilterCubicImageViewImageFormatPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageFormatProperties2<'b>>
    for FilterCubicImageViewImageFormatPropertiesEXT<'a>
{
}
impl<'a> Default for FilterCubicImageViewImageFormatPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            filter_cubic: Default::default(),
            filter_cubic_minmax: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> FilterCubicImageViewImageFormatPropertiesEXT<'a> {
    #[inline]
    pub fn filter_cubic(mut self, value: impl Into<Bool32>) -> Self {
        self.filter_cubic = value.into();
        self
    }
    #[inline]
    pub fn filter_cubic_minmax(mut self, value: impl Into<Bool32>) -> Self {
        self.filter_cubic_minmax = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryHostPointerInfoEXT.html>"]
#[doc(alias = "VkImportMemoryHostPointerInfoEXT")]
pub struct ImportMemoryHostPointerInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub p_host_pointer: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportMemoryHostPointerInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportMemoryHostPointerInfoEXT;
}
unsafe impl<'a> Send for ImportMemoryHostPointerInfoEXT<'a> {}
unsafe impl<'a> Sync for ImportMemoryHostPointerInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>>
    for ImportMemoryHostPointerInfoEXT<'a>
{
}
impl<'a> Default for ImportMemoryHostPointerInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_type: Default::default(),
            p_host_pointer: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportMemoryHostPointerInfoEXT<'a> {
    #[inline]
    pub fn handle_type(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn host_pointer(mut self, value: VoidPtr) -> Self {
        self.p_host_pointer = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHostPointerPropertiesEXT.html>"]
#[doc(alias = "VkMemoryHostPointerPropertiesEXT")]
pub struct MemoryHostPointerPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory_type_bits: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryHostPointerPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryHostPointerPropertiesEXT;
}
unsafe impl<'a> Send for MemoryHostPointerPropertiesEXT<'a> {}
unsafe impl<'a> Sync for MemoryHostPointerPropertiesEXT<'a> {}
impl<'a> Default for MemoryHostPointerPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory_type_bits: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryHostPointerPropertiesEXT<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, value: u32) -> Self {
        self.memory_type_bits = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalMemoryHostPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceExternalMemoryHostPropertiesEXT")]
pub struct PhysicalDeviceExternalMemoryHostPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub min_imported_host_pointer_alignment: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExternalMemoryHostPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceExternalMemoryHostPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceExternalMemoryHostPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExternalMemoryHostPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceExternalMemoryHostPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceExternalMemoryHostPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            min_imported_host_pointer_alignment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExternalMemoryHostPropertiesEXT<'a> {
    #[inline]
    pub fn min_imported_host_pointer_alignment(mut self, value: DeviceSize) -> Self {
        self.min_imported_host_pointer_alignment = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderClockFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceShaderClockFeaturesKHR")]
pub struct PhysicalDeviceShaderClockFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_subgroup_clock: Bool32,
    pub shader_device_clock: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderClockFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderClockFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceShaderClockFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderClockFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderClockFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderClockFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderClockFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_subgroup_clock: Default::default(),
            shader_device_clock: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderClockFeaturesKHR<'a> {
    #[inline]
    pub fn shader_subgroup_clock(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_subgroup_clock = value.into();
        self
    }
    #[inline]
    pub fn shader_device_clock(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_device_clock = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCompilerControlCreateInfoAMD.html>"]
#[doc(alias = "VkPipelineCompilerControlCreateInfoAMD")]
pub struct PipelineCompilerControlCreateInfoAMD<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub compiler_control_flags: PipelineCompilerControlFlagsAMD,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineCompilerControlCreateInfoAMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineCompilerControlCreateInfoAMD;
}
unsafe impl<'a> Send for PipelineCompilerControlCreateInfoAMD<'a> {}
unsafe impl<'a> Sync for PipelineCompilerControlCreateInfoAMD<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for PipelineCompilerControlCreateInfoAMD<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<ComputePipelineCreateInfo<'b>>
    for PipelineCompilerControlCreateInfoAMD<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<ExecutionGraphPipelineCreateInfoAMDX<'b>>
    for PipelineCompilerControlCreateInfoAMD<'a>
{
}
impl<'a> Default for PipelineCompilerControlCreateInfoAMD<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            compiler_control_flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineCompilerControlCreateInfoAMD<'a> {
    #[inline]
    pub fn compiler_control_flags(mut self, value: PipelineCompilerControlFlagsAMD) -> Self {
        self.compiler_control_flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCorePropertiesAMD.html>"]
#[doc(alias = "VkPhysicalDeviceShaderCorePropertiesAMD")]
pub struct PhysicalDeviceShaderCorePropertiesAMD<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_engine_count: u32,
    pub shader_arrays_per_engine_count: u32,
    pub compute_units_per_shader_array: u32,
    pub simd_per_compute_unit: u32,
    pub wavefronts_per_simd: u32,
    pub wavefront_size: u32,
    pub sgprs_per_simd: u32,
    pub min_sgpr_allocation: u32,
    pub max_sgpr_allocation: u32,
    pub sgpr_allocation_granularity: u32,
    pub vgprs_per_simd: u32,
    pub min_vgpr_allocation: u32,
    pub max_vgpr_allocation: u32,
    pub vgpr_allocation_granularity: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderCorePropertiesAMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderCorePropertiesAMD;
}
unsafe impl<'a> Send for PhysicalDeviceShaderCorePropertiesAMD<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderCorePropertiesAMD<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceShaderCorePropertiesAMD<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderCorePropertiesAMD<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_engine_count: Default::default(),
            shader_arrays_per_engine_count: Default::default(),
            compute_units_per_shader_array: Default::default(),
            simd_per_compute_unit: Default::default(),
            wavefronts_per_simd: Default::default(),
            wavefront_size: Default::default(),
            sgprs_per_simd: Default::default(),
            min_sgpr_allocation: Default::default(),
            max_sgpr_allocation: Default::default(),
            sgpr_allocation_granularity: Default::default(),
            vgprs_per_simd: Default::default(),
            min_vgpr_allocation: Default::default(),
            max_vgpr_allocation: Default::default(),
            vgpr_allocation_granularity: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderCorePropertiesAMD<'a> {
    #[inline]
    pub fn shader_engine_count(mut self, value: u32) -> Self {
        self.shader_engine_count = value;
        self
    }
    #[inline]
    pub fn shader_arrays_per_engine_count(mut self, value: u32) -> Self {
        self.shader_arrays_per_engine_count = value;
        self
    }
    #[inline]
    pub fn compute_units_per_shader_array(mut self, value: u32) -> Self {
        self.compute_units_per_shader_array = value;
        self
    }
    #[inline]
    pub fn simd_per_compute_unit(mut self, value: u32) -> Self {
        self.simd_per_compute_unit = value;
        self
    }
    #[inline]
    pub fn wavefronts_per_simd(mut self, value: u32) -> Self {
        self.wavefronts_per_simd = value;
        self
    }
    #[inline]
    pub fn wavefront_size(mut self, value: u32) -> Self {
        self.wavefront_size = value;
        self
    }
    #[inline]
    pub fn sgprs_per_simd(mut self, value: u32) -> Self {
        self.sgprs_per_simd = value;
        self
    }
    #[inline]
    pub fn min_sgpr_allocation(mut self, value: u32) -> Self {
        self.min_sgpr_allocation = value;
        self
    }
    #[inline]
    pub fn max_sgpr_allocation(mut self, value: u32) -> Self {
        self.max_sgpr_allocation = value;
        self
    }
    #[inline]
    pub fn sgpr_allocation_granularity(mut self, value: u32) -> Self {
        self.sgpr_allocation_granularity = value;
        self
    }
    #[inline]
    pub fn vgprs_per_simd(mut self, value: u32) -> Self {
        self.vgprs_per_simd = value;
        self
    }
    #[inline]
    pub fn min_vgpr_allocation(mut self, value: u32) -> Self {
        self.min_vgpr_allocation = value;
        self
    }
    #[inline]
    pub fn max_vgpr_allocation(mut self, value: u32) -> Self {
        self.max_vgpr_allocation = value;
        self
    }
    #[inline]
    pub fn vgpr_allocation_granularity(mut self, value: u32) -> Self {
        self.vgpr_allocation_granularity = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueGlobalPriorityCreateInfoKHR.html>"]
#[doc(alias = "VkDeviceQueueGlobalPriorityCreateInfoKHR")]
pub struct DeviceQueueGlobalPriorityCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub global_priority: QueueGlobalPriorityKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceQueueGlobalPriorityCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceQueueGlobalPriorityCreateInfoKHR;
}
unsafe impl<'a> Send for DeviceQueueGlobalPriorityCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for DeviceQueueGlobalPriorityCreateInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DeviceQueueCreateInfo<'b>>
    for DeviceQueueGlobalPriorityCreateInfoKHR<'a>
{
}
impl<'a> Default for DeviceQueueGlobalPriorityCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            global_priority: QueueGlobalPriorityKHR::Low,
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceQueueGlobalPriorityCreateInfoKHR<'a> {
    #[inline]
    pub fn global_priority(mut self, value: QueueGlobalPriorityKHR) -> Self {
        self.global_priority = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type DeviceQueueGlobalPriorityCreateInfoEXT<'a> = DeviceQueueGlobalPriorityCreateInfoKHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR")]
pub struct PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub global_priority_query: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceGlobalPriorityQueryFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            global_priority_query: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'a> {
    #[inline]
    pub fn global_priority_query(mut self, value: impl Into<Bool32>) -> Self {
        self.global_priority_query = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceGlobalPriorityQueryFeaturesEXT<'a> =
    PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyGlobalPriorityPropertiesKHR.html>"]
#[doc(alias = "VkQueueFamilyGlobalPriorityPropertiesKHR")]
pub struct QueueFamilyGlobalPriorityPropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) priority_count: u32,
    pub(crate) priorities: [QueueGlobalPriorityKHR; MAX_GLOBAL_PRIORITY_SIZE_KHR as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for QueueFamilyGlobalPriorityPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QueueFamilyGlobalPriorityPropertiesKHR;
}
unsafe impl<'a> Send for QueueFamilyGlobalPriorityPropertiesKHR<'a> {}
unsafe impl<'a> Sync for QueueFamilyGlobalPriorityPropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<QueueFamilyProperties2<'b>>
    for QueueFamilyGlobalPriorityPropertiesKHR<'a>
{
}
impl<'a> Default for QueueFamilyGlobalPriorityPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            priority_count: Default::default(),
            priorities: array::from_fn(|_| QueueGlobalPriorityKHR::Low),
            phantom: PhantomData,
        }
    }
}
impl<'a> QueueFamilyGlobalPriorityPropertiesKHR<'a> {
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type QueueFamilyGlobalPriorityPropertiesEXT<'a> = QueueFamilyGlobalPriorityPropertiesKHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryOverallocationCreateInfoAMD.html>"]
#[doc(alias = "VkDeviceMemoryOverallocationCreateInfoAMD")]
pub struct DeviceMemoryOverallocationCreateInfoAMD<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub overallocation_behavior: MemoryOverallocationBehaviorAMD,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceMemoryOverallocationCreateInfoAMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceMemoryOverallocationCreateInfoAMD;
}
unsafe impl<'a> Send for DeviceMemoryOverallocationCreateInfoAMD<'a> {}
unsafe impl<'a> Sync for DeviceMemoryOverallocationCreateInfoAMD<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for DeviceMemoryOverallocationCreateInfoAMD<'a>
{
}
impl<'a> Default for DeviceMemoryOverallocationCreateInfoAMD<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            overallocation_behavior: MemoryOverallocationBehaviorAMD::Default,
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceMemoryOverallocationCreateInfoAMD<'a> {
    #[inline]
    pub fn overallocation_behavior(mut self, value: MemoryOverallocationBehaviorAMD) -> Self {
        self.overallocation_behavior = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT")]
pub struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_vertex_attrib_divisor: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceVertexAttributeDivisorPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceVertexAttributeDivisorPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceVertexAttributeDivisorPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceVertexAttributeDivisorPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceVertexAttributeDivisorPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceVertexAttributeDivisorPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_vertex_attrib_divisor: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceVertexAttributeDivisorPropertiesEXT<'a> {
    #[inline]
    pub fn max_vertex_attrib_divisor(mut self, value: u32) -> Self {
        self.max_vertex_attrib_divisor = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentFrameTokenGGP.html>"]
#[doc(alias = "VkPresentFrameTokenGGP")]
pub struct PresentFrameTokenGGP<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub frame_token: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PresentFrameTokenGGP<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PresentFrameTokenGGP;
}
unsafe impl<'a> Send for PresentFrameTokenGGP<'a> {}
unsafe impl<'a> Sync for PresentFrameTokenGGP<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PresentInfoKHR<'b>> for PresentFrameTokenGGP<'a> {}
impl<'a> Default for PresentFrameTokenGGP<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            frame_token: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PresentFrameTokenGGP<'a> {
    #[inline]
    pub fn frame_token(mut self, value: VoidPtr) -> Self {
        self.frame_token = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV")]
pub struct PhysicalDeviceComputeShaderDerivativesFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub compute_derivative_group_quads: Bool32,
    pub compute_derivative_group_linear: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceComputeShaderDerivativesFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceComputeShaderDerivativesFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceComputeShaderDerivativesFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceComputeShaderDerivativesFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceComputeShaderDerivativesFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceComputeShaderDerivativesFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceComputeShaderDerivativesFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            compute_derivative_group_quads: Default::default(),
            compute_derivative_group_linear: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceComputeShaderDerivativesFeaturesNV<'a> {
    #[inline]
    pub fn compute_derivative_group_quads(mut self, value: impl Into<Bool32>) -> Self {
        self.compute_derivative_group_quads = value.into();
        self
    }
    #[inline]
    pub fn compute_derivative_group_linear(mut self, value: impl Into<Bool32>) -> Self {
        self.compute_derivative_group_linear = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceMeshShaderFeaturesNV")]
pub struct PhysicalDeviceMeshShaderFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub task_shader: Bool32,
    pub mesh_shader: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMeshShaderFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMeshShaderFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceMeshShaderFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMeshShaderFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMeshShaderFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMeshShaderFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceMeshShaderFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            task_shader: Default::default(),
            mesh_shader: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMeshShaderFeaturesNV<'a> {
    #[inline]
    pub fn task_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.task_shader = value.into();
        self
    }
    #[inline]
    pub fn mesh_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.mesh_shader = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderPropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceMeshShaderPropertiesNV")]
pub struct PhysicalDeviceMeshShaderPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_draw_mesh_tasks_count: u32,
    pub max_task_work_group_invocations: u32,
    pub max_task_work_group_size: [u32; 3u16 as _],
    pub max_task_total_memory_size: u32,
    pub max_task_output_count: u32,
    pub max_mesh_work_group_invocations: u32,
    pub max_mesh_work_group_size: [u32; 3u16 as _],
    pub max_mesh_total_memory_size: u32,
    pub max_mesh_output_vertices: u32,
    pub max_mesh_output_primitives: u32,
    pub max_mesh_multiview_view_count: u32,
    pub mesh_output_per_vertex_granularity: u32,
    pub mesh_output_per_primitive_granularity: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMeshShaderPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMeshShaderPropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceMeshShaderPropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMeshShaderPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceMeshShaderPropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceMeshShaderPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_draw_mesh_tasks_count: Default::default(),
            max_task_work_group_invocations: Default::default(),
            max_task_work_group_size: array::from_fn(|_| Default::default()),
            max_task_total_memory_size: Default::default(),
            max_task_output_count: Default::default(),
            max_mesh_work_group_invocations: Default::default(),
            max_mesh_work_group_size: array::from_fn(|_| Default::default()),
            max_mesh_total_memory_size: Default::default(),
            max_mesh_output_vertices: Default::default(),
            max_mesh_output_primitives: Default::default(),
            max_mesh_multiview_view_count: Default::default(),
            mesh_output_per_vertex_granularity: Default::default(),
            mesh_output_per_primitive_granularity: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMeshShaderPropertiesNV<'a> {
    #[inline]
    pub fn max_draw_mesh_tasks_count(mut self, value: u32) -> Self {
        self.max_draw_mesh_tasks_count = value;
        self
    }
    #[inline]
    pub fn max_task_work_group_invocations(mut self, value: u32) -> Self {
        self.max_task_work_group_invocations = value;
        self
    }
    #[inline]
    pub fn max_task_work_group_size(mut self, value: [u32; 3u16 as _]) -> Self {
        self.max_task_work_group_size = value;
        self
    }
    #[inline]
    pub fn max_task_total_memory_size(mut self, value: u32) -> Self {
        self.max_task_total_memory_size = value;
        self
    }
    #[inline]
    pub fn max_task_output_count(mut self, value: u32) -> Self {
        self.max_task_output_count = value;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_invocations(mut self, value: u32) -> Self {
        self.max_mesh_work_group_invocations = value;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_size(mut self, value: [u32; 3u16 as _]) -> Self {
        self.max_mesh_work_group_size = value;
        self
    }
    #[inline]
    pub fn max_mesh_total_memory_size(mut self, value: u32) -> Self {
        self.max_mesh_total_memory_size = value;
        self
    }
    #[inline]
    pub fn max_mesh_output_vertices(mut self, value: u32) -> Self {
        self.max_mesh_output_vertices = value;
        self
    }
    #[inline]
    pub fn max_mesh_output_primitives(mut self, value: u32) -> Self {
        self.max_mesh_output_primitives = value;
        self
    }
    #[inline]
    pub fn max_mesh_multiview_view_count(mut self, value: u32) -> Self {
        self.max_mesh_multiview_view_count = value;
        self
    }
    #[inline]
    pub fn mesh_output_per_vertex_granularity(mut self, value: u32) -> Self {
        self.mesh_output_per_vertex_granularity = value;
        self
    }
    #[inline]
    pub fn mesh_output_per_primitive_granularity(mut self, value: u32) -> Self {
        self.mesh_output_per_primitive_granularity = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawMeshTasksIndirectCommandNV.html>"]
#[doc(alias = "VkDrawMeshTasksIndirectCommandNV")]
pub struct DrawMeshTasksIndirectCommandNV {
    pub task_count: u32,
    pub first_task: u32,
}
unsafe impl Send for DrawMeshTasksIndirectCommandNV {}
unsafe impl Sync for DrawMeshTasksIndirectCommandNV {}
impl Default for DrawMeshTasksIndirectCommandNV {
    fn default() -> Self {
        Self {
            task_count: Default::default(),
            first_task: Default::default(),
        }
    }
}
impl DrawMeshTasksIndirectCommandNV {
    #[inline]
    pub fn task_count(mut self, value: u32) -> Self {
        self.task_count = value;
        self
    }
    #[inline]
    pub fn first_task(mut self, value: u32) -> Self {
        self.first_task = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderImageFootprintFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceShaderImageFootprintFeaturesNV")]
pub struct PhysicalDeviceShaderImageFootprintFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_footprint: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderImageFootprintFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderImageFootprintFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceShaderImageFootprintFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderImageFootprintFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderImageFootprintFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderImageFootprintFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderImageFootprintFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_footprint: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderImageFootprintFeaturesNV<'a> {
    #[inline]
    pub fn image_footprint(mut self, value: impl Into<Bool32>) -> Self {
        self.image_footprint = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportExclusiveScissorStateCreateInfoNV.html>"]
#[doc(alias = "VkPipelineViewportExclusiveScissorStateCreateInfoNV")]
pub struct PipelineViewportExclusiveScissorStateCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) exclusive_scissor_count: u32,
    pub(crate) p_exclusive_scissors: *const Rect2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineViewportExclusiveScissorStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineViewportExclusiveScissorStateCreateInfoNV;
}
unsafe impl<'a> Send for PipelineViewportExclusiveScissorStateCreateInfoNV<'a> {}
unsafe impl<'a> Sync for PipelineViewportExclusiveScissorStateCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineViewportStateCreateInfo<'b>>
    for PipelineViewportExclusiveScissorStateCreateInfoNV<'a>
{
}
impl<'a> Default for PipelineViewportExclusiveScissorStateCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            exclusive_scissor_count: Default::default(),
            p_exclusive_scissors: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineViewportExclusiveScissorStateCreateInfoNV<'a> {
    #[inline]
    pub fn exclusive_scissors(mut self, p_exclusive_scissors: impl AsSlice<'a, Rect2D>) -> Self {
        self.p_exclusive_scissors = p_exclusive_scissors.as_slice().as_ptr().cast();
        self.exclusive_scissor_count = p_exclusive_scissors.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExclusiveScissorFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceExclusiveScissorFeaturesNV")]
pub struct PhysicalDeviceExclusiveScissorFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub exclusive_scissor: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExclusiveScissorFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceExclusiveScissorFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceExclusiveScissorFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExclusiveScissorFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceExclusiveScissorFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceExclusiveScissorFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceExclusiveScissorFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            exclusive_scissor: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExclusiveScissorFeaturesNV<'a> {
    #[inline]
    pub fn exclusive_scissor(mut self, value: impl Into<Bool32>) -> Self {
        self.exclusive_scissor = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyCheckpointPropertiesNV.html>"]
#[doc(alias = "VkQueueFamilyCheckpointPropertiesNV")]
pub struct QueueFamilyCheckpointPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub checkpoint_execution_stage_mask: PipelineStageFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for QueueFamilyCheckpointPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QueueFamilyCheckpointPropertiesNV;
}
unsafe impl<'a> Send for QueueFamilyCheckpointPropertiesNV<'a> {}
unsafe impl<'a> Sync for QueueFamilyCheckpointPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<QueueFamilyProperties2<'b>>
    for QueueFamilyCheckpointPropertiesNV<'a>
{
}
impl<'a> Default for QueueFamilyCheckpointPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            checkpoint_execution_stage_mask: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> QueueFamilyCheckpointPropertiesNV<'a> {
    #[inline]
    pub fn checkpoint_execution_stage_mask(mut self, value: PipelineStageFlags) -> Self {
        self.checkpoint_execution_stage_mask = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCheckpointDataNV.html>"]
#[doc(alias = "VkCheckpointDataNV")]
pub struct CheckpointDataNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub stage: PipelineStageFlags,
    pub p_checkpoint_marker: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CheckpointDataNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CheckpointDataNV;
}
unsafe impl<'a> Send for CheckpointDataNV<'a> {}
unsafe impl<'a> Sync for CheckpointDataNV<'a> {}
impl<'a> Default for CheckpointDataNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stage: Default::default(),
            p_checkpoint_marker: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CheckpointDataNV<'a> {
    #[inline]
    pub fn stage(mut self, value: PipelineStageFlags) -> Self {
        self.stage = value;
        self
    }
    #[inline]
    pub fn checkpoint_marker(mut self, value: VoidPtr) -> Self {
        self.p_checkpoint_marker = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.html>"]
#[doc(alias = "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL")]
pub struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_integer_functions2: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
}
unsafe impl<'a> Send for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_integer_functions2: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'a> {
    #[inline]
    pub fn shader_integer_functions2(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_integer_functions2 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceValueDataINTEL.html>"]
#[doc(alias = "VkPerformanceValueDataINTEL")]
pub union PerformanceValueDataINTEL {
    pub value32: u32,
    pub value64: u64,
    pub value_float: f32,
    pub value_bool: Bool32,
    pub value_string: ManuallyDrop<*const c_char>,
}
impl Default for PerformanceValueDataINTEL {
    fn default() -> Self {
        Self {
            value32: Default::default(),
        }
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceValueINTEL.html>"]
#[doc(alias = "VkPerformanceValueINTEL")]
pub struct PerformanceValueINTEL {
    pub ty: PerformanceValueTypeINTEL,
    pub data: PerformanceValueDataINTEL,
}
unsafe impl Send for PerformanceValueINTEL {}
unsafe impl Sync for PerformanceValueINTEL {}
impl Default for PerformanceValueINTEL {
    fn default() -> Self {
        Self {
            ty: PerformanceValueTypeINTEL::Uint32,
            data: Default::default(),
        }
    }
}
impl PerformanceValueINTEL {
    #[inline]
    pub fn ty(mut self, value: PerformanceValueTypeINTEL) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn data(mut self, value: PerformanceValueDataINTEL) -> Self {
        self.data = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInitializePerformanceApiInfoINTEL.html>"]
#[doc(alias = "VkInitializePerformanceApiInfoINTEL")]
pub struct InitializePerformanceApiInfoINTEL<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_user_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for InitializePerformanceApiInfoINTEL<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::InitializePerformanceApiInfoINTEL;
}
unsafe impl<'a> Send for InitializePerformanceApiInfoINTEL<'a> {}
unsafe impl<'a> Sync for InitializePerformanceApiInfoINTEL<'a> {}
impl<'a> Default for InitializePerformanceApiInfoINTEL<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_user_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> InitializePerformanceApiInfoINTEL<'a> {
    #[inline]
    pub fn user_data(mut self, value: VoidPtr) -> Self {
        self.p_user_data = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolPerformanceQueryCreateInfoINTEL.html>"]
#[doc(alias = "VkQueryPoolPerformanceQueryCreateInfoINTEL")]
pub struct QueryPoolPerformanceQueryCreateInfoINTEL<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub performance_counters_sampling: QueryPoolSamplingModeINTEL,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for QueryPoolPerformanceQueryCreateInfoINTEL<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QueryPoolPerformanceQueryCreateInfoINTEL;
}
unsafe impl<'a> Send for QueryPoolPerformanceQueryCreateInfoINTEL<'a> {}
unsafe impl<'a> Sync for QueryPoolPerformanceQueryCreateInfoINTEL<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<QueryPoolCreateInfo<'b>>
    for QueryPoolPerformanceQueryCreateInfoINTEL<'a>
{
}
impl<'a> Default for QueryPoolPerformanceQueryCreateInfoINTEL<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            performance_counters_sampling: QueryPoolSamplingModeINTEL::Manual,
            phantom: PhantomData,
        }
    }
}
impl<'a> QueryPoolPerformanceQueryCreateInfoINTEL<'a> {
    #[inline]
    pub fn performance_counters_sampling(mut self, value: QueryPoolSamplingModeINTEL) -> Self {
        self.performance_counters_sampling = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type QueryPoolCreateInfoINTEL<'a> = QueryPoolPerformanceQueryCreateInfoINTEL<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceMarkerInfoINTEL.html>"]
#[doc(alias = "VkPerformanceMarkerInfoINTEL")]
pub struct PerformanceMarkerInfoINTEL<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub marker: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PerformanceMarkerInfoINTEL<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PerformanceMarkerInfoINTEL;
}
unsafe impl<'a> Send for PerformanceMarkerInfoINTEL<'a> {}
unsafe impl<'a> Sync for PerformanceMarkerInfoINTEL<'a> {}
impl<'a> Default for PerformanceMarkerInfoINTEL<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            marker: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PerformanceMarkerInfoINTEL<'a> {
    #[inline]
    pub fn marker(mut self, value: u64) -> Self {
        self.marker = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceStreamMarkerInfoINTEL.html>"]
#[doc(alias = "VkPerformanceStreamMarkerInfoINTEL")]
pub struct PerformanceStreamMarkerInfoINTEL<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub marker: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PerformanceStreamMarkerInfoINTEL<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PerformanceStreamMarkerInfoINTEL;
}
unsafe impl<'a> Send for PerformanceStreamMarkerInfoINTEL<'a> {}
unsafe impl<'a> Sync for PerformanceStreamMarkerInfoINTEL<'a> {}
impl<'a> Default for PerformanceStreamMarkerInfoINTEL<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            marker: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PerformanceStreamMarkerInfoINTEL<'a> {
    #[inline]
    pub fn marker(mut self, value: u32) -> Self {
        self.marker = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceOverrideInfoINTEL.html>"]
#[doc(alias = "VkPerformanceOverrideInfoINTEL")]
pub struct PerformanceOverrideInfoINTEL<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ty: PerformanceOverrideTypeINTEL,
    pub enable: Bool32,
    pub parameter: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PerformanceOverrideInfoINTEL<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PerformanceOverrideInfoINTEL;
}
unsafe impl<'a> Send for PerformanceOverrideInfoINTEL<'a> {}
unsafe impl<'a> Sync for PerformanceOverrideInfoINTEL<'a> {}
impl<'a> Default for PerformanceOverrideInfoINTEL<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ty: PerformanceOverrideTypeINTEL::NullHardware,
            enable: Default::default(),
            parameter: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PerformanceOverrideInfoINTEL<'a> {
    #[inline]
    pub fn ty(mut self, value: PerformanceOverrideTypeINTEL) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn enable(mut self, value: impl Into<Bool32>) -> Self {
        self.enable = value.into();
        self
    }
    #[inline]
    pub fn parameter(mut self, value: u64) -> Self {
        self.parameter = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceConfigurationAcquireInfoINTEL.html>"]
#[doc(alias = "VkPerformanceConfigurationAcquireInfoINTEL")]
pub struct PerformanceConfigurationAcquireInfoINTEL<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ty: PerformanceConfigurationTypeINTEL,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PerformanceConfigurationAcquireInfoINTEL<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PerformanceConfigurationAcquireInfoINTEL;
}
unsafe impl<'a> Send for PerformanceConfigurationAcquireInfoINTEL<'a> {}
unsafe impl<'a> Sync for PerformanceConfigurationAcquireInfoINTEL<'a> {}
impl<'a> Default for PerformanceConfigurationAcquireInfoINTEL<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ty: PerformanceConfigurationTypeINTEL::CommandQueueMetricsDiscoveryActivated,
            phantom: PhantomData,
        }
    }
}
impl<'a> PerformanceConfigurationAcquireInfoINTEL<'a> {
    #[inline]
    pub fn ty(mut self, value: PerformanceConfigurationTypeINTEL) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePCIBusInfoPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDevicePCIBusInfoPropertiesEXT")]
pub struct PhysicalDevicePCIBusInfoPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pci_domain: u32,
    pub pci_bus: u32,
    pub pci_device: u32,
    pub pci_function: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePCIBusInfoPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDevicePciBusInfoPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDevicePCIBusInfoPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePCIBusInfoPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDevicePCIBusInfoPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDevicePCIBusInfoPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pci_domain: Default::default(),
            pci_bus: Default::default(),
            pci_device: Default::default(),
            pci_function: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePCIBusInfoPropertiesEXT<'a> {
    #[inline]
    pub fn pci_domain(mut self, value: u32) -> Self {
        self.pci_domain = value;
        self
    }
    #[inline]
    pub fn pci_bus(mut self, value: u32) -> Self {
        self.pci_bus = value;
        self
    }
    #[inline]
    pub fn pci_device(mut self, value: u32) -> Self {
        self.pci_device = value;
        self
    }
    #[inline]
    pub fn pci_function(mut self, value: u32) -> Self {
        self.pci_function = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayNativeHdrSurfaceCapabilitiesAMD.html>"]
#[doc(alias = "VkDisplayNativeHdrSurfaceCapabilitiesAMD")]
pub struct DisplayNativeHdrSurfaceCapabilitiesAMD<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub local_dimming_support: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DisplayNativeHdrSurfaceCapabilitiesAMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DisplayNativeHdrSurfaceCapabilitiesAMD;
}
unsafe impl<'a> Send for DisplayNativeHdrSurfaceCapabilitiesAMD<'a> {}
unsafe impl<'a> Sync for DisplayNativeHdrSurfaceCapabilitiesAMD<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SurfaceCapabilities2KHR<'b>>
    for DisplayNativeHdrSurfaceCapabilitiesAMD<'a>
{
}
impl<'a> Default for DisplayNativeHdrSurfaceCapabilitiesAMD<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            local_dimming_support: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DisplayNativeHdrSurfaceCapabilitiesAMD<'a> {
    #[inline]
    pub fn local_dimming_support(mut self, value: impl Into<Bool32>) -> Self {
        self.local_dimming_support = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainDisplayNativeHdrCreateInfoAMD.html>"]
#[doc(alias = "VkSwapchainDisplayNativeHdrCreateInfoAMD")]
pub struct SwapchainDisplayNativeHdrCreateInfoAMD<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub local_dimming_enable: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SwapchainDisplayNativeHdrCreateInfoAMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SwapchainDisplayNativeHdrCreateInfoAMD;
}
unsafe impl<'a> Send for SwapchainDisplayNativeHdrCreateInfoAMD<'a> {}
unsafe impl<'a> Sync for SwapchainDisplayNativeHdrCreateInfoAMD<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SwapchainCreateInfoKHR<'b>>
    for SwapchainDisplayNativeHdrCreateInfoAMD<'a>
{
}
impl<'a> Default for SwapchainDisplayNativeHdrCreateInfoAMD<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            local_dimming_enable: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SwapchainDisplayNativeHdrCreateInfoAMD<'a> {
    #[inline]
    pub fn local_dimming_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.local_dimming_enable = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImagePipeSurfaceCreateInfoFUCHSIA.html>"]
#[doc(alias = "VkImagePipeSurfaceCreateInfoFUCHSIA")]
pub struct ImagePipeSurfaceCreateInfoFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub image_pipe_handle: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImagePipeSurfaceCreateInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImagepipeSurfaceCreateInfoFUCHSIA;
}
unsafe impl<'a> Send for ImagePipeSurfaceCreateInfoFUCHSIA<'a> {}
unsafe impl<'a> Sync for ImagePipeSurfaceCreateInfoFUCHSIA<'a> {}
impl<'a> Default for ImagePipeSurfaceCreateInfoFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            image_pipe_handle: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImagePipeSurfaceCreateInfoFUCHSIA<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn image_pipe_handle(mut self, value: VoidPtr) -> Self {
        self.image_pipe_handle = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMetalSurfaceCreateInfoEXT.html>"]
#[doc(alias = "VkMetalSurfaceCreateInfoEXT")]
pub struct MetalSurfaceCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub p_layer: *const CAMetalLayer,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MetalSurfaceCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MetalSurfaceCreateInfoEXT;
}
unsafe impl<'a> Send for MetalSurfaceCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for MetalSurfaceCreateInfoEXT<'a> {}
impl<'a> Default for MetalSurfaceCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            p_layer: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MetalSurfaceCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn layer(mut self, value: &'a CAMetalLayer) -> Self {
        self.p_layer = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/CAMetalLayer.html>"]
pub type CAMetalLayer = c_void;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentDensityMapFeaturesEXT")]
pub struct PhysicalDeviceFragmentDensityMapFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fragment_density_map: Bool32,
    pub fragment_density_map_dynamic: Bool32,
    pub fragment_density_map_non_subsampled_images: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentDensityMapFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentDensityMapFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentDensityMapFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentDensityMapFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceFragmentDensityMapFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceFragmentDensityMapFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentDensityMapFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fragment_density_map: Default::default(),
            fragment_density_map_dynamic: Default::default(),
            fragment_density_map_non_subsampled_images: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentDensityMapFeaturesEXT<'a> {
    #[inline]
    pub fn fragment_density_map(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_density_map = value.into();
        self
    }
    #[inline]
    pub fn fragment_density_map_dynamic(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_density_map_dynamic = value.into();
        self
    }
    #[inline]
    pub fn fragment_density_map_non_subsampled_images(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_density_map_non_subsampled_images = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentDensityMapPropertiesEXT")]
pub struct PhysicalDeviceFragmentDensityMapPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub min_fragment_density_texel_size: Extent2D,
    pub max_fragment_density_texel_size: Extent2D,
    pub fragment_density_invocations: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentDensityMapPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentDensityMapPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentDensityMapPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentDensityMapPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceFragmentDensityMapPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentDensityMapPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            min_fragment_density_texel_size: Default::default(),
            max_fragment_density_texel_size: Default::default(),
            fragment_density_invocations: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentDensityMapPropertiesEXT<'a> {
    #[inline]
    pub fn min_fragment_density_texel_size(mut self, value: Extent2D) -> Self {
        self.min_fragment_density_texel_size = value;
        self
    }
    #[inline]
    pub fn max_fragment_density_texel_size(mut self, value: Extent2D) -> Self {
        self.max_fragment_density_texel_size = value;
        self
    }
    #[inline]
    pub fn fragment_density_invocations(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_density_invocations = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassFragmentDensityMapCreateInfoEXT.html>"]
#[doc(alias = "VkRenderPassFragmentDensityMapCreateInfoEXT")]
pub struct RenderPassFragmentDensityMapCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fragment_density_map_attachment: AttachmentReference,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassFragmentDensityMapCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassFragmentDensityMapCreateInfoEXT;
}
unsafe impl<'a> Send for RenderPassFragmentDensityMapCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for RenderPassFragmentDensityMapCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderPassCreateInfo<'b>>
    for RenderPassFragmentDensityMapCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<RenderPassCreateInfo2<'b>>
    for RenderPassFragmentDensityMapCreateInfoEXT<'a>
{
}
impl<'a> Default for RenderPassFragmentDensityMapCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fragment_density_map_attachment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassFragmentDensityMapCreateInfoEXT<'a> {
    #[inline]
    pub fn fragment_density_map_attachment(mut self, value: AttachmentReference) -> Self {
        self.fragment_density_map_attachment = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFragmentShadingRateAttachmentInfoKHR.html>"]
#[doc(alias = "VkFragmentShadingRateAttachmentInfoKHR")]
pub struct FragmentShadingRateAttachmentInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_fragment_shading_rate_attachment: *const AttachmentReference2<'a>,
    pub shading_rate_attachment_texel_size: Extent2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for FragmentShadingRateAttachmentInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FragmentShadingRateAttachmentInfoKHR;
}
unsafe impl<'a> Send for FragmentShadingRateAttachmentInfoKHR<'a> {}
unsafe impl<'a> Sync for FragmentShadingRateAttachmentInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubpassDescription2<'b>>
    for FragmentShadingRateAttachmentInfoKHR<'a>
{
}
impl<'a> Default for FragmentShadingRateAttachmentInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_fragment_shading_rate_attachment: ptr::null(),
            shading_rate_attachment_texel_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> FragmentShadingRateAttachmentInfoKHR<'a> {
    #[inline]
    pub fn fragment_shading_rate_attachment(
        mut self,
        value: Option<&'a AttachmentReference2<'a>>,
    ) -> Self {
        self.p_fragment_shading_rate_attachment =
            value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn shading_rate_attachment_texel_size(mut self, value: Extent2D) -> Self {
        self.shading_rate_attachment_texel_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineFragmentShadingRateStateCreateInfoKHR.html>"]
#[doc(alias = "VkPipelineFragmentShadingRateStateCreateInfoKHR")]
pub struct PipelineFragmentShadingRateStateCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fragment_size: Extent2D,
    pub combiner_ops: [FragmentShadingRateCombinerOpKHR; 2u16 as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineFragmentShadingRateStateCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineFragmentShadingRateStateCreateInfoKHR;
}
unsafe impl<'a> Send for PipelineFragmentShadingRateStateCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for PipelineFragmentShadingRateStateCreateInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for PipelineFragmentShadingRateStateCreateInfoKHR<'a>
{
}
impl<'a> Default for PipelineFragmentShadingRateStateCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fragment_size: Default::default(),
            combiner_ops: array::from_fn(|_| FragmentShadingRateCombinerOpKHR::Keep),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineFragmentShadingRateStateCreateInfoKHR<'a> {
    #[inline]
    pub fn fragment_size(mut self, value: Extent2D) -> Self {
        self.fragment_size = value;
        self
    }
    #[inline]
    pub fn combiner_ops(mut self, value: [FragmentShadingRateCombinerOpKHR; 2u16 as _]) -> Self {
        self.combiner_ops = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentShadingRateFeaturesKHR")]
pub struct PhysicalDeviceFragmentShadingRateFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline_fragment_shading_rate: Bool32,
    pub primitive_fragment_shading_rate: Bool32,
    pub attachment_fragment_shading_rate: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentShadingRateFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentShadingRateFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentShadingRateFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentShadingRateFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceFragmentShadingRateFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceFragmentShadingRateFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentShadingRateFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline_fragment_shading_rate: Default::default(),
            primitive_fragment_shading_rate: Default::default(),
            attachment_fragment_shading_rate: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentShadingRateFeaturesKHR<'a> {
    #[inline]
    pub fn pipeline_fragment_shading_rate(mut self, value: impl Into<Bool32>) -> Self {
        self.pipeline_fragment_shading_rate = value.into();
        self
    }
    #[inline]
    pub fn primitive_fragment_shading_rate(mut self, value: impl Into<Bool32>) -> Self {
        self.primitive_fragment_shading_rate = value.into();
        self
    }
    #[inline]
    pub fn attachment_fragment_shading_rate(mut self, value: impl Into<Bool32>) -> Self {
        self.attachment_fragment_shading_rate = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRatePropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentShadingRatePropertiesKHR")]
pub struct PhysicalDeviceFragmentShadingRatePropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub min_fragment_shading_rate_attachment_texel_size: Extent2D,
    pub max_fragment_shading_rate_attachment_texel_size: Extent2D,
    pub max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32,
    pub primitive_fragment_shading_rate_with_multiple_viewports: Bool32,
    pub layered_shading_rate_attachments: Bool32,
    pub fragment_shading_rate_non_trivial_combiner_ops: Bool32,
    pub max_fragment_size: Extent2D,
    pub max_fragment_size_aspect_ratio: u32,
    pub max_fragment_shading_rate_coverage_samples: u32,
    pub max_fragment_shading_rate_rasterization_samples: SampleCountFlags,
    pub fragment_shading_rate_with_shader_depth_stencil_writes: Bool32,
    pub fragment_shading_rate_with_sample_mask: Bool32,
    pub fragment_shading_rate_with_shader_sample_mask: Bool32,
    pub fragment_shading_rate_with_conservative_rasterization: Bool32,
    pub fragment_shading_rate_with_fragment_shader_interlock: Bool32,
    pub fragment_shading_rate_with_custom_sample_locations: Bool32,
    pub fragment_shading_rate_strict_multiply_combiner: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentShadingRatePropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentShadingRatePropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentShadingRatePropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentShadingRatePropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceFragmentShadingRatePropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentShadingRatePropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            min_fragment_shading_rate_attachment_texel_size: Default::default(),
            max_fragment_shading_rate_attachment_texel_size: Default::default(),
            max_fragment_shading_rate_attachment_texel_size_aspect_ratio: Default::default(),
            primitive_fragment_shading_rate_with_multiple_viewports: Default::default(),
            layered_shading_rate_attachments: Default::default(),
            fragment_shading_rate_non_trivial_combiner_ops: Default::default(),
            max_fragment_size: Default::default(),
            max_fragment_size_aspect_ratio: Default::default(),
            max_fragment_shading_rate_coverage_samples: Default::default(),
            max_fragment_shading_rate_rasterization_samples: Default::default(),
            fragment_shading_rate_with_shader_depth_stencil_writes: Default::default(),
            fragment_shading_rate_with_sample_mask: Default::default(),
            fragment_shading_rate_with_shader_sample_mask: Default::default(),
            fragment_shading_rate_with_conservative_rasterization: Default::default(),
            fragment_shading_rate_with_fragment_shader_interlock: Default::default(),
            fragment_shading_rate_with_custom_sample_locations: Default::default(),
            fragment_shading_rate_strict_multiply_combiner: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentShadingRatePropertiesKHR<'a> {
    #[inline]
    pub fn min_fragment_shading_rate_attachment_texel_size(mut self, value: Extent2D) -> Self {
        self.min_fragment_shading_rate_attachment_texel_size = value;
        self
    }
    #[inline]
    pub fn max_fragment_shading_rate_attachment_texel_size(mut self, value: Extent2D) -> Self {
        self.max_fragment_shading_rate_attachment_texel_size = value;
        self
    }
    #[inline]
    pub fn max_fragment_shading_rate_attachment_texel_size_aspect_ratio(
        mut self,
        value: u32,
    ) -> Self {
        self.max_fragment_shading_rate_attachment_texel_size_aspect_ratio = value;
        self
    }
    #[inline]
    pub fn primitive_fragment_shading_rate_with_multiple_viewports(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.primitive_fragment_shading_rate_with_multiple_viewports = value.into();
        self
    }
    #[inline]
    pub fn layered_shading_rate_attachments(mut self, value: impl Into<Bool32>) -> Self {
        self.layered_shading_rate_attachments = value.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_non_trivial_combiner_ops(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.fragment_shading_rate_non_trivial_combiner_ops = value.into();
        self
    }
    #[inline]
    pub fn max_fragment_size(mut self, value: Extent2D) -> Self {
        self.max_fragment_size = value;
        self
    }
    #[inline]
    pub fn max_fragment_size_aspect_ratio(mut self, value: u32) -> Self {
        self.max_fragment_size_aspect_ratio = value;
        self
    }
    #[inline]
    pub fn max_fragment_shading_rate_coverage_samples(mut self, value: u32) -> Self {
        self.max_fragment_shading_rate_coverage_samples = value;
        self
    }
    #[inline]
    pub fn max_fragment_shading_rate_rasterization_samples(
        mut self,
        value: SampleCountFlags,
    ) -> Self {
        self.max_fragment_shading_rate_rasterization_samples = value;
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_shader_depth_stencil_writes(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.fragment_shading_rate_with_shader_depth_stencil_writes = value.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_sample_mask(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_shading_rate_with_sample_mask = value.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_shader_sample_mask(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.fragment_shading_rate_with_shader_sample_mask = value.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_conservative_rasterization(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.fragment_shading_rate_with_conservative_rasterization = value.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_fragment_shader_interlock(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.fragment_shading_rate_with_fragment_shader_interlock = value.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_custom_sample_locations(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.fragment_shading_rate_with_custom_sample_locations = value.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_strict_multiply_combiner(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.fragment_shading_rate_strict_multiply_combiner = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateKHR.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentShadingRateKHR")]
pub struct PhysicalDeviceFragmentShadingRateKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub sample_counts: SampleCountFlags,
    pub fragment_size: Extent2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentShadingRateKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceFragmentShadingRateKHR;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentShadingRateKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentShadingRateKHR<'a> {}
impl<'a> Default for PhysicalDeviceFragmentShadingRateKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            sample_counts: Default::default(),
            fragment_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentShadingRateKHR<'a> {
    #[inline]
    pub fn sample_counts(mut self, value: SampleCountFlags) -> Self {
        self.sample_counts = value;
        self
    }
    #[inline]
    pub fn fragment_size(mut self, value: Extent2D) -> Self {
        self.fragment_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCoreProperties2AMD.html>"]
#[doc(alias = "VkPhysicalDeviceShaderCoreProperties2AMD")]
pub struct PhysicalDeviceShaderCoreProperties2AMD<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_core_features: ShaderCorePropertiesFlagsAMD,
    pub active_compute_unit_count: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderCoreProperties2AMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderCoreProperties2AMD;
}
unsafe impl<'a> Send for PhysicalDeviceShaderCoreProperties2AMD<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderCoreProperties2AMD<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceShaderCoreProperties2AMD<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderCoreProperties2AMD<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_core_features: Default::default(),
            active_compute_unit_count: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderCoreProperties2AMD<'a> {
    #[inline]
    pub fn shader_core_features(mut self, value: ShaderCorePropertiesFlagsAMD) -> Self {
        self.shader_core_features = value;
        self
    }
    #[inline]
    pub fn active_compute_unit_count(mut self, value: u32) -> Self {
        self.active_compute_unit_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCoherentMemoryFeaturesAMD.html>"]
#[doc(alias = "VkPhysicalDeviceCoherentMemoryFeaturesAMD")]
pub struct PhysicalDeviceCoherentMemoryFeaturesAMD<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_coherent_memory: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCoherentMemoryFeaturesAMD<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceCoherentMemoryFeaturesAMD;
}
unsafe impl<'a> Send for PhysicalDeviceCoherentMemoryFeaturesAMD<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCoherentMemoryFeaturesAMD<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceCoherentMemoryFeaturesAMD<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceCoherentMemoryFeaturesAMD<'a>
{
}
impl<'a> Default for PhysicalDeviceCoherentMemoryFeaturesAMD<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_coherent_memory: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCoherentMemoryFeaturesAMD<'a> {
    #[inline]
    pub fn device_coherent_memory(mut self, value: impl Into<Bool32>) -> Self {
        self.device_coherent_memory = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR")]
pub struct PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub dynamic_rendering_local_read: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            dynamic_rendering_local_read: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR<'a> {
    #[inline]
    pub fn dynamic_rendering_local_read(mut self, value: impl Into<Bool32>) -> Self {
        self.dynamic_rendering_local_read = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingAttachmentLocationInfoKHR.html>"]
#[doc(alias = "VkRenderingAttachmentLocationInfoKHR")]
pub struct RenderingAttachmentLocationInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) color_attachment_count: u32,
    pub(crate) p_color_attachment_locations: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderingAttachmentLocationInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderingAttachmentLocationInfoKHR;
}
unsafe impl<'a> Send for RenderingAttachmentLocationInfoKHR<'a> {}
unsafe impl<'a> Sync for RenderingAttachmentLocationInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for RenderingAttachmentLocationInfoKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<CommandBufferInheritanceInfo<'b>>
    for RenderingAttachmentLocationInfoKHR<'a>
{
}
impl<'a> Default for RenderingAttachmentLocationInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            color_attachment_count: Default::default(),
            p_color_attachment_locations: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderingAttachmentLocationInfoKHR<'a> {
    #[inline]
    pub fn color_attachment_locations(
        mut self,
        p_color_attachment_locations: impl AsSlice<'a, u32>,
    ) -> Self {
        self.p_color_attachment_locations = p_color_attachment_locations.as_slice().as_ptr().cast();
        self.color_attachment_count = p_color_attachment_locations.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingInputAttachmentIndexInfoKHR.html>"]
#[doc(alias = "VkRenderingInputAttachmentIndexInfoKHR")]
pub struct RenderingInputAttachmentIndexInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub color_attachment_count: u32,
    pub(crate) p_color_attachment_input_indices: *const u32,
    pub p_depth_input_attachment_index: *const u32,
    pub p_stencil_input_attachment_index: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderingInputAttachmentIndexInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderingInputAttachmentIndexInfoKHR;
}
unsafe impl<'a> Send for RenderingInputAttachmentIndexInfoKHR<'a> {}
unsafe impl<'a> Sync for RenderingInputAttachmentIndexInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for RenderingInputAttachmentIndexInfoKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<CommandBufferInheritanceInfo<'b>>
    for RenderingInputAttachmentIndexInfoKHR<'a>
{
}
impl<'a> Default for RenderingInputAttachmentIndexInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            color_attachment_count: Default::default(),
            p_color_attachment_input_indices: ptr::null(),
            p_depth_input_attachment_index: ptr::null(),
            p_stencil_input_attachment_index: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderingInputAttachmentIndexInfoKHR<'a> {
    #[inline]
    pub fn color_attachment_count(mut self, value: u32) -> Self {
        self.color_attachment_count = value;
        self
    }
    #[inline]
    pub fn depth_input_attachment_index(mut self, value: Option<&'a u32>) -> Self {
        self.p_depth_input_attachment_index =
            value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn stencil_input_attachment_index(mut self, value: Option<&'a u32>) -> Self {
        self.p_stencil_input_attachment_index =
            value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn color_attachment_input_indices(
        mut self,
        p_color_attachment_input_indices: impl AsSlice<'a, u32>,
    ) -> Self {
        self.p_color_attachment_input_indices =
            p_color_attachment_input_indices.as_slice().as_ptr().cast();
        self.color_attachment_count = p_color_attachment_input_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT")]
pub struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_image_int64_atomics: Bool32,
    pub sparse_image_int64_atomics: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_image_int64_atomics: Default::default(),
            sparse_image_int64_atomics: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'a> {
    #[inline]
    pub fn shader_image_int64_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_image_int64_atomics = value.into();
        self
    }
    #[inline]
    pub fn sparse_image_int64_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_image_int64_atomics = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderQuadControlFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceShaderQuadControlFeaturesKHR")]
pub struct PhysicalDeviceShaderQuadControlFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_quad_control: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderQuadControlFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderQuadControlFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceShaderQuadControlFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderQuadControlFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderQuadControlFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderQuadControlFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderQuadControlFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_quad_control: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderQuadControlFeaturesKHR<'a> {
    #[inline]
    pub fn shader_quad_control(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_quad_control = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryBudgetPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceMemoryBudgetPropertiesEXT")]
pub struct PhysicalDeviceMemoryBudgetPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub heap_budget: [DeviceSize; MAX_MEMORY_HEAPS as _],
    pub heap_usage: [DeviceSize; MAX_MEMORY_HEAPS as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMemoryBudgetPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMemoryBudgetPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceMemoryBudgetPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMemoryBudgetPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceMemoryProperties2<'b>>
    for PhysicalDeviceMemoryBudgetPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceMemoryBudgetPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            heap_budget: array::from_fn(|_| Default::default()),
            heap_usage: array::from_fn(|_| Default::default()),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMemoryBudgetPropertiesEXT<'a> {
    #[inline]
    pub fn heap_budget(mut self, value: [DeviceSize; MAX_MEMORY_HEAPS as _]) -> Self {
        self.heap_budget = value;
        self
    }
    #[inline]
    pub fn heap_usage(mut self, value: [DeviceSize; MAX_MEMORY_HEAPS as _]) -> Self {
        self.heap_usage = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryPriorityFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceMemoryPriorityFeaturesEXT")]
pub struct PhysicalDeviceMemoryPriorityFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory_priority: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMemoryPriorityFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMemoryPriorityFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceMemoryPriorityFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMemoryPriorityFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMemoryPriorityFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMemoryPriorityFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceMemoryPriorityFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory_priority: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMemoryPriorityFeaturesEXT<'a> {
    #[inline]
    pub fn memory_priority(mut self, value: impl Into<Bool32>) -> Self {
        self.memory_priority = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryPriorityAllocateInfoEXT.html>"]
#[doc(alias = "VkMemoryPriorityAllocateInfoEXT")]
pub struct MemoryPriorityAllocateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub priority: f32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryPriorityAllocateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryPriorityAllocateInfoEXT;
}
unsafe impl<'a> Send for MemoryPriorityAllocateInfoEXT<'a> {}
unsafe impl<'a> Sync for MemoryPriorityAllocateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>>
    for MemoryPriorityAllocateInfoEXT<'a>
{
}
impl<'a> Default for MemoryPriorityAllocateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            priority: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryPriorityAllocateInfoEXT<'a> {
    #[inline]
    pub fn priority(mut self, value: f32) -> Self {
        self.priority = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceProtectedCapabilitiesKHR.html>"]
#[doc(alias = "VkSurfaceProtectedCapabilitiesKHR")]
pub struct SurfaceProtectedCapabilitiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub supports_protected: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SurfaceProtectedCapabilitiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SurfaceProtectedCapabilitiesKHR;
}
unsafe impl<'a> Send for SurfaceProtectedCapabilitiesKHR<'a> {}
unsafe impl<'a> Sync for SurfaceProtectedCapabilitiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SurfaceCapabilities2KHR<'b>>
    for SurfaceProtectedCapabilitiesKHR<'a>
{
}
impl<'a> Default for SurfaceProtectedCapabilitiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            supports_protected: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SurfaceProtectedCapabilitiesKHR<'a> {
    #[inline]
    pub fn supports_protected(mut self, value: impl Into<Bool32>) -> Self {
        self.supports_protected = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV")]
pub struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub dedicated_allocation_image_aliasing: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure
    for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'a>
{
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            dedicated_allocation_image_aliasing: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'a> {
    #[inline]
    pub fn dedicated_allocation_image_aliasing(mut self, value: impl Into<Bool32>) -> Self {
        self.dedicated_allocation_image_aliasing = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT")]
pub struct PhysicalDeviceBufferDeviceAddressFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceBufferDeviceAddressFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceBufferDeviceAddressFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceBufferDeviceAddressFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceBufferDeviceAddressFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceBufferDeviceAddressFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceBufferDeviceAddressFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceBufferDeviceAddressFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            buffer_device_address: Default::default(),
            buffer_device_address_capture_replay: Default::default(),
            buffer_device_address_multi_device: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceBufferDeviceAddressFeaturesEXT<'a> {
    #[inline]
    pub fn buffer_device_address(mut self, value: impl Into<Bool32>) -> Self {
        self.buffer_device_address = value.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_capture_replay(mut self, value: impl Into<Bool32>) -> Self {
        self.buffer_device_address_capture_replay = value.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_multi_device(mut self, value: impl Into<Bool32>) -> Self {
        self.buffer_device_address_multi_device = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceBufferAddressFeaturesEXT<'a> =
    PhysicalDeviceBufferDeviceAddressFeaturesEXT<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferDeviceAddressCreateInfoEXT.html>"]
#[doc(alias = "VkBufferDeviceAddressCreateInfoEXT")]
pub struct BufferDeviceAddressCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_address: DeviceAddress,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferDeviceAddressCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferDeviceAddressCreateInfoEXT;
}
unsafe impl<'a> Send for BufferDeviceAddressCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for BufferDeviceAddressCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BufferCreateInfo<'b>>
    for BufferDeviceAddressCreateInfoEXT<'a>
{
}
impl<'a> Default for BufferDeviceAddressCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_address: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferDeviceAddressCreateInfoEXT<'a> {
    #[inline]
    pub fn device_address(mut self, value: DeviceAddress) -> Self {
        self.device_address = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationFeaturesEXT.html>"]
#[doc(alias = "VkValidationFeaturesEXT")]
pub struct ValidationFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) enabled_validation_feature_count: u32,
    pub(crate) p_enabled_validation_features: *const ValidationFeatureEnableEXT,
    pub(crate) disabled_validation_feature_count: u32,
    pub(crate) p_disabled_validation_features: *const ValidationFeatureDisableEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ValidationFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ValidationFeaturesEXT;
}
unsafe impl<'a> Send for ValidationFeaturesEXT<'a> {}
unsafe impl<'a> Sync for ValidationFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<InstanceCreateInfo<'b>> for ValidationFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ShaderModuleCreateInfo<'b>> for ValidationFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ShaderCreateInfoEXT<'b>> for ValidationFeaturesEXT<'a> {}
impl<'a> Default for ValidationFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            enabled_validation_feature_count: Default::default(),
            p_enabled_validation_features: ptr::null(),
            disabled_validation_feature_count: Default::default(),
            p_disabled_validation_features: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ValidationFeaturesEXT<'a> {
    #[inline]
    pub fn enabled_validation_features(
        mut self,
        p_enabled_validation_features: impl AsSlice<'a, ValidationFeatureEnableEXT>,
    ) -> Self {
        self.p_enabled_validation_features =
            p_enabled_validation_features.as_slice().as_ptr().cast();
        self.enabled_validation_feature_count = p_enabled_validation_features.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn disabled_validation_features(
        mut self,
        p_disabled_validation_features: impl AsSlice<'a, ValidationFeatureDisableEXT>,
    ) -> Self {
        self.p_disabled_validation_features =
            p_disabled_validation_features.as_slice().as_ptr().cast();
        self.disabled_validation_feature_count =
            p_disabled_validation_features.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentWaitFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDevicePresentWaitFeaturesKHR")]
pub struct PhysicalDevicePresentWaitFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub present_wait: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePresentWaitFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDevicePresentWaitFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDevicePresentWaitFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePresentWaitFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePresentWaitFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePresentWaitFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDevicePresentWaitFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_wait: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePresentWaitFeaturesKHR<'a> {
    #[inline]
    pub fn present_wait(mut self, value: impl Into<Bool32>) -> Self {
        self.present_wait = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCooperativeMatrixPropertiesNV.html>"]
#[doc(alias = "VkCooperativeMatrixPropertiesNV")]
pub struct CooperativeMatrixPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub msize: u32,
    pub nsize: u32,
    pub ksize: u32,
    pub atype: ComponentTypeNV,
    pub btype: ComponentTypeNV,
    pub ctype: ComponentTypeNV,
    pub dtype: ComponentTypeNV,
    pub scope: ScopeNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CooperativeMatrixPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CooperativeMatrixPropertiesNV;
}
unsafe impl<'a> Send for CooperativeMatrixPropertiesNV<'a> {}
unsafe impl<'a> Sync for CooperativeMatrixPropertiesNV<'a> {}
impl<'a> Default for CooperativeMatrixPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            msize: Default::default(),
            nsize: Default::default(),
            ksize: Default::default(),
            atype: ComponentTypeKHR::Float16,
            btype: ComponentTypeKHR::Float16,
            ctype: ComponentTypeKHR::Float16,
            dtype: ComponentTypeKHR::Float16,
            scope: ScopeKHR::Device,
            phantom: PhantomData,
        }
    }
}
impl<'a> CooperativeMatrixPropertiesNV<'a> {
    #[inline]
    pub fn msize(mut self, value: u32) -> Self {
        self.msize = value;
        self
    }
    #[inline]
    pub fn nsize(mut self, value: u32) -> Self {
        self.nsize = value;
        self
    }
    #[inline]
    pub fn ksize(mut self, value: u32) -> Self {
        self.ksize = value;
        self
    }
    #[inline]
    pub fn atype(mut self, value: ComponentTypeNV) -> Self {
        self.atype = value;
        self
    }
    #[inline]
    pub fn btype(mut self, value: ComponentTypeNV) -> Self {
        self.btype = value;
        self
    }
    #[inline]
    pub fn ctype(mut self, value: ComponentTypeNV) -> Self {
        self.ctype = value;
        self
    }
    #[inline]
    pub fn dtype(mut self, value: ComponentTypeNV) -> Self {
        self.dtype = value;
        self
    }
    #[inline]
    pub fn scope(mut self, value: ScopeNV) -> Self {
        self.scope = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCooperativeMatrixFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceCooperativeMatrixFeaturesNV")]
pub struct PhysicalDeviceCooperativeMatrixFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub cooperative_matrix: Bool32,
    pub cooperative_matrix_robust_buffer_access: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCooperativeMatrixFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceCooperativeMatrixFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceCooperativeMatrixFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCooperativeMatrixFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceCooperativeMatrixFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceCooperativeMatrixFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceCooperativeMatrixFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            cooperative_matrix: Default::default(),
            cooperative_matrix_robust_buffer_access: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCooperativeMatrixFeaturesNV<'a> {
    #[inline]
    pub fn cooperative_matrix(mut self, value: impl Into<Bool32>) -> Self {
        self.cooperative_matrix = value.into();
        self
    }
    #[inline]
    pub fn cooperative_matrix_robust_buffer_access(mut self, value: impl Into<Bool32>) -> Self {
        self.cooperative_matrix_robust_buffer_access = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCooperativeMatrixPropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceCooperativeMatrixPropertiesNV")]
pub struct PhysicalDeviceCooperativeMatrixPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub cooperative_matrix_supported_stages: ShaderStageFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCooperativeMatrixPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceCooperativeMatrixPropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceCooperativeMatrixPropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCooperativeMatrixPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceCooperativeMatrixPropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceCooperativeMatrixPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            cooperative_matrix_supported_stages: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCooperativeMatrixPropertiesNV<'a> {
    #[inline]
    pub fn cooperative_matrix_supported_stages(mut self, value: ShaderStageFlags) -> Self {
        self.cooperative_matrix_supported_stages = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCoverageReductionModeFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceCoverageReductionModeFeaturesNV")]
pub struct PhysicalDeviceCoverageReductionModeFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub coverage_reduction_mode: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCoverageReductionModeFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceCoverageReductionModeFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceCoverageReductionModeFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCoverageReductionModeFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceCoverageReductionModeFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceCoverageReductionModeFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceCoverageReductionModeFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            coverage_reduction_mode: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCoverageReductionModeFeaturesNV<'a> {
    #[inline]
    pub fn coverage_reduction_mode(mut self, value: impl Into<Bool32>) -> Self {
        self.coverage_reduction_mode = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageReductionStateCreateInfoNV.html>"]
#[doc(alias = "VkPipelineCoverageReductionStateCreateInfoNV")]
pub struct PipelineCoverageReductionStateCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub coverage_reduction_mode: CoverageReductionModeNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineCoverageReductionStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineCoverageReductionStateCreateInfoNV;
}
unsafe impl<'a> Send for PipelineCoverageReductionStateCreateInfoNV<'a> {}
unsafe impl<'a> Sync for PipelineCoverageReductionStateCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineMultisampleStateCreateInfo<'b>>
    for PipelineCoverageReductionStateCreateInfoNV<'a>
{
}
impl<'a> Default for PipelineCoverageReductionStateCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            coverage_reduction_mode: CoverageReductionModeNV::Merge,
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineCoverageReductionStateCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn coverage_reduction_mode(mut self, value: CoverageReductionModeNV) -> Self {
        self.coverage_reduction_mode = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferMixedSamplesCombinationNV.html>"]
#[doc(alias = "VkFramebufferMixedSamplesCombinationNV")]
pub struct FramebufferMixedSamplesCombinationNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub coverage_reduction_mode: CoverageReductionModeNV,
    pub rasterization_samples: SampleCountFlags,
    pub depth_stencil_samples: SampleCountFlags,
    pub color_samples: SampleCountFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for FramebufferMixedSamplesCombinationNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FramebufferMixedSamplesCombinationNV;
}
unsafe impl<'a> Send for FramebufferMixedSamplesCombinationNV<'a> {}
unsafe impl<'a> Sync for FramebufferMixedSamplesCombinationNV<'a> {}
impl<'a> Default for FramebufferMixedSamplesCombinationNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            coverage_reduction_mode: CoverageReductionModeNV::Merge,
            rasterization_samples: Default::default(),
            depth_stencil_samples: Default::default(),
            color_samples: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> FramebufferMixedSamplesCombinationNV<'a> {
    #[inline]
    pub fn coverage_reduction_mode(mut self, value: CoverageReductionModeNV) -> Self {
        self.coverage_reduction_mode = value;
        self
    }
    #[inline]
    pub fn rasterization_samples(mut self, value: SampleCountFlags) -> Self {
        self.rasterization_samples = value;
        self
    }
    #[inline]
    pub fn depth_stencil_samples(mut self, value: SampleCountFlags) -> Self {
        self.depth_stencil_samples = value;
        self
    }
    #[inline]
    pub fn color_samples(mut self, value: SampleCountFlags) -> Self {
        self.color_samples = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT")]
pub struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fragment_shader_sample_interlock: Bool32,
    pub fragment_shader_pixel_interlock: Bool32,
    pub fragment_shader_shading_rate_interlock: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentShaderInterlockFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fragment_shader_sample_interlock: Default::default(),
            fragment_shader_pixel_interlock: Default::default(),
            fragment_shader_shading_rate_interlock: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'a> {
    #[inline]
    pub fn fragment_shader_sample_interlock(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_shader_sample_interlock = value.into();
        self
    }
    #[inline]
    pub fn fragment_shader_pixel_interlock(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_shader_pixel_interlock = value.into();
        self
    }
    #[inline]
    pub fn fragment_shader_shading_rate_interlock(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_shader_shading_rate_interlock = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT")]
pub struct PhysicalDeviceYcbcrImageArraysFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ycbcr_image_arrays: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceYcbcrImageArraysFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceYcbcrImageArraysFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceYcbcrImageArraysFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceYcbcrImageArraysFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceYcbcrImageArraysFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceYcbcrImageArraysFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceYcbcrImageArraysFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ycbcr_image_arrays: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceYcbcrImageArraysFeaturesEXT<'a> {
    #[inline]
    pub fn ycbcr_image_arrays(mut self, value: impl Into<Bool32>) -> Self {
        self.ycbcr_image_arrays = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProvokingVertexFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceProvokingVertexFeaturesEXT")]
pub struct PhysicalDeviceProvokingVertexFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub provoking_vertex_last: Bool32,
    pub transform_feedback_preserves_provoking_vertex: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceProvokingVertexFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceProvokingVertexFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceProvokingVertexFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceProvokingVertexFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceProvokingVertexFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceProvokingVertexFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceProvokingVertexFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            provoking_vertex_last: Default::default(),
            transform_feedback_preserves_provoking_vertex: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceProvokingVertexFeaturesEXT<'a> {
    #[inline]
    pub fn provoking_vertex_last(mut self, value: impl Into<Bool32>) -> Self {
        self.provoking_vertex_last = value.into();
        self
    }
    #[inline]
    pub fn transform_feedback_preserves_provoking_vertex(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.transform_feedback_preserves_provoking_vertex = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProvokingVertexPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceProvokingVertexPropertiesEXT")]
pub struct PhysicalDeviceProvokingVertexPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub provoking_vertex_mode_per_pipeline: Bool32,
    pub transform_feedback_preserves_triangle_fan_provoking_vertex: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceProvokingVertexPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceProvokingVertexPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceProvokingVertexPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceProvokingVertexPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceProvokingVertexPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceProvokingVertexPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            provoking_vertex_mode_per_pipeline: Default::default(),
            transform_feedback_preserves_triangle_fan_provoking_vertex: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceProvokingVertexPropertiesEXT<'a> {
    #[inline]
    pub fn provoking_vertex_mode_per_pipeline(mut self, value: impl Into<Bool32>) -> Self {
        self.provoking_vertex_mode_per_pipeline = value.into();
        self
    }
    #[inline]
    pub fn transform_feedback_preserves_triangle_fan_provoking_vertex(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.transform_feedback_preserves_triangle_fan_provoking_vertex = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationProvokingVertexStateCreateInfoEXT.html>"]
#[doc(alias = "VkPipelineRasterizationProvokingVertexStateCreateInfoEXT")]
pub struct PipelineRasterizationProvokingVertexStateCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub provoking_vertex_mode: ProvokingVertexModeEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineRasterizationProvokingVertexStateCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineRasterizationProvokingVertexStateCreateInfoEXT;
}
unsafe impl<'a> Send for PipelineRasterizationProvokingVertexStateCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for PipelineRasterizationProvokingVertexStateCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineRasterizationStateCreateInfo<'b>>
    for PipelineRasterizationProvokingVertexStateCreateInfoEXT<'a>
{
}
impl<'a> Default for PipelineRasterizationProvokingVertexStateCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            provoking_vertex_mode: ProvokingVertexModeEXT::FirstVertex,
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineRasterizationProvokingVertexStateCreateInfoEXT<'a> {
    #[inline]
    pub fn provoking_vertex_mode(mut self, value: ProvokingVertexModeEXT) -> Self {
        self.provoking_vertex_mode = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFullScreenExclusiveInfoEXT.html>"]
#[doc(alias = "VkSurfaceFullScreenExclusiveInfoEXT")]
pub struct SurfaceFullScreenExclusiveInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub full_screen_exclusive: FullScreenExclusiveEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SurfaceFullScreenExclusiveInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SurfaceFullScreenExclusiveInfoEXT;
}
unsafe impl<'a> Send for SurfaceFullScreenExclusiveInfoEXT<'a> {}
unsafe impl<'a> Sync for SurfaceFullScreenExclusiveInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceSurfaceInfo2KHR<'b>>
    for SurfaceFullScreenExclusiveInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<SwapchainCreateInfoKHR<'b>>
    for SurfaceFullScreenExclusiveInfoEXT<'a>
{
}
impl<'a> Default for SurfaceFullScreenExclusiveInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            full_screen_exclusive: FullScreenExclusiveEXT::Default,
            phantom: PhantomData,
        }
    }
}
impl<'a> SurfaceFullScreenExclusiveInfoEXT<'a> {
    #[inline]
    pub fn full_screen_exclusive(mut self, value: FullScreenExclusiveEXT) -> Self {
        self.full_screen_exclusive = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesFullScreenExclusiveEXT.html>"]
#[doc(alias = "VkSurfaceCapabilitiesFullScreenExclusiveEXT")]
pub struct SurfaceCapabilitiesFullScreenExclusiveEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub full_screen_exclusive_supported: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SurfaceCapabilitiesFullScreenExclusiveEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SurfaceCapabilitiesFullScreenExclusiveEXT;
}
unsafe impl<'a> Send for SurfaceCapabilitiesFullScreenExclusiveEXT<'a> {}
unsafe impl<'a> Sync for SurfaceCapabilitiesFullScreenExclusiveEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SurfaceCapabilities2KHR<'b>>
    for SurfaceCapabilitiesFullScreenExclusiveEXT<'a>
{
}
impl<'a> Default for SurfaceCapabilitiesFullScreenExclusiveEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            full_screen_exclusive_supported: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SurfaceCapabilitiesFullScreenExclusiveEXT<'a> {
    #[inline]
    pub fn full_screen_exclusive_supported(mut self, value: impl Into<Bool32>) -> Self {
        self.full_screen_exclusive_supported = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFullScreenExclusiveWin32InfoEXT.html>"]
#[doc(alias = "VkSurfaceFullScreenExclusiveWin32InfoEXT")]
pub struct SurfaceFullScreenExclusiveWin32InfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub hmonitor: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SurfaceFullScreenExclusiveWin32InfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SurfaceFullScreenExclusiveWin32InfoEXT;
}
unsafe impl<'a> Send for SurfaceFullScreenExclusiveWin32InfoEXT<'a> {}
unsafe impl<'a> Sync for SurfaceFullScreenExclusiveWin32InfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceSurfaceInfo2KHR<'b>>
    for SurfaceFullScreenExclusiveWin32InfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<SwapchainCreateInfoKHR<'b>>
    for SurfaceFullScreenExclusiveWin32InfoEXT<'a>
{
}
impl<'a> Default for SurfaceFullScreenExclusiveWin32InfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            hmonitor: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SurfaceFullScreenExclusiveWin32InfoEXT<'a> {
    #[inline]
    pub fn hmonitor(mut self, value: VoidPtr) -> Self {
        self.hmonitor = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkHeadlessSurfaceCreateInfoEXT.html>"]
#[doc(alias = "VkHeadlessSurfaceCreateInfoEXT")]
pub struct HeadlessSurfaceCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for HeadlessSurfaceCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::HeadlessSurfaceCreateInfoEXT;
}
unsafe impl<'a> Send for HeadlessSurfaceCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for HeadlessSurfaceCreateInfoEXT<'a> {}
impl<'a> Default for HeadlessSurfaceCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> HeadlessSurfaceCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT")]
pub struct PhysicalDeviceShaderAtomicFloatFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_buffer_float32_atomics: Bool32,
    pub shader_buffer_float32_atomic_add: Bool32,
    pub shader_buffer_float64_atomics: Bool32,
    pub shader_buffer_float64_atomic_add: Bool32,
    pub shader_shared_float32_atomics: Bool32,
    pub shader_shared_float32_atomic_add: Bool32,
    pub shader_shared_float64_atomics: Bool32,
    pub shader_shared_float64_atomic_add: Bool32,
    pub shader_image_float32_atomics: Bool32,
    pub shader_image_float32_atomic_add: Bool32,
    pub sparse_image_float32_atomics: Bool32,
    pub sparse_image_float32_atomic_add: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderAtomicFloatFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderAtomicFloatFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceShaderAtomicFloatFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderAtomicFloatFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderAtomicFloatFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderAtomicFloatFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderAtomicFloatFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_buffer_float32_atomics: Default::default(),
            shader_buffer_float32_atomic_add: Default::default(),
            shader_buffer_float64_atomics: Default::default(),
            shader_buffer_float64_atomic_add: Default::default(),
            shader_shared_float32_atomics: Default::default(),
            shader_shared_float32_atomic_add: Default::default(),
            shader_shared_float64_atomics: Default::default(),
            shader_shared_float64_atomic_add: Default::default(),
            shader_image_float32_atomics: Default::default(),
            shader_image_float32_atomic_add: Default::default(),
            sparse_image_float32_atomics: Default::default(),
            sparse_image_float32_atomic_add: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderAtomicFloatFeaturesEXT<'a> {
    #[inline]
    pub fn shader_buffer_float32_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_buffer_float32_atomics = value.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float32_atomic_add(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_buffer_float32_atomic_add = value.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float64_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_buffer_float64_atomics = value.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float64_atomic_add(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_buffer_float64_atomic_add = value.into();
        self
    }
    #[inline]
    pub fn shader_shared_float32_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_shared_float32_atomics = value.into();
        self
    }
    #[inline]
    pub fn shader_shared_float32_atomic_add(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_shared_float32_atomic_add = value.into();
        self
    }
    #[inline]
    pub fn shader_shared_float64_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_shared_float64_atomics = value.into();
        self
    }
    #[inline]
    pub fn shader_shared_float64_atomic_add(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_shared_float64_atomic_add = value.into();
        self
    }
    #[inline]
    pub fn shader_image_float32_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_image_float32_atomics = value.into();
        self
    }
    #[inline]
    pub fn shader_image_float32_atomic_add(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_image_float32_atomic_add = value.into();
        self
    }
    #[inline]
    pub fn sparse_image_float32_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_image_float32_atomics = value.into();
        self
    }
    #[inline]
    pub fn sparse_image_float32_atomic_add(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_image_float32_atomic_add = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT")]
pub struct PhysicalDeviceExtendedDynamicStateFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub extended_dynamic_state: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExtendedDynamicStateFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceExtendedDynamicStateFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceExtendedDynamicStateFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExtendedDynamicStateFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceExtendedDynamicStateFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceExtendedDynamicStateFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceExtendedDynamicStateFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            extended_dynamic_state: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExtendedDynamicStateFeaturesEXT<'a> {
    #[inline]
    pub fn extended_dynamic_state(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR")]
pub struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline_executable_info: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline_executable_info: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'a> {
    #[inline]
    pub fn pipeline_executable_info(mut self, value: impl Into<Bool32>) -> Self {
        self.pipeline_executable_info = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInfoKHR.html>"]
#[doc(alias = "VkPipelineInfoKHR")]
pub struct PipelineInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline: Option<Pipeline>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineInfoKHR;
}
unsafe impl<'a> Send for PipelineInfoKHR<'a> {}
unsafe impl<'a> Sync for PipelineInfoKHR<'a> {}
impl<'a> Default for PipelineInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineInfoKHR<'a> {
    #[inline]
    pub fn pipeline(mut self, value: &'a Pipeline) -> Self {
        self.pipeline = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PipelineInfoEXT<'a> = PipelineInfoKHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutablePropertiesKHR.html>"]
#[doc(alias = "VkPipelineExecutablePropertiesKHR")]
pub struct PipelineExecutablePropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub stages: ShaderStageFlags,
    pub(crate) name: [c_char; MAX_DESCRIPTION_SIZE as _],
    pub(crate) description: [c_char; MAX_DESCRIPTION_SIZE as _],
    pub subgroup_size: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineExecutablePropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineExecutablePropertiesKHR;
}
unsafe impl<'a> Send for PipelineExecutablePropertiesKHR<'a> {}
unsafe impl<'a> Sync for PipelineExecutablePropertiesKHR<'a> {}
impl<'a> Default for PipelineExecutablePropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stages: Default::default(),
            name: array::from_fn(|_| Default::default()),
            description: array::from_fn(|_| Default::default()),
            subgroup_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineExecutablePropertiesKHR<'a> {
    #[inline]
    pub fn stages(mut self, value: ShaderStageFlags) -> Self {
        self.stages = value;
        self
    }
    #[inline]
    pub fn subgroup_size(mut self, value: u32) -> Self {
        self.subgroup_size = value;
        self
    }
    pub fn get_name(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.name) }.as_slice(),
        )
        .unwrap()
    }
    pub fn get_description(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.description) }
                .as_slice(),
        )
        .unwrap()
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutableInfoKHR.html>"]
#[doc(alias = "VkPipelineExecutableInfoKHR")]
pub struct PipelineExecutableInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline: Option<Pipeline>,
    pub executable_index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineExecutableInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineExecutableInfoKHR;
}
unsafe impl<'a> Send for PipelineExecutableInfoKHR<'a> {}
unsafe impl<'a> Sync for PipelineExecutableInfoKHR<'a> {}
impl<'a> Default for PipelineExecutableInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline: Default::default(),
            executable_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineExecutableInfoKHR<'a> {
    #[inline]
    pub fn pipeline(mut self, value: &'a Pipeline) -> Self {
        self.pipeline = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn executable_index(mut self, value: u32) -> Self {
        self.executable_index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutableStatisticValueKHR.html>"]
#[doc(alias = "VkPipelineExecutableStatisticValueKHR")]
pub union PipelineExecutableStatisticValueKHR {
    pub bool32: Bool32,
    pub int64: i64,
    pub uint64: u64,
    pub float64: f64,
}
impl Default for PipelineExecutableStatisticValueKHR {
    fn default() -> Self {
        Self {
            bool32: Default::default(),
        }
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutableStatisticKHR.html>"]
#[doc(alias = "VkPipelineExecutableStatisticKHR")]
pub struct PipelineExecutableStatisticKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) name: [c_char; MAX_DESCRIPTION_SIZE as _],
    pub(crate) description: [c_char; MAX_DESCRIPTION_SIZE as _],
    pub format: PipelineExecutableStatisticFormatKHR,
    pub value: PipelineExecutableStatisticValueKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineExecutableStatisticKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineExecutableStatisticKHR;
}
unsafe impl<'a> Send for PipelineExecutableStatisticKHR<'a> {}
unsafe impl<'a> Sync for PipelineExecutableStatisticKHR<'a> {}
impl<'a> Default for PipelineExecutableStatisticKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            name: array::from_fn(|_| Default::default()),
            description: array::from_fn(|_| Default::default()),
            format: PipelineExecutableStatisticFormatKHR::Bool32,
            value: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineExecutableStatisticKHR<'a> {
    #[inline]
    pub fn format(mut self, value: PipelineExecutableStatisticFormatKHR) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn value(mut self, value: PipelineExecutableStatisticValueKHR) -> Self {
        self.value = value;
        self
    }
    pub fn get_name(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.name) }.as_slice(),
        )
        .unwrap()
    }
    pub fn get_description(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.description) }
                .as_slice(),
        )
        .unwrap()
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutableInternalRepresentationKHR.html>"]
#[doc(alias = "VkPipelineExecutableInternalRepresentationKHR")]
pub struct PipelineExecutableInternalRepresentationKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) name: [c_char; MAX_DESCRIPTION_SIZE as _],
    pub(crate) description: [c_char; MAX_DESCRIPTION_SIZE as _],
    pub is_text: Bool32,
    pub data_size: usize,
    pub(crate) p_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineExecutableInternalRepresentationKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineExecutableInternalRepresentationKHR;
}
unsafe impl<'a> Send for PipelineExecutableInternalRepresentationKHR<'a> {}
unsafe impl<'a> Sync for PipelineExecutableInternalRepresentationKHR<'a> {}
impl<'a> Default for PipelineExecutableInternalRepresentationKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            name: array::from_fn(|_| Default::default()),
            description: array::from_fn(|_| Default::default()),
            is_text: Default::default(),
            data_size: Default::default(),
            p_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineExecutableInternalRepresentationKHR<'a> {
    #[inline]
    pub fn is_text(mut self, value: impl Into<Bool32>) -> Self {
        self.is_text = value.into();
        self
    }
    #[inline]
    pub fn data_size(mut self, value: usize) -> Self {
        self.data_size = value;
        self
    }
    pub fn get_name(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.name) }.as_slice(),
        )
        .unwrap()
    }
    pub fn get_description(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.description) }
                .as_slice(),
        )
        .unwrap()
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceHostImageCopyFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceHostImageCopyFeaturesEXT")]
pub struct PhysicalDeviceHostImageCopyFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub host_image_copy: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceHostImageCopyFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceHostImageCopyFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceHostImageCopyFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceHostImageCopyFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceHostImageCopyFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceHostImageCopyFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceHostImageCopyFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            host_image_copy: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceHostImageCopyFeaturesEXT<'a> {
    #[inline]
    pub fn host_image_copy(mut self, value: impl Into<Bool32>) -> Self {
        self.host_image_copy = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceHostImageCopyPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceHostImageCopyPropertiesEXT")]
pub struct PhysicalDeviceHostImageCopyPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub copy_src_layout_count: u32,
    pub(crate) p_copy_src_layouts: *const ImageLayout,
    pub copy_dst_layout_count: u32,
    pub(crate) p_copy_dst_layouts: *const ImageLayout,
    pub optimal_tiling_layout_uuid: [u8; UUID_SIZE as _],
    pub identical_memory_type_requirements: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceHostImageCopyPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceHostImageCopyPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceHostImageCopyPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceHostImageCopyPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceHostImageCopyPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceHostImageCopyPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            copy_src_layout_count: Default::default(),
            p_copy_src_layouts: ptr::null(),
            copy_dst_layout_count: Default::default(),
            p_copy_dst_layouts: ptr::null(),
            optimal_tiling_layout_uuid: array::from_fn(|_| Default::default()),
            identical_memory_type_requirements: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceHostImageCopyPropertiesEXT<'a> {
    #[inline]
    pub fn copy_src_layout_count(mut self, value: u32) -> Self {
        self.copy_src_layout_count = value;
        self
    }
    #[inline]
    pub fn copy_dst_layout_count(mut self, value: u32) -> Self {
        self.copy_dst_layout_count = value;
        self
    }
    #[inline]
    pub fn optimal_tiling_layout_uuid(mut self, value: [u8; UUID_SIZE as _]) -> Self {
        self.optimal_tiling_layout_uuid = value;
        self
    }
    #[inline]
    pub fn identical_memory_type_requirements(mut self, value: impl Into<Bool32>) -> Self {
        self.identical_memory_type_requirements = value.into();
        self
    }
    #[inline]
    pub fn copy_src_layouts(mut self, p_copy_src_layouts: impl AsSlice<'a, ImageLayout>) -> Self {
        self.p_copy_src_layouts = p_copy_src_layouts.as_slice().as_ptr().cast();
        self.copy_src_layout_count = p_copy_src_layouts.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn copy_dst_layouts(mut self, p_copy_dst_layouts: impl AsSlice<'a, ImageLayout>) -> Self {
        self.p_copy_dst_layouts = p_copy_dst_layouts.as_slice().as_ptr().cast();
        self.copy_dst_layout_count = p_copy_dst_layouts.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryToImageCopyEXT.html>"]
#[doc(alias = "VkMemoryToImageCopyEXT")]
pub struct MemoryToImageCopyEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_host_pointer: VoidPtr,
    pub memory_row_length: u32,
    pub memory_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    pub image_offset: Offset3D,
    pub image_extent: Extent3D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryToImageCopyEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryToImageCopyEXT;
}
unsafe impl<'a> Send for MemoryToImageCopyEXT<'a> {}
unsafe impl<'a> Sync for MemoryToImageCopyEXT<'a> {}
impl<'a> Default for MemoryToImageCopyEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_host_pointer: ptr::null(),
            memory_row_length: Default::default(),
            memory_image_height: Default::default(),
            image_subresource: Default::default(),
            image_offset: Default::default(),
            image_extent: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryToImageCopyEXT<'a> {
    #[inline]
    pub fn host_pointer(mut self, value: VoidPtr) -> Self {
        self.p_host_pointer = value;
        self
    }
    #[inline]
    pub fn memory_row_length(mut self, value: u32) -> Self {
        self.memory_row_length = value;
        self
    }
    #[inline]
    pub fn memory_image_height(mut self, value: u32) -> Self {
        self.memory_image_height = value;
        self
    }
    #[inline]
    pub fn image_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.image_subresource = value;
        self
    }
    #[inline]
    pub fn image_offset(mut self, value: Offset3D) -> Self {
        self.image_offset = value;
        self
    }
    #[inline]
    pub fn image_extent(mut self, value: Extent3D) -> Self {
        self.image_extent = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageToMemoryCopyEXT.html>"]
#[doc(alias = "VkImageToMemoryCopyEXT")]
pub struct ImageToMemoryCopyEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_host_pointer: VoidPtr,
    pub memory_row_length: u32,
    pub memory_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    pub image_offset: Offset3D,
    pub image_extent: Extent3D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageToMemoryCopyEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageToMemoryCopyEXT;
}
unsafe impl<'a> Send for ImageToMemoryCopyEXT<'a> {}
unsafe impl<'a> Sync for ImageToMemoryCopyEXT<'a> {}
impl<'a> Default for ImageToMemoryCopyEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_host_pointer: ptr::null(),
            memory_row_length: Default::default(),
            memory_image_height: Default::default(),
            image_subresource: Default::default(),
            image_offset: Default::default(),
            image_extent: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageToMemoryCopyEXT<'a> {
    #[inline]
    pub fn host_pointer(mut self, value: VoidPtr) -> Self {
        self.p_host_pointer = value;
        self
    }
    #[inline]
    pub fn memory_row_length(mut self, value: u32) -> Self {
        self.memory_row_length = value;
        self
    }
    #[inline]
    pub fn memory_image_height(mut self, value: u32) -> Self {
        self.memory_image_height = value;
        self
    }
    #[inline]
    pub fn image_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.image_subresource = value;
        self
    }
    #[inline]
    pub fn image_offset(mut self, value: Offset3D) -> Self {
        self.image_offset = value;
        self
    }
    #[inline]
    pub fn image_extent(mut self, value: Extent3D) -> Self {
        self.image_extent = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMemoryToImageInfoEXT.html>"]
#[doc(alias = "VkCopyMemoryToImageInfoEXT")]
pub struct CopyMemoryToImageInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: HostImageCopyFlagsEXT,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub(crate) region_count: u32,
    pub(crate) p_regions: *const MemoryToImageCopyEXT<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyMemoryToImageInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyMemoryToImageInfoEXT;
}
unsafe impl<'a> Send for CopyMemoryToImageInfoEXT<'a> {}
unsafe impl<'a> Sync for CopyMemoryToImageInfoEXT<'a> {}
impl<'a> Default for CopyMemoryToImageInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            dst_image: Default::default(),
            dst_image_layout: ImageLayout::Undefined,
            region_count: Default::default(),
            p_regions: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyMemoryToImageInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: HostImageCopyFlagsEXT) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn dst_image(mut self, value: &'a Image) -> Self {
        self.dst_image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, value: ImageLayout) -> Self {
        self.dst_image_layout = value;
        self
    }
    #[inline]
    pub fn regions(mut self, p_regions: impl AsSlice<'a, MemoryToImageCopyEXT<'a>>) -> Self {
        self.p_regions = p_regions.as_slice().as_ptr().cast();
        self.region_count = p_regions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageToMemoryInfoEXT.html>"]
#[doc(alias = "VkCopyImageToMemoryInfoEXT")]
pub struct CopyImageToMemoryInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: HostImageCopyFlagsEXT,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub(crate) region_count: u32,
    pub(crate) p_regions: *const ImageToMemoryCopyEXT<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyImageToMemoryInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyImageToMemoryInfoEXT;
}
unsafe impl<'a> Send for CopyImageToMemoryInfoEXT<'a> {}
unsafe impl<'a> Sync for CopyImageToMemoryInfoEXT<'a> {}
impl<'a> Default for CopyImageToMemoryInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            src_image: Default::default(),
            src_image_layout: ImageLayout::Undefined,
            region_count: Default::default(),
            p_regions: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyImageToMemoryInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: HostImageCopyFlagsEXT) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn src_image(mut self, value: &'a Image) -> Self {
        self.src_image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, value: ImageLayout) -> Self {
        self.src_image_layout = value;
        self
    }
    #[inline]
    pub fn regions(mut self, p_regions: impl AsSlice<'a, ImageToMemoryCopyEXT<'a>>) -> Self {
        self.p_regions = p_regions.as_slice().as_ptr().cast();
        self.region_count = p_regions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageToImageInfoEXT.html>"]
#[doc(alias = "VkCopyImageToImageInfoEXT")]
pub struct CopyImageToImageInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: HostImageCopyFlagsEXT,
    pub src_image: Option<Image>,
    pub src_image_layout: ImageLayout,
    pub dst_image: Option<Image>,
    pub dst_image_layout: ImageLayout,
    pub(crate) region_count: u32,
    pub(crate) p_regions: *const ImageCopy2<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyImageToImageInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyImageToImageInfoEXT;
}
unsafe impl<'a> Send for CopyImageToImageInfoEXT<'a> {}
unsafe impl<'a> Sync for CopyImageToImageInfoEXT<'a> {}
impl<'a> Default for CopyImageToImageInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            src_image: Default::default(),
            src_image_layout: ImageLayout::Undefined,
            dst_image: Default::default(),
            dst_image_layout: ImageLayout::Undefined,
            region_count: Default::default(),
            p_regions: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyImageToImageInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: HostImageCopyFlagsEXT) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn src_image(mut self, value: &'a Image) -> Self {
        self.src_image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, value: ImageLayout) -> Self {
        self.src_image_layout = value;
        self
    }
    #[inline]
    pub fn dst_image(mut self, value: &'a Image) -> Self {
        self.dst_image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, value: ImageLayout) -> Self {
        self.dst_image_layout = value;
        self
    }
    #[inline]
    pub fn regions(mut self, p_regions: impl AsSlice<'a, ImageCopy2<'a>>) -> Self {
        self.p_regions = p_regions.as_slice().as_ptr().cast();
        self.region_count = p_regions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkHostImageLayoutTransitionInfoEXT.html>"]
#[doc(alias = "VkHostImageLayoutTransitionInfoEXT")]
pub struct HostImageLayoutTransitionInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image: Option<Image>,
    pub old_layout: ImageLayout,
    pub new_layout: ImageLayout,
    pub subresource_range: ImageSubresourceRange,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for HostImageLayoutTransitionInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::HostImageLayoutTransitionInfoEXT;
}
unsafe impl<'a> Send for HostImageLayoutTransitionInfoEXT<'a> {}
unsafe impl<'a> Sync for HostImageLayoutTransitionInfoEXT<'a> {}
impl<'a> Default for HostImageLayoutTransitionInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image: Default::default(),
            old_layout: ImageLayout::Undefined,
            new_layout: ImageLayout::Undefined,
            subresource_range: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> HostImageLayoutTransitionInfoEXT<'a> {
    #[inline]
    pub fn image(mut self, value: &'a Image) -> Self {
        self.image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn old_layout(mut self, value: ImageLayout) -> Self {
        self.old_layout = value;
        self
    }
    #[inline]
    pub fn new_layout(mut self, value: ImageLayout) -> Self {
        self.new_layout = value;
        self
    }
    #[inline]
    pub fn subresource_range(mut self, value: ImageSubresourceRange) -> Self {
        self.subresource_range = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubresourceHostMemcpySizeEXT.html>"]
#[doc(alias = "VkSubresourceHostMemcpySizeEXT")]
pub struct SubresourceHostMemcpySizeEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SubresourceHostMemcpySizeEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SubresourceHostMemcpySizeEXT;
}
unsafe impl<'a> Send for SubresourceHostMemcpySizeEXT<'a> {}
unsafe impl<'a> Sync for SubresourceHostMemcpySizeEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubresourceLayout2KHR<'b>>
    for SubresourceHostMemcpySizeEXT<'a>
{
}
impl<'a> Default for SubresourceHostMemcpySizeEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubresourceHostMemcpySizeEXT<'a> {
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkHostImageCopyDevicePerformanceQueryEXT.html>"]
#[doc(alias = "VkHostImageCopyDevicePerformanceQueryEXT")]
pub struct HostImageCopyDevicePerformanceQueryEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub optimal_device_access: Bool32,
    pub identical_memory_layout: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for HostImageCopyDevicePerformanceQueryEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::HostImageCopyDevicePerformanceQueryEXT;
}
unsafe impl<'a> Send for HostImageCopyDevicePerformanceQueryEXT<'a> {}
unsafe impl<'a> Sync for HostImageCopyDevicePerformanceQueryEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageFormatProperties2<'b>>
    for HostImageCopyDevicePerformanceQueryEXT<'a>
{
}
impl<'a> Default for HostImageCopyDevicePerformanceQueryEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            optimal_device_access: Default::default(),
            identical_memory_layout: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> HostImageCopyDevicePerformanceQueryEXT<'a> {
    #[inline]
    pub fn optimal_device_access(mut self, value: impl Into<Bool32>) -> Self {
        self.optimal_device_access = value.into();
        self
    }
    #[inline]
    pub fn identical_memory_layout(mut self, value: impl Into<Bool32>) -> Self {
        self.identical_memory_layout = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryMapInfoKHR.html>"]
#[doc(alias = "VkMemoryMapInfoKHR")]
pub struct MemoryMapInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: MemoryMapFlags,
    pub memory: Option<DeviceMemory>,
    pub offset: DeviceSize,
    pub size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryMapInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryMapInfoKHR;
}
unsafe impl<'a> Send for MemoryMapInfoKHR<'a> {}
unsafe impl<'a> Sync for MemoryMapInfoKHR<'a> {}
impl<'a> Default for MemoryMapInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            memory: Default::default(),
            offset: Default::default(),
            size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryMapInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: MemoryMapFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn offset(mut self, value: DeviceSize) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryUnmapInfoKHR.html>"]
#[doc(alias = "VkMemoryUnmapInfoKHR")]
pub struct MemoryUnmapInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: MemoryUnmapFlagsKHR,
    pub memory: Option<DeviceMemory>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryUnmapInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryUnmapInfoKHR;
}
unsafe impl<'a> Send for MemoryUnmapInfoKHR<'a> {}
unsafe impl<'a> Sync for MemoryUnmapInfoKHR<'a> {}
impl<'a> Default for MemoryUnmapInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            memory: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryUnmapInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: MemoryUnmapFlagsKHR) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMapMemoryPlacedFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceMapMemoryPlacedFeaturesEXT")]
pub struct PhysicalDeviceMapMemoryPlacedFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory_map_placed: Bool32,
    pub memory_map_range_placed: Bool32,
    pub memory_unmap_reserve: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMapMemoryPlacedFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMapMemoryPlacedFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceMapMemoryPlacedFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMapMemoryPlacedFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMapMemoryPlacedFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMapMemoryPlacedFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceMapMemoryPlacedFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory_map_placed: Default::default(),
            memory_map_range_placed: Default::default(),
            memory_unmap_reserve: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMapMemoryPlacedFeaturesEXT<'a> {
    #[inline]
    pub fn memory_map_placed(mut self, value: impl Into<Bool32>) -> Self {
        self.memory_map_placed = value.into();
        self
    }
    #[inline]
    pub fn memory_map_range_placed(mut self, value: impl Into<Bool32>) -> Self {
        self.memory_map_range_placed = value.into();
        self
    }
    #[inline]
    pub fn memory_unmap_reserve(mut self, value: impl Into<Bool32>) -> Self {
        self.memory_unmap_reserve = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMapMemoryPlacedPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceMapMemoryPlacedPropertiesEXT")]
pub struct PhysicalDeviceMapMemoryPlacedPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub min_placed_memory_map_alignment: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMapMemoryPlacedPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMapMemoryPlacedPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceMapMemoryPlacedPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMapMemoryPlacedPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceMapMemoryPlacedPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceMapMemoryPlacedPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            min_placed_memory_map_alignment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMapMemoryPlacedPropertiesEXT<'a> {
    #[inline]
    pub fn min_placed_memory_map_alignment(mut self, value: DeviceSize) -> Self {
        self.min_placed_memory_map_alignment = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryMapPlacedInfoEXT.html>"]
#[doc(alias = "VkMemoryMapPlacedInfoEXT")]
pub struct MemoryMapPlacedInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_placed_address: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryMapPlacedInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryMapPlacedInfoEXT;
}
unsafe impl<'a> Send for MemoryMapPlacedInfoEXT<'a> {}
unsafe impl<'a> Sync for MemoryMapPlacedInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryMapInfoKHR<'b>> for MemoryMapPlacedInfoEXT<'a> {}
impl<'a> Default for MemoryMapPlacedInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_placed_address: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryMapPlacedInfoEXT<'a> {
    #[inline]
    pub fn placed_address(mut self, value: VoidPtr) -> Self {
        self.p_placed_address = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT")]
pub struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_buffer_float16_atomics: Bool32,
    pub shader_buffer_float16_atomic_add: Bool32,
    pub shader_buffer_float16_atomic_min_max: Bool32,
    pub shader_buffer_float32_atomic_min_max: Bool32,
    pub shader_buffer_float64_atomic_min_max: Bool32,
    pub shader_shared_float16_atomics: Bool32,
    pub shader_shared_float16_atomic_add: Bool32,
    pub shader_shared_float16_atomic_min_max: Bool32,
    pub shader_shared_float32_atomic_min_max: Bool32,
    pub shader_shared_float64_atomic_min_max: Bool32,
    pub shader_image_float32_atomic_min_max: Bool32,
    pub sparse_image_float32_atomic_min_max: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderAtomicFloat2FeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_buffer_float16_atomics: Default::default(),
            shader_buffer_float16_atomic_add: Default::default(),
            shader_buffer_float16_atomic_min_max: Default::default(),
            shader_buffer_float32_atomic_min_max: Default::default(),
            shader_buffer_float64_atomic_min_max: Default::default(),
            shader_shared_float16_atomics: Default::default(),
            shader_shared_float16_atomic_add: Default::default(),
            shader_shared_float16_atomic_min_max: Default::default(),
            shader_shared_float32_atomic_min_max: Default::default(),
            shader_shared_float64_atomic_min_max: Default::default(),
            shader_image_float32_atomic_min_max: Default::default(),
            sparse_image_float32_atomic_min_max: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'a> {
    #[inline]
    pub fn shader_buffer_float16_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_buffer_float16_atomics = value.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float16_atomic_add(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_buffer_float16_atomic_add = value.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float16_atomic_min_max(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_buffer_float16_atomic_min_max = value.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float32_atomic_min_max(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_buffer_float32_atomic_min_max = value.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float64_atomic_min_max(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_buffer_float64_atomic_min_max = value.into();
        self
    }
    #[inline]
    pub fn shader_shared_float16_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_shared_float16_atomics = value.into();
        self
    }
    #[inline]
    pub fn shader_shared_float16_atomic_add(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_shared_float16_atomic_add = value.into();
        self
    }
    #[inline]
    pub fn shader_shared_float16_atomic_min_max(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_shared_float16_atomic_min_max = value.into();
        self
    }
    #[inline]
    pub fn shader_shared_float32_atomic_min_max(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_shared_float32_atomic_min_max = value.into();
        self
    }
    #[inline]
    pub fn shader_shared_float64_atomic_min_max(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_shared_float64_atomic_min_max = value.into();
        self
    }
    #[inline]
    pub fn shader_image_float32_atomic_min_max(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_image_float32_atomic_min_max = value.into();
        self
    }
    #[inline]
    pub fn sparse_image_float32_atomic_min_max(mut self, value: impl Into<Bool32>) -> Self {
        self.sparse_image_float32_atomic_min_max = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfacePresentModeEXT.html>"]
#[doc(alias = "VkSurfacePresentModeEXT")]
pub struct SurfacePresentModeEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub present_mode: PresentModeKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SurfacePresentModeEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SurfacePresentModeEXT;
}
unsafe impl<'a> Send for SurfacePresentModeEXT<'a> {}
unsafe impl<'a> Sync for SurfacePresentModeEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceSurfaceInfo2KHR<'b>>
    for SurfacePresentModeEXT<'a>
{
}
impl<'a> Default for SurfacePresentModeEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_mode: PresentModeKHR::Immediate,
            phantom: PhantomData,
        }
    }
}
impl<'a> SurfacePresentModeEXT<'a> {
    #[inline]
    pub fn present_mode(mut self, value: PresentModeKHR) -> Self {
        self.present_mode = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfacePresentScalingCapabilitiesEXT.html>"]
#[doc(alias = "VkSurfacePresentScalingCapabilitiesEXT")]
pub struct SurfacePresentScalingCapabilitiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub supported_present_scaling: PresentScalingFlagsEXT,
    pub supported_present_gravity_x: PresentGravityFlagsEXT,
    pub supported_present_gravity_y: PresentGravityFlagsEXT,
    pub min_scaled_image_extent: Extent2D,
    pub max_scaled_image_extent: Extent2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SurfacePresentScalingCapabilitiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SurfacePresentScalingCapabilitiesEXT;
}
unsafe impl<'a> Send for SurfacePresentScalingCapabilitiesEXT<'a> {}
unsafe impl<'a> Sync for SurfacePresentScalingCapabilitiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SurfaceCapabilities2KHR<'b>>
    for SurfacePresentScalingCapabilitiesEXT<'a>
{
}
impl<'a> Default for SurfacePresentScalingCapabilitiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            supported_present_scaling: Default::default(),
            supported_present_gravity_x: Default::default(),
            supported_present_gravity_y: Default::default(),
            min_scaled_image_extent: Default::default(),
            max_scaled_image_extent: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SurfacePresentScalingCapabilitiesEXT<'a> {
    #[inline]
    pub fn supported_present_scaling(mut self, value: PresentScalingFlagsEXT) -> Self {
        self.supported_present_scaling = value;
        self
    }
    #[inline]
    pub fn supported_present_gravity_x(mut self, value: PresentGravityFlagsEXT) -> Self {
        self.supported_present_gravity_x = value;
        self
    }
    #[inline]
    pub fn supported_present_gravity_y(mut self, value: PresentGravityFlagsEXT) -> Self {
        self.supported_present_gravity_y = value;
        self
    }
    #[inline]
    pub fn min_scaled_image_extent(mut self, value: Extent2D) -> Self {
        self.min_scaled_image_extent = value;
        self
    }
    #[inline]
    pub fn max_scaled_image_extent(mut self, value: Extent2D) -> Self {
        self.max_scaled_image_extent = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfacePresentModeCompatibilityEXT.html>"]
#[doc(alias = "VkSurfacePresentModeCompatibilityEXT")]
pub struct SurfacePresentModeCompatibilityEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub present_mode_count: u32,
    pub(crate) p_present_modes: *const PresentModeKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SurfacePresentModeCompatibilityEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SurfacePresentModeCompatibilityEXT;
}
unsafe impl<'a> Send for SurfacePresentModeCompatibilityEXT<'a> {}
unsafe impl<'a> Sync for SurfacePresentModeCompatibilityEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SurfaceCapabilities2KHR<'b>>
    for SurfacePresentModeCompatibilityEXT<'a>
{
}
impl<'a> Default for SurfacePresentModeCompatibilityEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_mode_count: Default::default(),
            p_present_modes: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SurfacePresentModeCompatibilityEXT<'a> {
    #[inline]
    pub fn present_mode_count(mut self, value: u32) -> Self {
        self.present_mode_count = value;
        self
    }
    #[inline]
    pub fn present_modes(mut self, p_present_modes: impl AsSlice<'a, PresentModeKHR>) -> Self {
        self.p_present_modes = p_present_modes.as_slice().as_ptr().cast();
        self.present_mode_count = p_present_modes.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT")]
pub struct PhysicalDeviceSwapchainMaintenance1FeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub swapchain_maintenance1: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSwapchainMaintenance1FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceSwapchainMaintenance1FeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceSwapchainMaintenance1FeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSwapchainMaintenance1FeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceSwapchainMaintenance1FeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceSwapchainMaintenance1FeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceSwapchainMaintenance1FeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            swapchain_maintenance1: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSwapchainMaintenance1FeaturesEXT<'a> {
    #[inline]
    pub fn swapchain_maintenance1(mut self, value: impl Into<Bool32>) -> Self {
        self.swapchain_maintenance1 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainPresentFenceInfoEXT.html>"]
#[doc(alias = "VkSwapchainPresentFenceInfoEXT")]
pub struct SwapchainPresentFenceInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) swapchain_count: u32,
    pub(crate) p_fences: *const Fence,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SwapchainPresentFenceInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SwapchainPresentFenceInfoEXT;
}
unsafe impl<'a> Send for SwapchainPresentFenceInfoEXT<'a> {}
unsafe impl<'a> Sync for SwapchainPresentFenceInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PresentInfoKHR<'b>> for SwapchainPresentFenceInfoEXT<'a> {}
impl<'a> Default for SwapchainPresentFenceInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            swapchain_count: Default::default(),
            p_fences: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SwapchainPresentFenceInfoEXT<'a> {
    #[inline]
    pub fn fences<V0: Alias<raw::Fence> + 'a>(mut self, p_fences: impl AsSlice<'a, V0>) -> Self {
        self.p_fences = p_fences.as_slice().as_ptr().cast();
        self.swapchain_count = p_fences.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainPresentModesCreateInfoEXT.html>"]
#[doc(alias = "VkSwapchainPresentModesCreateInfoEXT")]
pub struct SwapchainPresentModesCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) present_mode_count: u32,
    pub(crate) p_present_modes: *const PresentModeKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SwapchainPresentModesCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SwapchainPresentModesCreateInfoEXT;
}
unsafe impl<'a> Send for SwapchainPresentModesCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for SwapchainPresentModesCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SwapchainCreateInfoKHR<'b>>
    for SwapchainPresentModesCreateInfoEXT<'a>
{
}
impl<'a> Default for SwapchainPresentModesCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_mode_count: Default::default(),
            p_present_modes: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SwapchainPresentModesCreateInfoEXT<'a> {
    #[inline]
    pub fn present_modes(mut self, p_present_modes: impl AsSlice<'a, PresentModeKHR>) -> Self {
        self.p_present_modes = p_present_modes.as_slice().as_ptr().cast();
        self.present_mode_count = p_present_modes.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainPresentModeInfoEXT.html>"]
#[doc(alias = "VkSwapchainPresentModeInfoEXT")]
pub struct SwapchainPresentModeInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) swapchain_count: u32,
    pub(crate) p_present_modes: *const PresentModeKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SwapchainPresentModeInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SwapchainPresentModeInfoEXT;
}
unsafe impl<'a> Send for SwapchainPresentModeInfoEXT<'a> {}
unsafe impl<'a> Sync for SwapchainPresentModeInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PresentInfoKHR<'b>> for SwapchainPresentModeInfoEXT<'a> {}
impl<'a> Default for SwapchainPresentModeInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            swapchain_count: Default::default(),
            p_present_modes: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SwapchainPresentModeInfoEXT<'a> {
    #[inline]
    pub fn present_modes(mut self, p_present_modes: impl AsSlice<'a, PresentModeKHR>) -> Self {
        self.p_present_modes = p_present_modes.as_slice().as_ptr().cast();
        self.swapchain_count = p_present_modes.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainPresentScalingCreateInfoEXT.html>"]
#[doc(alias = "VkSwapchainPresentScalingCreateInfoEXT")]
pub struct SwapchainPresentScalingCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub scaling_behavior: PresentScalingFlagsEXT,
    pub present_gravity_x: PresentGravityFlagsEXT,
    pub present_gravity_y: PresentGravityFlagsEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SwapchainPresentScalingCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SwapchainPresentScalingCreateInfoEXT;
}
unsafe impl<'a> Send for SwapchainPresentScalingCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for SwapchainPresentScalingCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SwapchainCreateInfoKHR<'b>>
    for SwapchainPresentScalingCreateInfoEXT<'a>
{
}
impl<'a> Default for SwapchainPresentScalingCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            scaling_behavior: Default::default(),
            present_gravity_x: Default::default(),
            present_gravity_y: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SwapchainPresentScalingCreateInfoEXT<'a> {
    #[inline]
    pub fn scaling_behavior(mut self, value: PresentScalingFlagsEXT) -> Self {
        self.scaling_behavior = value;
        self
    }
    #[inline]
    pub fn present_gravity_x(mut self, value: PresentGravityFlagsEXT) -> Self {
        self.present_gravity_x = value;
        self
    }
    #[inline]
    pub fn present_gravity_y(mut self, value: PresentGravityFlagsEXT) -> Self {
        self.present_gravity_y = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkReleaseSwapchainImagesInfoEXT.html>"]
#[doc(alias = "VkReleaseSwapchainImagesInfoEXT")]
pub struct ReleaseSwapchainImagesInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub swapchain: Option<SwapchainKHR>,
    pub(crate) image_index_count: u32,
    pub(crate) p_image_indices: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ReleaseSwapchainImagesInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ReleaseSwapchainImagesInfoEXT;
}
unsafe impl<'a> Send for ReleaseSwapchainImagesInfoEXT<'a> {}
unsafe impl<'a> Sync for ReleaseSwapchainImagesInfoEXT<'a> {}
impl<'a> Default for ReleaseSwapchainImagesInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            swapchain: Default::default(),
            image_index_count: Default::default(),
            p_image_indices: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ReleaseSwapchainImagesInfoEXT<'a> {
    #[inline]
    pub fn swapchain(mut self, value: &'a SwapchainKHR) -> Self {
        self.swapchain = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn image_indices(mut self, p_image_indices: impl AsSlice<'a, u32>) -> Self {
        self.p_image_indices = p_image_indices.as_slice().as_ptr().cast();
        self.image_index_count = p_image_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV")]
pub struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_graphics_shader_group_count: u32,
    pub max_indirect_sequence_count: u32,
    pub max_indirect_commands_token_count: u32,
    pub max_indirect_commands_stream_count: u32,
    pub max_indirect_commands_token_offset: u32,
    pub max_indirect_commands_stream_stride: u32,
    pub min_sequences_count_buffer_offset_alignment: u32,
    pub min_sequences_index_buffer_offset_alignment: u32,
    pub min_indirect_commands_buffer_offset_alignment: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDeviceGeneratedCommandsPropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_graphics_shader_group_count: Default::default(),
            max_indirect_sequence_count: Default::default(),
            max_indirect_commands_token_count: Default::default(),
            max_indirect_commands_stream_count: Default::default(),
            max_indirect_commands_token_offset: Default::default(),
            max_indirect_commands_stream_stride: Default::default(),
            min_sequences_count_buffer_offset_alignment: Default::default(),
            min_sequences_index_buffer_offset_alignment: Default::default(),
            min_indirect_commands_buffer_offset_alignment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDeviceGeneratedCommandsPropertiesNV<'a> {
    #[inline]
    pub fn max_graphics_shader_group_count(mut self, value: u32) -> Self {
        self.max_graphics_shader_group_count = value;
        self
    }
    #[inline]
    pub fn max_indirect_sequence_count(mut self, value: u32) -> Self {
        self.max_indirect_sequence_count = value;
        self
    }
    #[inline]
    pub fn max_indirect_commands_token_count(mut self, value: u32) -> Self {
        self.max_indirect_commands_token_count = value;
        self
    }
    #[inline]
    pub fn max_indirect_commands_stream_count(mut self, value: u32) -> Self {
        self.max_indirect_commands_stream_count = value;
        self
    }
    #[inline]
    pub fn max_indirect_commands_token_offset(mut self, value: u32) -> Self {
        self.max_indirect_commands_token_offset = value;
        self
    }
    #[inline]
    pub fn max_indirect_commands_stream_stride(mut self, value: u32) -> Self {
        self.max_indirect_commands_stream_stride = value;
        self
    }
    #[inline]
    pub fn min_sequences_count_buffer_offset_alignment(mut self, value: u32) -> Self {
        self.min_sequences_count_buffer_offset_alignment = value;
        self
    }
    #[inline]
    pub fn min_sequences_index_buffer_offset_alignment(mut self, value: u32) -> Self {
        self.min_sequences_index_buffer_offset_alignment = value;
        self
    }
    #[inline]
    pub fn min_indirect_commands_buffer_offset_alignment(mut self, value: u32) -> Self {
        self.min_indirect_commands_buffer_offset_alignment = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV")]
pub struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_generated_commands: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_generated_commands: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'a> {
    #[inline]
    pub fn device_generated_commands(mut self, value: impl Into<Bool32>) -> Self {
        self.device_generated_commands = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsShaderGroupCreateInfoNV.html>"]
#[doc(alias = "VkGraphicsShaderGroupCreateInfoNV")]
pub struct GraphicsShaderGroupCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) stage_count: u32,
    pub(crate) p_stages: *const PipelineShaderStageCreateInfo<'a>,
    pub p_vertex_input_state: *const PipelineVertexInputStateCreateInfo<'a>,
    pub p_tessellation_state: *const PipelineTessellationStateCreateInfo<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for GraphicsShaderGroupCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GraphicsShaderGroupCreateInfoNV;
}
unsafe impl<'a> Send for GraphicsShaderGroupCreateInfoNV<'a> {}
unsafe impl<'a> Sync for GraphicsShaderGroupCreateInfoNV<'a> {}
impl<'a> Default for GraphicsShaderGroupCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stage_count: Default::default(),
            p_stages: ptr::null(),
            p_vertex_input_state: ptr::null(),
            p_tessellation_state: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> GraphicsShaderGroupCreateInfoNV<'a> {
    #[inline]
    pub fn vertex_input_state(
        mut self,
        value: Option<&'a PipelineVertexInputStateCreateInfo<'a>>,
    ) -> Self {
        self.p_vertex_input_state = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn tessellation_state(
        mut self,
        value: Option<&'a PipelineTessellationStateCreateInfo<'a>>,
    ) -> Self {
        self.p_tessellation_state = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn stages(mut self, p_stages: impl AsSlice<'a, PipelineShaderStageCreateInfo<'a>>) -> Self {
        self.p_stages = p_stages.as_slice().as_ptr().cast();
        self.stage_count = p_stages.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineShaderGroupsCreateInfoNV.html>"]
#[doc(alias = "VkGraphicsPipelineShaderGroupsCreateInfoNV")]
pub struct GraphicsPipelineShaderGroupsCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) group_count: u32,
    pub(crate) p_groups: *const GraphicsShaderGroupCreateInfoNV<'a>,
    pub(crate) pipeline_count: u32,
    pub(crate) p_pipelines: *const Pipeline,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for GraphicsPipelineShaderGroupsCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GraphicsPipelineShaderGroupsCreateInfoNV;
}
unsafe impl<'a> Send for GraphicsPipelineShaderGroupsCreateInfoNV<'a> {}
unsafe impl<'a> Sync for GraphicsPipelineShaderGroupsCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for GraphicsPipelineShaderGroupsCreateInfoNV<'a>
{
}
impl<'a> Default for GraphicsPipelineShaderGroupsCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            group_count: Default::default(),
            p_groups: ptr::null(),
            pipeline_count: Default::default(),
            p_pipelines: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> GraphicsPipelineShaderGroupsCreateInfoNV<'a> {
    #[inline]
    pub fn groups(
        mut self,
        p_groups: impl AsSlice<'a, GraphicsShaderGroupCreateInfoNV<'a>>,
    ) -> Self {
        self.p_groups = p_groups.as_slice().as_ptr().cast();
        self.group_count = p_groups.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn pipelines<V0: Alias<raw::Pipeline> + 'a>(
        mut self,
        p_pipelines: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_pipelines = p_pipelines.as_slice().as_ptr().cast();
        self.pipeline_count = p_pipelines.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindShaderGroupIndirectCommandNV.html>"]
#[doc(alias = "VkBindShaderGroupIndirectCommandNV")]
pub struct BindShaderGroupIndirectCommandNV {
    pub group_index: u32,
}
unsafe impl Send for BindShaderGroupIndirectCommandNV {}
unsafe impl Sync for BindShaderGroupIndirectCommandNV {}
impl Default for BindShaderGroupIndirectCommandNV {
    fn default() -> Self {
        Self {
            group_index: Default::default(),
        }
    }
}
impl BindShaderGroupIndirectCommandNV {
    #[inline]
    pub fn group_index(mut self, value: u32) -> Self {
        self.group_index = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindIndexBufferIndirectCommandNV.html>"]
#[doc(alias = "VkBindIndexBufferIndirectCommandNV")]
pub struct BindIndexBufferIndirectCommandNV {
    pub buffer_address: DeviceAddress,
    pub size: u32,
    pub index_type: IndexType,
}
unsafe impl Send for BindIndexBufferIndirectCommandNV {}
unsafe impl Sync for BindIndexBufferIndirectCommandNV {}
impl Default for BindIndexBufferIndirectCommandNV {
    fn default() -> Self {
        Self {
            buffer_address: Default::default(),
            size: Default::default(),
            index_type: IndexType::Uint16,
        }
    }
}
impl BindIndexBufferIndirectCommandNV {
    #[inline]
    pub fn buffer_address(mut self, value: DeviceAddress) -> Self {
        self.buffer_address = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: u32) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn index_type(mut self, value: IndexType) -> Self {
        self.index_type = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindVertexBufferIndirectCommandNV.html>"]
#[doc(alias = "VkBindVertexBufferIndirectCommandNV")]
pub struct BindVertexBufferIndirectCommandNV {
    pub buffer_address: DeviceAddress,
    pub size: u32,
    pub stride: u32,
}
unsafe impl Send for BindVertexBufferIndirectCommandNV {}
unsafe impl Sync for BindVertexBufferIndirectCommandNV {}
impl Default for BindVertexBufferIndirectCommandNV {
    fn default() -> Self {
        Self {
            buffer_address: Default::default(),
            size: Default::default(),
            stride: Default::default(),
        }
    }
}
impl BindVertexBufferIndirectCommandNV {
    #[inline]
    pub fn buffer_address(mut self, value: DeviceAddress) -> Self {
        self.buffer_address = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: u32) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn stride(mut self, value: u32) -> Self {
        self.stride = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSetStateFlagsIndirectCommandNV.html>"]
#[doc(alias = "VkSetStateFlagsIndirectCommandNV")]
pub struct SetStateFlagsIndirectCommandNV {
    pub data: u32,
}
unsafe impl Send for SetStateFlagsIndirectCommandNV {}
unsafe impl Sync for SetStateFlagsIndirectCommandNV {}
impl Default for SetStateFlagsIndirectCommandNV {
    fn default() -> Self {
        Self {
            data: Default::default(),
        }
    }
}
impl SetStateFlagsIndirectCommandNV {
    #[inline]
    pub fn data(mut self, value: u32) -> Self {
        self.data = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndirectCommandsStreamNV.html>"]
#[doc(alias = "VkIndirectCommandsStreamNV")]
pub struct IndirectCommandsStreamNV<'a> {
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for IndirectCommandsStreamNV<'a> {}
unsafe impl<'a> Sync for IndirectCommandsStreamNV<'a> {}
impl<'a> Default for IndirectCommandsStreamNV<'a> {
    fn default() -> Self {
        Self {
            buffer: Default::default(),
            offset: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> IndirectCommandsStreamNV<'a> {
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn offset(mut self, value: DeviceSize) -> Self {
        self.offset = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndirectCommandsLayoutTokenNV.html>"]
#[doc(alias = "VkIndirectCommandsLayoutTokenNV")]
pub struct IndirectCommandsLayoutTokenNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub token_type: IndirectCommandsTokenTypeNV,
    pub stream: u32,
    pub offset: u32,
    pub vertex_binding_unit: u32,
    pub vertex_dynamic_stride: Bool32,
    pub pushconstant_pipeline_layout: Option<PipelineLayout>,
    pub pushconstant_shader_stage_flags: ShaderStageFlags,
    pub pushconstant_offset: u32,
    pub pushconstant_size: u32,
    pub indirect_state_flags: IndirectStateFlagsNV,
    pub(crate) index_type_count: u32,
    pub(crate) p_index_types: *const IndexType,
    pub(crate) p_index_type_values: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for IndirectCommandsLayoutTokenNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IndirectCommandsLayoutTokenNV;
}
unsafe impl<'a> Send for IndirectCommandsLayoutTokenNV<'a> {}
unsafe impl<'a> Sync for IndirectCommandsLayoutTokenNV<'a> {}
impl<'a> Default for IndirectCommandsLayoutTokenNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            token_type: IndirectCommandsTokenTypeNV::ShaderGroup,
            stream: Default::default(),
            offset: Default::default(),
            vertex_binding_unit: Default::default(),
            vertex_dynamic_stride: Default::default(),
            pushconstant_pipeline_layout: Default::default(),
            pushconstant_shader_stage_flags: Default::default(),
            pushconstant_offset: Default::default(),
            pushconstant_size: Default::default(),
            indirect_state_flags: Default::default(),
            index_type_count: Default::default(),
            p_index_types: ptr::null(),
            p_index_type_values: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> IndirectCommandsLayoutTokenNV<'a> {
    #[inline]
    pub fn token_type(mut self, value: IndirectCommandsTokenTypeNV) -> Self {
        self.token_type = value;
        self
    }
    #[inline]
    pub fn stream(mut self, value: u32) -> Self {
        self.stream = value;
        self
    }
    #[inline]
    pub fn offset(mut self, value: u32) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn vertex_binding_unit(mut self, value: u32) -> Self {
        self.vertex_binding_unit = value;
        self
    }
    #[inline]
    pub fn vertex_dynamic_stride(mut self, value: impl Into<Bool32>) -> Self {
        self.vertex_dynamic_stride = value.into();
        self
    }
    #[inline]
    pub fn pushconstant_pipeline_layout(mut self, value: Option<&'a PipelineLayout>) -> Self {
        self.pushconstant_pipeline_layout = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn pushconstant_shader_stage_flags(mut self, value: ShaderStageFlags) -> Self {
        self.pushconstant_shader_stage_flags = value;
        self
    }
    #[inline]
    pub fn pushconstant_offset(mut self, value: u32) -> Self {
        self.pushconstant_offset = value;
        self
    }
    #[inline]
    pub fn pushconstant_size(mut self, value: u32) -> Self {
        self.pushconstant_size = value;
        self
    }
    #[inline]
    pub fn indirect_state_flags(mut self, value: IndirectStateFlagsNV) -> Self {
        self.indirect_state_flags = value;
        self
    }
    #[inline]
    pub fn index_type(
        mut self,
        p_index_types: impl AsSlice<'a, IndexType>,
        p_index_type_values: impl AsSlice<'a, u32>,
    ) -> Self {
        self.p_index_types = p_index_types.as_slice().as_ptr().cast();
        self.p_index_type_values = p_index_type_values.as_slice().as_ptr().cast();
        self.index_type_count = p_index_types.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndirectCommandsLayoutCreateInfoNV.html>"]
#[doc(alias = "VkIndirectCommandsLayoutCreateInfoNV")]
pub struct IndirectCommandsLayoutCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: IndirectCommandsLayoutUsageFlagsNV,
    pub pipeline_bind_point: PipelineBindPoint,
    pub(crate) token_count: u32,
    pub(crate) p_tokens: *const IndirectCommandsLayoutTokenNV<'a>,
    pub(crate) stream_count: u32,
    pub(crate) p_stream_strides: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for IndirectCommandsLayoutCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::IndirectCommandsLayoutCreateInfoNV;
}
unsafe impl<'a> Send for IndirectCommandsLayoutCreateInfoNV<'a> {}
unsafe impl<'a> Sync for IndirectCommandsLayoutCreateInfoNV<'a> {}
impl<'a> Default for IndirectCommandsLayoutCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            pipeline_bind_point: PipelineBindPoint::Graphics,
            token_count: Default::default(),
            p_tokens: ptr::null(),
            stream_count: Default::default(),
            p_stream_strides: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> IndirectCommandsLayoutCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, value: IndirectCommandsLayoutUsageFlagsNV) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn pipeline_bind_point(mut self, value: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = value;
        self
    }
    #[inline]
    pub fn tokens(mut self, p_tokens: impl AsSlice<'a, IndirectCommandsLayoutTokenNV<'a>>) -> Self {
        self.p_tokens = p_tokens.as_slice().as_ptr().cast();
        self.token_count = p_tokens.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn stream_strides(mut self, p_stream_strides: impl AsSlice<'a, u32>) -> Self {
        self.p_stream_strides = p_stream_strides.as_slice().as_ptr().cast();
        self.stream_count = p_stream_strides.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeneratedCommandsInfoNV.html>"]
#[doc(alias = "VkGeneratedCommandsInfoNV")]
pub struct GeneratedCommandsInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline: Option<Pipeline>,
    pub indirect_commands_layout: Option<IndirectCommandsLayoutNV>,
    pub(crate) stream_count: u32,
    pub(crate) p_streams: *const IndirectCommandsStreamNV<'a>,
    pub sequences_count: u32,
    pub preprocess_buffer: Option<Buffer>,
    pub preprocess_offset: DeviceSize,
    pub preprocess_size: DeviceSize,
    pub sequences_count_buffer: Option<Buffer>,
    pub sequences_count_offset: DeviceSize,
    pub sequences_index_buffer: Option<Buffer>,
    pub sequences_index_offset: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for GeneratedCommandsInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GeneratedCommandsInfoNV;
}
unsafe impl<'a> Send for GeneratedCommandsInfoNV<'a> {}
unsafe impl<'a> Sync for GeneratedCommandsInfoNV<'a> {}
impl<'a> Default for GeneratedCommandsInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline_bind_point: PipelineBindPoint::Graphics,
            pipeline: Default::default(),
            indirect_commands_layout: Default::default(),
            stream_count: Default::default(),
            p_streams: ptr::null(),
            sequences_count: Default::default(),
            preprocess_buffer: Default::default(),
            preprocess_offset: Default::default(),
            preprocess_size: Default::default(),
            sequences_count_buffer: Default::default(),
            sequences_count_offset: Default::default(),
            sequences_index_buffer: Default::default(),
            sequences_index_offset: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> GeneratedCommandsInfoNV<'a> {
    #[inline]
    pub fn pipeline_bind_point(mut self, value: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = value;
        self
    }
    #[inline]
    pub fn pipeline(mut self, value: Option<&'a Pipeline>) -> Self {
        self.pipeline = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn indirect_commands_layout(mut self, value: &'a IndirectCommandsLayoutNV) -> Self {
        self.indirect_commands_layout = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn sequences_count(mut self, value: u32) -> Self {
        self.sequences_count = value;
        self
    }
    #[inline]
    pub fn preprocess_buffer(mut self, value: &'a Buffer) -> Self {
        self.preprocess_buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn preprocess_offset(mut self, value: DeviceSize) -> Self {
        self.preprocess_offset = value;
        self
    }
    #[inline]
    pub fn preprocess_size(mut self, value: DeviceSize) -> Self {
        self.preprocess_size = value;
        self
    }
    #[inline]
    pub fn sequences_count_buffer(mut self, value: Option<&'a Buffer>) -> Self {
        self.sequences_count_buffer = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn sequences_count_offset(mut self, value: DeviceSize) -> Self {
        self.sequences_count_offset = value;
        self
    }
    #[inline]
    pub fn sequences_index_buffer(mut self, value: Option<&'a Buffer>) -> Self {
        self.sequences_index_buffer = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn sequences_index_offset(mut self, value: DeviceSize) -> Self {
        self.sequences_index_offset = value;
        self
    }
    #[inline]
    pub fn streams(mut self, p_streams: impl AsSlice<'a, IndirectCommandsStreamNV<'a>>) -> Self {
        self.p_streams = p_streams.as_slice().as_ptr().cast();
        self.stream_count = p_streams.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeneratedCommandsMemoryRequirementsInfoNV.html>"]
#[doc(alias = "VkGeneratedCommandsMemoryRequirementsInfoNV")]
pub struct GeneratedCommandsMemoryRequirementsInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline: Option<Pipeline>,
    pub indirect_commands_layout: Option<IndirectCommandsLayoutNV>,
    pub max_sequences_count: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for GeneratedCommandsMemoryRequirementsInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GeneratedCommandsMemoryRequirementsInfoNV;
}
unsafe impl<'a> Send for GeneratedCommandsMemoryRequirementsInfoNV<'a> {}
unsafe impl<'a> Sync for GeneratedCommandsMemoryRequirementsInfoNV<'a> {}
impl<'a> Default for GeneratedCommandsMemoryRequirementsInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline_bind_point: PipelineBindPoint::Graphics,
            pipeline: Default::default(),
            indirect_commands_layout: Default::default(),
            max_sequences_count: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> GeneratedCommandsMemoryRequirementsInfoNV<'a> {
    #[inline]
    pub fn pipeline_bind_point(mut self, value: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = value;
        self
    }
    #[inline]
    pub fn pipeline(mut self, value: Option<&'a Pipeline>) -> Self {
        self.pipeline = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn indirect_commands_layout(mut self, value: &'a IndirectCommandsLayoutNV) -> Self {
        self.indirect_commands_layout = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn max_sequences_count(mut self, value: u32) -> Self {
        self.max_sequences_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInheritedViewportScissorFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceInheritedViewportScissorFeaturesNV")]
pub struct PhysicalDeviceInheritedViewportScissorFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub inherited_viewport_scissor2_d: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceInheritedViewportScissorFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceInheritedViewportScissorFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceInheritedViewportScissorFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceInheritedViewportScissorFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceInheritedViewportScissorFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceInheritedViewportScissorFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceInheritedViewportScissorFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            inherited_viewport_scissor2_d: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceInheritedViewportScissorFeaturesNV<'a> {
    #[inline]
    pub fn inherited_viewport_scissor2_d(mut self, value: impl Into<Bool32>) -> Self {
        self.inherited_viewport_scissor2_d = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceViewportScissorInfoNV.html>"]
#[doc(alias = "VkCommandBufferInheritanceViewportScissorInfoNV")]
pub struct CommandBufferInheritanceViewportScissorInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub viewport_scissor2_d: Bool32,
    pub viewport_depth_count: u32,
    pub p_viewport_depths: *const Viewport,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CommandBufferInheritanceViewportScissorInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::CommandBufferInheritanceViewportScissorInfoNV;
}
unsafe impl<'a> Send for CommandBufferInheritanceViewportScissorInfoNV<'a> {}
unsafe impl<'a> Sync for CommandBufferInheritanceViewportScissorInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<CommandBufferInheritanceInfo<'b>>
    for CommandBufferInheritanceViewportScissorInfoNV<'a>
{
}
impl<'a> Default for CommandBufferInheritanceViewportScissorInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            viewport_scissor2_d: Default::default(),
            viewport_depth_count: Default::default(),
            p_viewport_depths: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CommandBufferInheritanceViewportScissorInfoNV<'a> {
    #[inline]
    pub fn viewport_scissor2_d(mut self, value: impl Into<Bool32>) -> Self {
        self.viewport_scissor2_d = value.into();
        self
    }
    #[inline]
    pub fn viewport_depth_count(mut self, value: u32) -> Self {
        self.viewport_depth_count = value;
        self
    }
    #[inline]
    pub fn viewport_depths(mut self, value: &'a Viewport) -> Self {
        self.p_viewport_depths = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT")]
pub struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub texel_buffer_alignment: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceTexelBufferAlignmentFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            texel_buffer_alignment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'a> {
    #[inline]
    pub fn texel_buffer_alignment(mut self, value: impl Into<Bool32>) -> Self {
        self.texel_buffer_alignment = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassTransformBeginInfoQCOM.html>"]
#[doc(alias = "VkRenderPassTransformBeginInfoQCOM")]
pub struct RenderPassTransformBeginInfoQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub transform: SurfaceTransformFlagsKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassTransformBeginInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassTransformBeginInfoQCOM;
}
unsafe impl<'a> Send for RenderPassTransformBeginInfoQCOM<'a> {}
unsafe impl<'a> Sync for RenderPassTransformBeginInfoQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderPassBeginInfo<'b>>
    for RenderPassTransformBeginInfoQCOM<'a>
{
}
impl<'a> Default for RenderPassTransformBeginInfoQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            transform: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassTransformBeginInfoQCOM<'a> {
    #[inline]
    pub fn transform(mut self, value: SurfaceTransformFlagsKHR) -> Self {
        self.transform = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceRenderPassTransformInfoQCOM.html>"]
#[doc(alias = "VkCommandBufferInheritanceRenderPassTransformInfoQCOM")]
pub struct CommandBufferInheritanceRenderPassTransformInfoQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub transform: SurfaceTransformFlagsKHR,
    pub render_area: Rect2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CommandBufferInheritanceRenderPassTransformInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::CommandBufferInheritanceRenderPassTransformInfoQCOM;
}
unsafe impl<'a> Send for CommandBufferInheritanceRenderPassTransformInfoQCOM<'a> {}
unsafe impl<'a> Sync for CommandBufferInheritanceRenderPassTransformInfoQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<CommandBufferInheritanceInfo<'b>>
    for CommandBufferInheritanceRenderPassTransformInfoQCOM<'a>
{
}
impl<'a> Default for CommandBufferInheritanceRenderPassTransformInfoQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            transform: Default::default(),
            render_area: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CommandBufferInheritanceRenderPassTransformInfoQCOM<'a> {
    #[inline]
    pub fn transform(mut self, value: SurfaceTransformFlagsKHR) -> Self {
        self.transform = value;
        self
    }
    #[inline]
    pub fn render_area(mut self, value: Rect2D) -> Self {
        self.render_area = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthBiasControlFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceDepthBiasControlFeaturesEXT")]
pub struct PhysicalDeviceDepthBiasControlFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub depth_bias_control: Bool32,
    pub least_representable_value_force_unorm_representation: Bool32,
    pub float_representation: Bool32,
    pub depth_bias_exact: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDepthBiasControlFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceDepthBiasControlFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceDepthBiasControlFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDepthBiasControlFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDepthBiasControlFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDepthBiasControlFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceDepthBiasControlFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            depth_bias_control: Default::default(),
            least_representable_value_force_unorm_representation: Default::default(),
            float_representation: Default::default(),
            depth_bias_exact: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDepthBiasControlFeaturesEXT<'a> {
    #[inline]
    pub fn depth_bias_control(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_bias_control = value.into();
        self
    }
    #[inline]
    pub fn least_representable_value_force_unorm_representation(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.least_representable_value_force_unorm_representation = value.into();
        self
    }
    #[inline]
    pub fn float_representation(mut self, value: impl Into<Bool32>) -> Self {
        self.float_representation = value.into();
        self
    }
    #[inline]
    pub fn depth_bias_exact(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_bias_exact = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDepthBiasInfoEXT.html>"]
#[doc(alias = "VkDepthBiasInfoEXT")]
pub struct DepthBiasInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub depth_bias_constant_factor: f32,
    pub depth_bias_clamp: f32,
    pub depth_bias_slope_factor: f32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DepthBiasInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DepthBiasInfoEXT;
}
unsafe impl<'a> Send for DepthBiasInfoEXT<'a> {}
unsafe impl<'a> Sync for DepthBiasInfoEXT<'a> {}
impl<'a> Default for DepthBiasInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            depth_bias_constant_factor: Default::default(),
            depth_bias_clamp: Default::default(),
            depth_bias_slope_factor: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DepthBiasInfoEXT<'a> {
    #[inline]
    pub fn depth_bias_constant_factor(mut self, value: f32) -> Self {
        self.depth_bias_constant_factor = value;
        self
    }
    #[inline]
    pub fn depth_bias_clamp(mut self, value: f32) -> Self {
        self.depth_bias_clamp = value;
        self
    }
    #[inline]
    pub fn depth_bias_slope_factor(mut self, value: f32) -> Self {
        self.depth_bias_slope_factor = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDepthBiasRepresentationInfoEXT.html>"]
#[doc(alias = "VkDepthBiasRepresentationInfoEXT")]
pub struct DepthBiasRepresentationInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub depth_bias_representation: DepthBiasRepresentationEXT,
    pub depth_bias_exact: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DepthBiasRepresentationInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DepthBiasRepresentationInfoEXT;
}
unsafe impl<'a> Send for DepthBiasRepresentationInfoEXT<'a> {}
unsafe impl<'a> Sync for DepthBiasRepresentationInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DepthBiasInfoEXT<'b>>
    for DepthBiasRepresentationInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<PipelineRasterizationStateCreateInfo<'b>>
    for DepthBiasRepresentationInfoEXT<'a>
{
}
impl<'a> Default for DepthBiasRepresentationInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            depth_bias_representation: DepthBiasRepresentationEXT::LeastRepresentableValueFormat,
            depth_bias_exact: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DepthBiasRepresentationInfoEXT<'a> {
    #[inline]
    pub fn depth_bias_representation(mut self, value: DepthBiasRepresentationEXT) -> Self {
        self.depth_bias_representation = value;
        self
    }
    #[inline]
    pub fn depth_bias_exact(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_bias_exact = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceDeviceMemoryReportFeaturesEXT")]
pub struct PhysicalDeviceDeviceMemoryReportFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_memory_report: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDeviceMemoryReportFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDeviceMemoryReportFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceDeviceMemoryReportFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDeviceMemoryReportFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDeviceMemoryReportFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDeviceMemoryReportFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceDeviceMemoryReportFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_memory_report: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDeviceMemoryReportFeaturesEXT<'a> {
    #[inline]
    pub fn device_memory_report(mut self, value: impl Into<Bool32>) -> Self {
        self.device_memory_report = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceDeviceMemoryReportCreateInfoEXT.html>"]
#[doc(alias = "VkDeviceDeviceMemoryReportCreateInfoEXT")]
pub struct DeviceDeviceMemoryReportCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub pfn_user_callback: FuncPtr,
    pub p_user_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceDeviceMemoryReportCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceDeviceMemoryReportCreateInfoEXT;
}
unsafe impl<'a> Send for DeviceDeviceMemoryReportCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for DeviceDeviceMemoryReportCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for DeviceDeviceMemoryReportCreateInfoEXT<'a>
{
}
impl<'a> Default for DeviceDeviceMemoryReportCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            pfn_user_callback: ptr::null(),
            p_user_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceDeviceMemoryReportCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn pfn_user_callback(mut self, value: FuncPtr) -> Self {
        self.pfn_user_callback = value;
        self
    }
    #[inline]
    pub fn user_data(mut self, value: VoidPtr) -> Self {
        self.p_user_data = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryReportCallbackDataEXT.html>"]
#[doc(alias = "VkDeviceMemoryReportCallbackDataEXT")]
pub struct DeviceMemoryReportCallbackDataEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub ty: DeviceMemoryReportEventTypeEXT,
    pub memory_object_id: u64,
    pub size: DeviceSize,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub heap_index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceMemoryReportCallbackDataEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceMemoryReportCallbackDataEXT;
}
unsafe impl<'a> Send for DeviceMemoryReportCallbackDataEXT<'a> {}
unsafe impl<'a> Sync for DeviceMemoryReportCallbackDataEXT<'a> {}
impl<'a> Default for DeviceMemoryReportCallbackDataEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            ty: DeviceMemoryReportEventTypeEXT::Allocate,
            memory_object_id: Default::default(),
            size: Default::default(),
            object_type: ObjectType::Unknown,
            object_handle: Default::default(),
            heap_index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceMemoryReportCallbackDataEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn ty(mut self, value: DeviceMemoryReportEventTypeEXT) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn memory_object_id(mut self, value: u64) -> Self {
        self.memory_object_id = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn object_type(mut self, value: ObjectType) -> Self {
        self.object_type = value;
        self
    }
    #[inline]
    pub fn object_handle(mut self, value: u64) -> Self {
        self.object_handle = value;
        self
    }
    #[inline]
    pub fn heap_index(mut self, value: u32) -> Self {
        self.heap_index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRobustness2FeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceRobustness2FeaturesEXT")]
pub struct PhysicalDeviceRobustness2FeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub robust_buffer_access2: Bool32,
    pub robust_image_access2: Bool32,
    pub null_descriptor: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRobustness2FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceRobustness2FeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceRobustness2FeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRobustness2FeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRobustness2FeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRobustness2FeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceRobustness2FeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            robust_buffer_access2: Default::default(),
            robust_image_access2: Default::default(),
            null_descriptor: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRobustness2FeaturesEXT<'a> {
    #[inline]
    pub fn robust_buffer_access2(mut self, value: impl Into<Bool32>) -> Self {
        self.robust_buffer_access2 = value.into();
        self
    }
    #[inline]
    pub fn robust_image_access2(mut self, value: impl Into<Bool32>) -> Self {
        self.robust_image_access2 = value.into();
        self
    }
    #[inline]
    pub fn null_descriptor(mut self, value: impl Into<Bool32>) -> Self {
        self.null_descriptor = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRobustness2PropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceRobustness2PropertiesEXT")]
pub struct PhysicalDeviceRobustness2PropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub robust_storage_buffer_access_size_alignment: DeviceSize,
    pub robust_uniform_buffer_access_size_alignment: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRobustness2PropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceRobustness2PropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceRobustness2PropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRobustness2PropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceRobustness2PropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceRobustness2PropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            robust_storage_buffer_access_size_alignment: Default::default(),
            robust_uniform_buffer_access_size_alignment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRobustness2PropertiesEXT<'a> {
    #[inline]
    pub fn robust_storage_buffer_access_size_alignment(mut self, value: DeviceSize) -> Self {
        self.robust_storage_buffer_access_size_alignment = value;
        self
    }
    #[inline]
    pub fn robust_uniform_buffer_access_size_alignment(mut self, value: DeviceSize) -> Self {
        self.robust_uniform_buffer_access_size_alignment = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCustomBorderColorCreateInfoEXT.html>"]
#[doc(alias = "VkSamplerCustomBorderColorCreateInfoEXT")]
pub struct SamplerCustomBorderColorCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub custom_border_color: ClearColorValue,
    pub format: Format,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SamplerCustomBorderColorCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SamplerCustomBorderColorCreateInfoEXT;
}
unsafe impl<'a> Send for SamplerCustomBorderColorCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for SamplerCustomBorderColorCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SamplerCreateInfo<'b>>
    for SamplerCustomBorderColorCreateInfoEXT<'a>
{
}
impl<'a> Default for SamplerCustomBorderColorCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            custom_border_color: Default::default(),
            format: Format::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> SamplerCustomBorderColorCreateInfoEXT<'a> {
    #[inline]
    pub fn custom_border_color(mut self, value: ClearColorValue) -> Self {
        self.custom_border_color = value;
        self
    }
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCustomBorderColorPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceCustomBorderColorPropertiesEXT")]
pub struct PhysicalDeviceCustomBorderColorPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_custom_border_color_samplers: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCustomBorderColorPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceCustomBorderColorPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceCustomBorderColorPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCustomBorderColorPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceCustomBorderColorPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceCustomBorderColorPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_custom_border_color_samplers: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCustomBorderColorPropertiesEXT<'a> {
    #[inline]
    pub fn max_custom_border_color_samplers(mut self, value: u32) -> Self {
        self.max_custom_border_color_samplers = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCustomBorderColorFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceCustomBorderColorFeaturesEXT")]
pub struct PhysicalDeviceCustomBorderColorFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub custom_border_colors: Bool32,
    pub custom_border_color_without_format: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCustomBorderColorFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceCustomBorderColorFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceCustomBorderColorFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCustomBorderColorFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceCustomBorderColorFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceCustomBorderColorFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceCustomBorderColorFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            custom_border_colors: Default::default(),
            custom_border_color_without_format: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCustomBorderColorFeaturesEXT<'a> {
    #[inline]
    pub fn custom_border_colors(mut self, value: impl Into<Bool32>) -> Self {
        self.custom_border_colors = value.into();
        self
    }
    #[inline]
    pub fn custom_border_color_without_format(mut self, value: impl Into<Bool32>) -> Self {
        self.custom_border_color_without_format = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLibraryCreateInfoKHR.html>"]
#[doc(alias = "VkPipelineLibraryCreateInfoKHR")]
pub struct PipelineLibraryCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) library_count: u32,
    pub(crate) p_libraries: *const Pipeline,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineLibraryCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineLibraryCreateInfoKHR;
}
unsafe impl<'a> Send for PipelineLibraryCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for PipelineLibraryCreateInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for PipelineLibraryCreateInfoKHR<'a>
{
}
impl<'a> Default for PipelineLibraryCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            library_count: Default::default(),
            p_libraries: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineLibraryCreateInfoKHR<'a> {
    #[inline]
    pub fn libraries<V0: Alias<raw::Pipeline> + 'a>(
        mut self,
        p_libraries: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_libraries = p_libraries.as_slice().as_ptr().cast();
        self.library_count = p_libraries.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentBarrierFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDevicePresentBarrierFeaturesNV")]
pub struct PhysicalDevicePresentBarrierFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub present_barrier: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePresentBarrierFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDevicePresentBarrierFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDevicePresentBarrierFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePresentBarrierFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePresentBarrierFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePresentBarrierFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDevicePresentBarrierFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_barrier: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePresentBarrierFeaturesNV<'a> {
    #[inline]
    pub fn present_barrier(mut self, value: impl Into<Bool32>) -> Self {
        self.present_barrier = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesPresentBarrierNV.html>"]
#[doc(alias = "VkSurfaceCapabilitiesPresentBarrierNV")]
pub struct SurfaceCapabilitiesPresentBarrierNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub present_barrier_supported: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SurfaceCapabilitiesPresentBarrierNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SurfaceCapabilitiesPresentBarrierNV;
}
unsafe impl<'a> Send for SurfaceCapabilitiesPresentBarrierNV<'a> {}
unsafe impl<'a> Sync for SurfaceCapabilitiesPresentBarrierNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SurfaceCapabilities2KHR<'b>>
    for SurfaceCapabilitiesPresentBarrierNV<'a>
{
}
impl<'a> Default for SurfaceCapabilitiesPresentBarrierNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_barrier_supported: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SurfaceCapabilitiesPresentBarrierNV<'a> {
    #[inline]
    pub fn present_barrier_supported(mut self, value: impl Into<Bool32>) -> Self {
        self.present_barrier_supported = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainPresentBarrierCreateInfoNV.html>"]
#[doc(alias = "VkSwapchainPresentBarrierCreateInfoNV")]
pub struct SwapchainPresentBarrierCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub present_barrier_enable: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SwapchainPresentBarrierCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SwapchainPresentBarrierCreateInfoNV;
}
unsafe impl<'a> Send for SwapchainPresentBarrierCreateInfoNV<'a> {}
unsafe impl<'a> Sync for SwapchainPresentBarrierCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SwapchainCreateInfoKHR<'b>>
    for SwapchainPresentBarrierCreateInfoNV<'a>
{
}
impl<'a> Default for SwapchainPresentBarrierCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_barrier_enable: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SwapchainPresentBarrierCreateInfoNV<'a> {
    #[inline]
    pub fn present_barrier_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.present_barrier_enable = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentIdKHR.html>"]
#[doc(alias = "VkPresentIdKHR")]
pub struct PresentIdKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub swapchain_count: u32,
    pub(crate) p_present_ids: *const u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PresentIdKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PresentIdKHR;
}
unsafe impl<'a> Send for PresentIdKHR<'a> {}
unsafe impl<'a> Sync for PresentIdKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PresentInfoKHR<'b>> for PresentIdKHR<'a> {}
impl<'a> Default for PresentIdKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            swapchain_count: Default::default(),
            p_present_ids: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PresentIdKHR<'a> {
    #[inline]
    pub fn swapchain_count(mut self, value: u32) -> Self {
        self.swapchain_count = value;
        self
    }
    #[inline]
    pub fn present_ids(mut self, p_present_ids: impl AsSlice<'a, u64>) -> Self {
        self.p_present_ids = p_present_ids.as_slice().as_ptr().cast();
        self.swapchain_count = p_present_ids.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentIdFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDevicePresentIdFeaturesKHR")]
pub struct PhysicalDevicePresentIdFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub present_id: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePresentIdFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDevicePresentIdFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDevicePresentIdFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePresentIdFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePresentIdFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePresentIdFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDevicePresentIdFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_id: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePresentIdFeaturesKHR<'a> {
    #[inline]
    pub fn present_id(mut self, value: impl Into<Bool32>) -> Self {
        self.present_id = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDiagnosticsConfigFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceDiagnosticsConfigFeaturesNV")]
pub struct PhysicalDeviceDiagnosticsConfigFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub diagnostics_config: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDiagnosticsConfigFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceDiagnosticsConfigFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceDiagnosticsConfigFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDiagnosticsConfigFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDiagnosticsConfigFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDiagnosticsConfigFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceDiagnosticsConfigFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            diagnostics_config: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDiagnosticsConfigFeaturesNV<'a> {
    #[inline]
    pub fn diagnostics_config(mut self, value: impl Into<Bool32>) -> Self {
        self.diagnostics_config = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceDiagnosticsConfigCreateInfoNV.html>"]
#[doc(alias = "VkDeviceDiagnosticsConfigCreateInfoNV")]
pub struct DeviceDiagnosticsConfigCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: DeviceDiagnosticsConfigFlagsNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceDiagnosticsConfigCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceDiagnosticsConfigCreateInfoNV;
}
unsafe impl<'a> Send for DeviceDiagnosticsConfigCreateInfoNV<'a> {}
unsafe impl<'a> Sync for DeviceDiagnosticsConfigCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for DeviceDiagnosticsConfigCreateInfoNV<'a>
{
}
impl<'a> Default for DeviceDiagnosticsConfigCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceDiagnosticsConfigCreateInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, value: DeviceDiagnosticsConfigFlagsNV) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCudaModuleCreateInfoNV.html>"]
#[doc(alias = "VkCudaModuleCreateInfoNV")]
pub struct CudaModuleCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) data_size: usize,
    pub(crate) p_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CudaModuleCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CudaModuleCreateInfoNV;
}
unsafe impl<'a> Send for CudaModuleCreateInfoNV<'a> {}
unsafe impl<'a> Sync for CudaModuleCreateInfoNV<'a> {}
impl<'a> Default for CudaModuleCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            data_size: Default::default(),
            p_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CudaModuleCreateInfoNV<'a> {
    #[inline]
    pub fn data(mut self, p_data: impl AsSlice<'a, u8>) -> Self {
        self.p_data = p_data.as_slice().as_ptr().cast();
        self.data_size = p_data.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCudaFunctionCreateInfoNV.html>"]
#[doc(alias = "VkCudaFunctionCreateInfoNV")]
pub struct CudaFunctionCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub module: Option<CudaModuleNV>,
    pub p_name: *const c_char,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CudaFunctionCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CudaFunctionCreateInfoNV;
}
unsafe impl<'a> Send for CudaFunctionCreateInfoNV<'a> {}
unsafe impl<'a> Sync for CudaFunctionCreateInfoNV<'a> {}
impl<'a> Default for CudaFunctionCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            module: Default::default(),
            p_name: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CudaFunctionCreateInfoNV<'a> {
    #[inline]
    pub fn module(mut self, value: &'a CudaModuleNV) -> Self {
        self.module = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn name(mut self, value: &'a CStr) -> Self {
        self.p_name = value.as_ptr();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCudaLaunchInfoNV.html>"]
#[doc(alias = "VkCudaLaunchInfoNV")]
pub struct CudaLaunchInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub function: Option<CudaFunctionNV>,
    pub grid_dim_x: u32,
    pub grid_dim_y: u32,
    pub grid_dim_z: u32,
    pub block_dim_x: u32,
    pub block_dim_y: u32,
    pub block_dim_z: u32,
    pub shared_mem_bytes: u32,
    pub(crate) param_count: usize,
    pub(crate) p_params: *const *const c_void,
    pub(crate) extra_count: usize,
    pub(crate) p_extras: *const *const c_void,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CudaLaunchInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CudaLaunchInfoNV;
}
unsafe impl<'a> Send for CudaLaunchInfoNV<'a> {}
unsafe impl<'a> Sync for CudaLaunchInfoNV<'a> {}
impl<'a> Default for CudaLaunchInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            function: Default::default(),
            grid_dim_x: Default::default(),
            grid_dim_y: Default::default(),
            grid_dim_z: Default::default(),
            block_dim_x: Default::default(),
            block_dim_y: Default::default(),
            block_dim_z: Default::default(),
            shared_mem_bytes: Default::default(),
            param_count: Default::default(),
            p_params: ptr::null(),
            extra_count: Default::default(),
            p_extras: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CudaLaunchInfoNV<'a> {
    #[inline]
    pub fn function(mut self, value: &'a CudaFunctionNV) -> Self {
        self.function = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn grid_dim_x(mut self, value: u32) -> Self {
        self.grid_dim_x = value;
        self
    }
    #[inline]
    pub fn grid_dim_y(mut self, value: u32) -> Self {
        self.grid_dim_y = value;
        self
    }
    #[inline]
    pub fn grid_dim_z(mut self, value: u32) -> Self {
        self.grid_dim_z = value;
        self
    }
    #[inline]
    pub fn block_dim_x(mut self, value: u32) -> Self {
        self.block_dim_x = value;
        self
    }
    #[inline]
    pub fn block_dim_y(mut self, value: u32) -> Self {
        self.block_dim_y = value;
        self
    }
    #[inline]
    pub fn block_dim_z(mut self, value: u32) -> Self {
        self.block_dim_z = value;
        self
    }
    #[inline]
    pub fn shared_mem_bytes(mut self, value: u32) -> Self {
        self.shared_mem_bytes = value;
        self
    }
    #[inline]
    pub fn params(mut self, p_params: impl AsSlice<'a, &'a ()>) -> Self {
        self.p_params = p_params.as_slice().as_ptr().cast();
        self.param_count = p_params.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn extras(mut self, p_extras: impl AsSlice<'a, &'a ()>) -> Self {
        self.p_extras = p_extras.as_slice().as_ptr().cast();
        self.extra_count = p_extras.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCudaKernelLaunchFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceCudaKernelLaunchFeaturesNV")]
pub struct PhysicalDeviceCudaKernelLaunchFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub cuda_kernel_launch_features: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCudaKernelLaunchFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceCudaKernelLaunchFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceCudaKernelLaunchFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCudaKernelLaunchFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceCudaKernelLaunchFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceCudaKernelLaunchFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceCudaKernelLaunchFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            cuda_kernel_launch_features: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCudaKernelLaunchFeaturesNV<'a> {
    #[inline]
    pub fn cuda_kernel_launch_features(mut self, value: impl Into<Bool32>) -> Self {
        self.cuda_kernel_launch_features = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCudaKernelLaunchPropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceCudaKernelLaunchPropertiesNV")]
pub struct PhysicalDeviceCudaKernelLaunchPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub compute_capability_minor: u32,
    pub compute_capability_major: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCudaKernelLaunchPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceCudaKernelLaunchPropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceCudaKernelLaunchPropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCudaKernelLaunchPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceCudaKernelLaunchPropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceCudaKernelLaunchPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            compute_capability_minor: Default::default(),
            compute_capability_major: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCudaKernelLaunchPropertiesNV<'a> {
    #[inline]
    pub fn compute_capability_minor(mut self, value: u32) -> Self {
        self.compute_capability_minor = value;
        self
    }
    #[inline]
    pub fn compute_capability_major(mut self, value: u32) -> Self {
        self.compute_capability_major = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryLowLatencySupportNV.html>"]
#[doc(alias = "VkQueryLowLatencySupportNV")]
pub struct QueryLowLatencySupportNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_queried_low_latency_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for QueryLowLatencySupportNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QueryLowLatencySupportNV;
}
unsafe impl<'a> Send for QueryLowLatencySupportNV<'a> {}
unsafe impl<'a> Sync for QueryLowLatencySupportNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SemaphoreCreateInfo<'b>> for QueryLowLatencySupportNV<'a> {}
impl<'a> Default for QueryLowLatencySupportNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_queried_low_latency_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> QueryLowLatencySupportNV<'a> {
    #[inline]
    pub fn queried_low_latency_data(mut self, value: VoidPtr) -> Self {
        self.p_queried_low_latency_data = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalObjectCreateInfoEXT.html>"]
#[doc(alias = "VkExportMetalObjectCreateInfoEXT")]
pub struct ExportMetalObjectCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub export_object_type: ExportMetalObjectTypeFlagsEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportMetalObjectCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportMetalObjectCreateInfoEXT;
}
unsafe impl<'a> Send for ExportMetalObjectCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for ExportMetalObjectCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<InstanceCreateInfo<'b>>
    for ExportMetalObjectCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>>
    for ExportMetalObjectCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>> for ExportMetalObjectCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageViewCreateInfo<'b>>
    for ExportMetalObjectCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<BufferViewCreateInfo<'b>>
    for ExportMetalObjectCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<SemaphoreCreateInfo<'b>>
    for ExportMetalObjectCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<EventCreateInfo<'b>> for ExportMetalObjectCreateInfoEXT<'a> {}
impl<'a> Default for ExportMetalObjectCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            export_object_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportMetalObjectCreateInfoEXT<'a> {
    #[inline]
    pub fn export_object_type(mut self, value: ExportMetalObjectTypeFlagsEXT) -> Self {
        self.export_object_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalObjectsInfoEXT.html>"]
#[doc(alias = "VkExportMetalObjectsInfoEXT")]
pub struct ExportMetalObjectsInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportMetalObjectsInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportMetalObjectsInfoEXT;
}
unsafe impl<'a> Send for ExportMetalObjectsInfoEXT<'a> {}
unsafe impl<'a> Sync for ExportMetalObjectsInfoEXT<'a> {}
impl<'a> Default for ExportMetalObjectsInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportMetalObjectsInfoEXT<'a> {
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalDeviceInfoEXT.html>"]
#[doc(alias = "VkExportMetalDeviceInfoEXT")]
pub struct ExportMetalDeviceInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub mtl_device: MTLDeviceId,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportMetalDeviceInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportMetalDeviceInfoEXT;
}
unsafe impl<'a> Send for ExportMetalDeviceInfoEXT<'a> {}
unsafe impl<'a> Sync for ExportMetalDeviceInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ExportMetalObjectsInfoEXT<'b>>
    for ExportMetalDeviceInfoEXT<'a>
{
}
impl<'a> Default for ExportMetalDeviceInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            mtl_device: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportMetalDeviceInfoEXT<'a> {
    #[inline]
    pub fn mtl_device(mut self, value: MTLDeviceId) -> Self {
        self.mtl_device = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalCommandQueueInfoEXT.html>"]
#[doc(alias = "VkExportMetalCommandQueueInfoEXT")]
pub struct ExportMetalCommandQueueInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub queue: Option<Queue>,
    pub mtl_command_queue: MTLCommandQueueId,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportMetalCommandQueueInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportMetalCommandQueueInfoEXT;
}
unsafe impl<'a> Send for ExportMetalCommandQueueInfoEXT<'a> {}
unsafe impl<'a> Sync for ExportMetalCommandQueueInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ExportMetalObjectsInfoEXT<'b>>
    for ExportMetalCommandQueueInfoEXT<'a>
{
}
impl<'a> Default for ExportMetalCommandQueueInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            queue: Default::default(),
            mtl_command_queue: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportMetalCommandQueueInfoEXT<'a> {
    #[inline]
    pub fn queue(mut self, value: &'a Queue) -> Self {
        self.queue = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn mtl_command_queue(mut self, value: MTLCommandQueueId) -> Self {
        self.mtl_command_queue = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalBufferInfoEXT.html>"]
#[doc(alias = "VkExportMetalBufferInfoEXT")]
pub struct ExportMetalBufferInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory: Option<DeviceMemory>,
    pub mtl_buffer: MTLBufferId,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportMetalBufferInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportMetalBufferInfoEXT;
}
unsafe impl<'a> Send for ExportMetalBufferInfoEXT<'a> {}
unsafe impl<'a> Sync for ExportMetalBufferInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ExportMetalObjectsInfoEXT<'b>>
    for ExportMetalBufferInfoEXT<'a>
{
}
impl<'a> Default for ExportMetalBufferInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory: Default::default(),
            mtl_buffer: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportMetalBufferInfoEXT<'a> {
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn mtl_buffer(mut self, value: MTLBufferId) -> Self {
        self.mtl_buffer = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMetalBufferInfoEXT.html>"]
#[doc(alias = "VkImportMetalBufferInfoEXT")]
pub struct ImportMetalBufferInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub mtl_buffer: MTLBufferId,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportMetalBufferInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportMetalBufferInfoEXT;
}
unsafe impl<'a> Send for ImportMetalBufferInfoEXT<'a> {}
unsafe impl<'a> Sync for ImportMetalBufferInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>> for ImportMetalBufferInfoEXT<'a> {}
impl<'a> Default for ImportMetalBufferInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            mtl_buffer: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportMetalBufferInfoEXT<'a> {
    #[inline]
    pub fn mtl_buffer(mut self, value: MTLBufferId) -> Self {
        self.mtl_buffer = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalTextureInfoEXT.html>"]
#[doc(alias = "VkExportMetalTextureInfoEXT")]
pub struct ExportMetalTextureInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image: Option<Image>,
    pub image_view: Option<ImageView>,
    pub buffer_view: Option<BufferView>,
    pub plane: ImageAspectFlags,
    pub mtl_texture: MTLTextureId,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportMetalTextureInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportMetalTextureInfoEXT;
}
unsafe impl<'a> Send for ExportMetalTextureInfoEXT<'a> {}
unsafe impl<'a> Sync for ExportMetalTextureInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ExportMetalObjectsInfoEXT<'b>>
    for ExportMetalTextureInfoEXT<'a>
{
}
impl<'a> Default for ExportMetalTextureInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image: Default::default(),
            image_view: Default::default(),
            buffer_view: Default::default(),
            plane: Default::default(),
            mtl_texture: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportMetalTextureInfoEXT<'a> {
    #[inline]
    pub fn image(mut self, value: Option<&'a Image>) -> Self {
        self.image = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn image_view(mut self, value: Option<&'a ImageView>) -> Self {
        self.image_view = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn buffer_view(mut self, value: Option<&'a BufferView>) -> Self {
        self.buffer_view = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn plane(mut self, value: ImageAspectFlags) -> Self {
        self.plane = value;
        self
    }
    #[inline]
    pub fn mtl_texture(mut self, value: MTLTextureId) -> Self {
        self.mtl_texture = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMetalTextureInfoEXT.html>"]
#[doc(alias = "VkImportMetalTextureInfoEXT")]
pub struct ImportMetalTextureInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub plane: ImageAspectFlags,
    pub mtl_texture: MTLTextureId,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportMetalTextureInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportMetalTextureInfoEXT;
}
unsafe impl<'a> Send for ImportMetalTextureInfoEXT<'a> {}
unsafe impl<'a> Sync for ImportMetalTextureInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>> for ImportMetalTextureInfoEXT<'a> {}
impl<'a> Default for ImportMetalTextureInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            plane: Default::default(),
            mtl_texture: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportMetalTextureInfoEXT<'a> {
    #[inline]
    pub fn plane(mut self, value: ImageAspectFlags) -> Self {
        self.plane = value;
        self
    }
    #[inline]
    pub fn mtl_texture(mut self, value: MTLTextureId) -> Self {
        self.mtl_texture = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalIOSurfaceInfoEXT.html>"]
#[doc(alias = "VkExportMetalIOSurfaceInfoEXT")]
pub struct ExportMetalIOSurfaceInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image: Option<Image>,
    pub io_surface: IOSurfaceRef,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportMetalIOSurfaceInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportMetalIoSurfaceInfoEXT;
}
unsafe impl<'a> Send for ExportMetalIOSurfaceInfoEXT<'a> {}
unsafe impl<'a> Sync for ExportMetalIOSurfaceInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ExportMetalObjectsInfoEXT<'b>>
    for ExportMetalIOSurfaceInfoEXT<'a>
{
}
impl<'a> Default for ExportMetalIOSurfaceInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image: Default::default(),
            io_surface: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportMetalIOSurfaceInfoEXT<'a> {
    #[inline]
    pub fn image(mut self, value: &'a Image) -> Self {
        self.image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn io_surface(mut self, value: IOSurfaceRef) -> Self {
        self.io_surface = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMetalIOSurfaceInfoEXT.html>"]
#[doc(alias = "VkImportMetalIOSurfaceInfoEXT")]
pub struct ImportMetalIOSurfaceInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub io_surface: IOSurfaceRef,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportMetalIOSurfaceInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportMetalIoSurfaceInfoEXT;
}
unsafe impl<'a> Send for ImportMetalIOSurfaceInfoEXT<'a> {}
unsafe impl<'a> Sync for ImportMetalIOSurfaceInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>> for ImportMetalIOSurfaceInfoEXT<'a> {}
impl<'a> Default for ImportMetalIOSurfaceInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            io_surface: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportMetalIOSurfaceInfoEXT<'a> {
    #[inline]
    pub fn io_surface(mut self, value: IOSurfaceRef) -> Self {
        self.io_surface = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalSharedEventInfoEXT.html>"]
#[doc(alias = "VkExportMetalSharedEventInfoEXT")]
pub struct ExportMetalSharedEventInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub semaphore: Option<Semaphore>,
    pub event: Option<Event>,
    pub mtl_shared_event: MTLSharedEventId,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExportMetalSharedEventInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExportMetalSharedEventInfoEXT;
}
unsafe impl<'a> Send for ExportMetalSharedEventInfoEXT<'a> {}
unsafe impl<'a> Sync for ExportMetalSharedEventInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ExportMetalObjectsInfoEXT<'b>>
    for ExportMetalSharedEventInfoEXT<'a>
{
}
impl<'a> Default for ExportMetalSharedEventInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            semaphore: Default::default(),
            event: Default::default(),
            mtl_shared_event: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExportMetalSharedEventInfoEXT<'a> {
    #[inline]
    pub fn semaphore(mut self, value: Option<&'a Semaphore>) -> Self {
        self.semaphore = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn event(mut self, value: Option<&'a Event>) -> Self {
        self.event = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn mtl_shared_event(mut self, value: MTLSharedEventId) -> Self {
        self.mtl_shared_event = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMetalSharedEventInfoEXT.html>"]
#[doc(alias = "VkImportMetalSharedEventInfoEXT")]
pub struct ImportMetalSharedEventInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub mtl_shared_event: MTLSharedEventId,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportMetalSharedEventInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportMetalSharedEventInfoEXT;
}
unsafe impl<'a> Send for ImportMetalSharedEventInfoEXT<'a> {}
unsafe impl<'a> Sync for ImportMetalSharedEventInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SemaphoreCreateInfo<'b>>
    for ImportMetalSharedEventInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<EventCreateInfo<'b>> for ImportMetalSharedEventInfoEXT<'a> {}
impl<'a> Default for ImportMetalSharedEventInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            mtl_shared_event: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportMetalSharedEventInfoEXT<'a> {
    #[inline]
    pub fn mtl_shared_event(mut self, value: MTLSharedEventId) -> Self {
        self.mtl_shared_event = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/MTLDevice_id.html>"]
pub type MTLDeviceId = VoidPtr;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/MTLCommandQueue_id.html>"]
pub type MTLCommandQueueId = VoidPtr;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/MTLBuffer_id.html>"]
pub type MTLBufferId = VoidPtr;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/MTLTexture_id.html>"]
pub type MTLTextureId = VoidPtr;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/MTLSharedEvent_id.html>"]
pub type MTLSharedEventId = VoidPtr;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/IOSurfaceRef.html>"]
pub type IOSurfaceRef = VoidPtr;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyCheckpointProperties2NV.html>"]
#[doc(alias = "VkQueueFamilyCheckpointProperties2NV")]
pub struct QueueFamilyCheckpointProperties2NV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub checkpoint_execution_stage_mask: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for QueueFamilyCheckpointProperties2NV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::QueueFamilyCheckpointProperties2NV;
}
unsafe impl<'a> Send for QueueFamilyCheckpointProperties2NV<'a> {}
unsafe impl<'a> Sync for QueueFamilyCheckpointProperties2NV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<QueueFamilyProperties2<'b>>
    for QueueFamilyCheckpointProperties2NV<'a>
{
}
impl<'a> Default for QueueFamilyCheckpointProperties2NV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            checkpoint_execution_stage_mask: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> QueueFamilyCheckpointProperties2NV<'a> {
    #[inline]
    pub fn checkpoint_execution_stage_mask(mut self, value: u32) -> Self {
        self.checkpoint_execution_stage_mask = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCheckpointData2NV.html>"]
#[doc(alias = "VkCheckpointData2NV")]
pub struct CheckpointData2NV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub stage: u32,
    pub p_checkpoint_marker: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CheckpointData2NV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CheckpointData2NV;
}
unsafe impl<'a> Send for CheckpointData2NV<'a> {}
unsafe impl<'a> Sync for CheckpointData2NV<'a> {}
impl<'a> Default for CheckpointData2NV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stage: Default::default(),
            p_checkpoint_marker: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CheckpointData2NV<'a> {
    #[inline]
    pub fn stage(mut self, value: u32) -> Self {
        self.stage = value;
        self
    }
    #[inline]
    pub fn checkpoint_marker(mut self, value: VoidPtr) -> Self {
        self.p_checkpoint_marker = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorBufferPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceDescriptorBufferPropertiesEXT")]
pub struct PhysicalDeviceDescriptorBufferPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub combined_image_sampler_descriptor_single_array: Bool32,
    pub bufferless_push_descriptors: Bool32,
    pub allow_sampler_image_view_post_submit_creation: Bool32,
    pub descriptor_buffer_offset_alignment: DeviceSize,
    pub max_descriptor_buffer_bindings: u32,
    pub max_resource_descriptor_buffer_bindings: u32,
    pub max_sampler_descriptor_buffer_bindings: u32,
    pub max_embedded_immutable_sampler_bindings: u32,
    pub max_embedded_immutable_samplers: u32,
    pub buffer_capture_replay_descriptor_data_size: usize,
    pub image_capture_replay_descriptor_data_size: usize,
    pub image_view_capture_replay_descriptor_data_size: usize,
    pub sampler_capture_replay_descriptor_data_size: usize,
    pub acceleration_structure_capture_replay_descriptor_data_size: usize,
    pub sampler_descriptor_size: usize,
    pub combined_image_sampler_descriptor_size: usize,
    pub sampled_image_descriptor_size: usize,
    pub storage_image_descriptor_size: usize,
    pub uniform_texel_buffer_descriptor_size: usize,
    pub robust_uniform_texel_buffer_descriptor_size: usize,
    pub storage_texel_buffer_descriptor_size: usize,
    pub robust_storage_texel_buffer_descriptor_size: usize,
    pub uniform_buffer_descriptor_size: usize,
    pub robust_uniform_buffer_descriptor_size: usize,
    pub storage_buffer_descriptor_size: usize,
    pub robust_storage_buffer_descriptor_size: usize,
    pub input_attachment_descriptor_size: usize,
    pub acceleration_structure_descriptor_size: usize,
    pub max_sampler_descriptor_buffer_range: DeviceSize,
    pub max_resource_descriptor_buffer_range: DeviceSize,
    pub sampler_descriptor_buffer_address_space_size: DeviceSize,
    pub resource_descriptor_buffer_address_space_size: DeviceSize,
    pub descriptor_buffer_address_space_size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDescriptorBufferPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDescriptorBufferPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceDescriptorBufferPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDescriptorBufferPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceDescriptorBufferPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceDescriptorBufferPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            combined_image_sampler_descriptor_single_array: Default::default(),
            bufferless_push_descriptors: Default::default(),
            allow_sampler_image_view_post_submit_creation: Default::default(),
            descriptor_buffer_offset_alignment: Default::default(),
            max_descriptor_buffer_bindings: Default::default(),
            max_resource_descriptor_buffer_bindings: Default::default(),
            max_sampler_descriptor_buffer_bindings: Default::default(),
            max_embedded_immutable_sampler_bindings: Default::default(),
            max_embedded_immutable_samplers: Default::default(),
            buffer_capture_replay_descriptor_data_size: Default::default(),
            image_capture_replay_descriptor_data_size: Default::default(),
            image_view_capture_replay_descriptor_data_size: Default::default(),
            sampler_capture_replay_descriptor_data_size: Default::default(),
            acceleration_structure_capture_replay_descriptor_data_size: Default::default(),
            sampler_descriptor_size: Default::default(),
            combined_image_sampler_descriptor_size: Default::default(),
            sampled_image_descriptor_size: Default::default(),
            storage_image_descriptor_size: Default::default(),
            uniform_texel_buffer_descriptor_size: Default::default(),
            robust_uniform_texel_buffer_descriptor_size: Default::default(),
            storage_texel_buffer_descriptor_size: Default::default(),
            robust_storage_texel_buffer_descriptor_size: Default::default(),
            uniform_buffer_descriptor_size: Default::default(),
            robust_uniform_buffer_descriptor_size: Default::default(),
            storage_buffer_descriptor_size: Default::default(),
            robust_storage_buffer_descriptor_size: Default::default(),
            input_attachment_descriptor_size: Default::default(),
            acceleration_structure_descriptor_size: Default::default(),
            max_sampler_descriptor_buffer_range: Default::default(),
            max_resource_descriptor_buffer_range: Default::default(),
            sampler_descriptor_buffer_address_space_size: Default::default(),
            resource_descriptor_buffer_address_space_size: Default::default(),
            descriptor_buffer_address_space_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDescriptorBufferPropertiesEXT<'a> {
    #[inline]
    pub fn combined_image_sampler_descriptor_single_array(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.combined_image_sampler_descriptor_single_array = value.into();
        self
    }
    #[inline]
    pub fn bufferless_push_descriptors(mut self, value: impl Into<Bool32>) -> Self {
        self.bufferless_push_descriptors = value.into();
        self
    }
    #[inline]
    pub fn allow_sampler_image_view_post_submit_creation(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.allow_sampler_image_view_post_submit_creation = value.into();
        self
    }
    #[inline]
    pub fn descriptor_buffer_offset_alignment(mut self, value: DeviceSize) -> Self {
        self.descriptor_buffer_offset_alignment = value;
        self
    }
    #[inline]
    pub fn max_descriptor_buffer_bindings(mut self, value: u32) -> Self {
        self.max_descriptor_buffer_bindings = value;
        self
    }
    #[inline]
    pub fn max_resource_descriptor_buffer_bindings(mut self, value: u32) -> Self {
        self.max_resource_descriptor_buffer_bindings = value;
        self
    }
    #[inline]
    pub fn max_sampler_descriptor_buffer_bindings(mut self, value: u32) -> Self {
        self.max_sampler_descriptor_buffer_bindings = value;
        self
    }
    #[inline]
    pub fn max_embedded_immutable_sampler_bindings(mut self, value: u32) -> Self {
        self.max_embedded_immutable_sampler_bindings = value;
        self
    }
    #[inline]
    pub fn max_embedded_immutable_samplers(mut self, value: u32) -> Self {
        self.max_embedded_immutable_samplers = value;
        self
    }
    #[inline]
    pub fn buffer_capture_replay_descriptor_data_size(mut self, value: usize) -> Self {
        self.buffer_capture_replay_descriptor_data_size = value;
        self
    }
    #[inline]
    pub fn image_capture_replay_descriptor_data_size(mut self, value: usize) -> Self {
        self.image_capture_replay_descriptor_data_size = value;
        self
    }
    #[inline]
    pub fn image_view_capture_replay_descriptor_data_size(mut self, value: usize) -> Self {
        self.image_view_capture_replay_descriptor_data_size = value;
        self
    }
    #[inline]
    pub fn sampler_capture_replay_descriptor_data_size(mut self, value: usize) -> Self {
        self.sampler_capture_replay_descriptor_data_size = value;
        self
    }
    #[inline]
    pub fn acceleration_structure_capture_replay_descriptor_data_size(
        mut self,
        value: usize,
    ) -> Self {
        self.acceleration_structure_capture_replay_descriptor_data_size = value;
        self
    }
    #[inline]
    pub fn sampler_descriptor_size(mut self, value: usize) -> Self {
        self.sampler_descriptor_size = value;
        self
    }
    #[inline]
    pub fn combined_image_sampler_descriptor_size(mut self, value: usize) -> Self {
        self.combined_image_sampler_descriptor_size = value;
        self
    }
    #[inline]
    pub fn sampled_image_descriptor_size(mut self, value: usize) -> Self {
        self.sampled_image_descriptor_size = value;
        self
    }
    #[inline]
    pub fn storage_image_descriptor_size(mut self, value: usize) -> Self {
        self.storage_image_descriptor_size = value;
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_descriptor_size(mut self, value: usize) -> Self {
        self.uniform_texel_buffer_descriptor_size = value;
        self
    }
    #[inline]
    pub fn robust_uniform_texel_buffer_descriptor_size(mut self, value: usize) -> Self {
        self.robust_uniform_texel_buffer_descriptor_size = value;
        self
    }
    #[inline]
    pub fn storage_texel_buffer_descriptor_size(mut self, value: usize) -> Self {
        self.storage_texel_buffer_descriptor_size = value;
        self
    }
    #[inline]
    pub fn robust_storage_texel_buffer_descriptor_size(mut self, value: usize) -> Self {
        self.robust_storage_texel_buffer_descriptor_size = value;
        self
    }
    #[inline]
    pub fn uniform_buffer_descriptor_size(mut self, value: usize) -> Self {
        self.uniform_buffer_descriptor_size = value;
        self
    }
    #[inline]
    pub fn robust_uniform_buffer_descriptor_size(mut self, value: usize) -> Self {
        self.robust_uniform_buffer_descriptor_size = value;
        self
    }
    #[inline]
    pub fn storage_buffer_descriptor_size(mut self, value: usize) -> Self {
        self.storage_buffer_descriptor_size = value;
        self
    }
    #[inline]
    pub fn robust_storage_buffer_descriptor_size(mut self, value: usize) -> Self {
        self.robust_storage_buffer_descriptor_size = value;
        self
    }
    #[inline]
    pub fn input_attachment_descriptor_size(mut self, value: usize) -> Self {
        self.input_attachment_descriptor_size = value;
        self
    }
    #[inline]
    pub fn acceleration_structure_descriptor_size(mut self, value: usize) -> Self {
        self.acceleration_structure_descriptor_size = value;
        self
    }
    #[inline]
    pub fn max_sampler_descriptor_buffer_range(mut self, value: DeviceSize) -> Self {
        self.max_sampler_descriptor_buffer_range = value;
        self
    }
    #[inline]
    pub fn max_resource_descriptor_buffer_range(mut self, value: DeviceSize) -> Self {
        self.max_resource_descriptor_buffer_range = value;
        self
    }
    #[inline]
    pub fn sampler_descriptor_buffer_address_space_size(mut self, value: DeviceSize) -> Self {
        self.sampler_descriptor_buffer_address_space_size = value;
        self
    }
    #[inline]
    pub fn resource_descriptor_buffer_address_space_size(mut self, value: DeviceSize) -> Self {
        self.resource_descriptor_buffer_address_space_size = value;
        self
    }
    #[inline]
    pub fn descriptor_buffer_address_space_size(mut self, value: DeviceSize) -> Self {
        self.descriptor_buffer_address_space_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT")]
pub struct PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub combined_image_sampler_density_map_descriptor_size: usize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            combined_image_sampler_density_map_descriptor_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT<'a> {
    #[inline]
    pub fn combined_image_sampler_density_map_descriptor_size(mut self, value: usize) -> Self {
        self.combined_image_sampler_density_map_descriptor_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorBufferFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceDescriptorBufferFeaturesEXT")]
pub struct PhysicalDeviceDescriptorBufferFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub descriptor_buffer: Bool32,
    pub descriptor_buffer_capture_replay: Bool32,
    pub descriptor_buffer_image_layout_ignored: Bool32,
    pub descriptor_buffer_push_descriptors: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDescriptorBufferFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceDescriptorBufferFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceDescriptorBufferFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDescriptorBufferFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDescriptorBufferFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDescriptorBufferFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceDescriptorBufferFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            descriptor_buffer: Default::default(),
            descriptor_buffer_capture_replay: Default::default(),
            descriptor_buffer_image_layout_ignored: Default::default(),
            descriptor_buffer_push_descriptors: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDescriptorBufferFeaturesEXT<'a> {
    #[inline]
    pub fn descriptor_buffer(mut self, value: impl Into<Bool32>) -> Self {
        self.descriptor_buffer = value.into();
        self
    }
    #[inline]
    pub fn descriptor_buffer_capture_replay(mut self, value: impl Into<Bool32>) -> Self {
        self.descriptor_buffer_capture_replay = value.into();
        self
    }
    #[inline]
    pub fn descriptor_buffer_image_layout_ignored(mut self, value: impl Into<Bool32>) -> Self {
        self.descriptor_buffer_image_layout_ignored = value.into();
        self
    }
    #[inline]
    pub fn descriptor_buffer_push_descriptors(mut self, value: impl Into<Bool32>) -> Self {
        self.descriptor_buffer_push_descriptors = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorAddressInfoEXT.html>"]
#[doc(alias = "VkDescriptorAddressInfoEXT")]
pub struct DescriptorAddressInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub address: DeviceAddress,
    pub range: DeviceSize,
    pub format: Format,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorAddressInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DescriptorAddressInfoEXT;
}
unsafe impl<'a> Send for DescriptorAddressInfoEXT<'a> {}
unsafe impl<'a> Sync for DescriptorAddressInfoEXT<'a> {}
impl<'a> Default for DescriptorAddressInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            address: Default::default(),
            range: Default::default(),
            format: Format::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorAddressInfoEXT<'a> {
    #[inline]
    pub fn address(mut self, value: DeviceAddress) -> Self {
        self.address = value;
        self
    }
    #[inline]
    pub fn range(mut self, value: DeviceSize) -> Self {
        self.range = value;
        self
    }
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBufferBindingInfoEXT.html>"]
#[doc(alias = "VkDescriptorBufferBindingInfoEXT")]
pub struct DescriptorBufferBindingInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub address: DeviceAddress,
    pub usage: BufferUsageFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorBufferBindingInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DescriptorBufferBindingInfoEXT;
}
unsafe impl<'a> Send for DescriptorBufferBindingInfoEXT<'a> {}
unsafe impl<'a> Sync for DescriptorBufferBindingInfoEXT<'a> {}
impl<'a> Default for DescriptorBufferBindingInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            address: Default::default(),
            usage: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorBufferBindingInfoEXT<'a> {
    #[inline]
    pub fn address(mut self, value: DeviceAddress) -> Self {
        self.address = value;
        self
    }
    #[inline]
    pub fn usage(mut self, value: BufferUsageFlags) -> Self {
        self.usage = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBufferBindingPushDescriptorBufferHandleEXT.html>"]
#[doc(alias = "VkDescriptorBufferBindingPushDescriptorBufferHandleEXT")]
pub struct DescriptorBufferBindingPushDescriptorBufferHandleEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub buffer: Option<Buffer>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorBufferBindingPushDescriptorBufferHandleEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DescriptorBufferBindingPushDescriptorBufferHandleEXT;
}
unsafe impl<'a> Send for DescriptorBufferBindingPushDescriptorBufferHandleEXT<'a> {}
unsafe impl<'a> Sync for DescriptorBufferBindingPushDescriptorBufferHandleEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DescriptorBufferBindingInfoEXT<'b>>
    for DescriptorBufferBindingPushDescriptorBufferHandleEXT<'a>
{
}
impl<'a> Default for DescriptorBufferBindingPushDescriptorBufferHandleEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            buffer: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorBufferBindingPushDescriptorBufferHandleEXT<'a> {
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorDataEXT.html>"]
#[doc(alias = "VkDescriptorDataEXT")]
pub union DescriptorDataEXT<'a> {
    pub p_sampler: ManuallyDrop<*const Sampler>,
    pub p_combined_image_sampler: ManuallyDrop<*const DescriptorImageInfo<'a>>,
    pub p_input_attachment_image: ManuallyDrop<*const DescriptorImageInfo<'a>>,
    pub p_sampled_image: ManuallyDrop<*const DescriptorImageInfo<'a>>,
    pub p_storage_image: ManuallyDrop<*const DescriptorImageInfo<'a>>,
    pub p_uniform_texel_buffer: ManuallyDrop<*const DescriptorAddressInfoEXT<'a>>,
    pub p_storage_texel_buffer: ManuallyDrop<*const DescriptorAddressInfoEXT<'a>>,
    pub p_uniform_buffer: ManuallyDrop<*const DescriptorAddressInfoEXT<'a>>,
    pub p_storage_buffer: ManuallyDrop<*const DescriptorAddressInfoEXT<'a>>,
    pub acceleration_structure: DeviceAddress,
}
impl<'a> Default for DescriptorDataEXT<'a> {
    fn default() -> Self {
        Self {
            p_sampler: ManuallyDrop::new(ptr::null()),
        }
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorGetInfoEXT.html>"]
#[doc(alias = "VkDescriptorGetInfoEXT")]
pub struct DescriptorGetInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ty: DescriptorType,
    pub data: DescriptorDataEXT<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorGetInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DescriptorGetInfoEXT;
}
unsafe impl<'a> Send for DescriptorGetInfoEXT<'a> {}
unsafe impl<'a> Sync for DescriptorGetInfoEXT<'a> {}
impl<'a> Default for DescriptorGetInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ty: DescriptorType::Sampler,
            data: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorGetInfoEXT<'a> {
    #[inline]
    pub fn ty(mut self, value: DescriptorType) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn data(mut self, value: DescriptorDataEXT<'a>) -> Self {
        self.data = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCaptureDescriptorDataInfoEXT.html>"]
#[doc(alias = "VkBufferCaptureDescriptorDataInfoEXT")]
pub struct BufferCaptureDescriptorDataInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub buffer: Option<Buffer>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferCaptureDescriptorDataInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferCaptureDescriptorDataInfoEXT;
}
unsafe impl<'a> Send for BufferCaptureDescriptorDataInfoEXT<'a> {}
unsafe impl<'a> Sync for BufferCaptureDescriptorDataInfoEXT<'a> {}
impl<'a> Default for BufferCaptureDescriptorDataInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            buffer: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferCaptureDescriptorDataInfoEXT<'a> {
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCaptureDescriptorDataInfoEXT.html>"]
#[doc(alias = "VkImageCaptureDescriptorDataInfoEXT")]
pub struct ImageCaptureDescriptorDataInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image: Option<Image>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageCaptureDescriptorDataInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageCaptureDescriptorDataInfoEXT;
}
unsafe impl<'a> Send for ImageCaptureDescriptorDataInfoEXT<'a> {}
unsafe impl<'a> Sync for ImageCaptureDescriptorDataInfoEXT<'a> {}
impl<'a> Default for ImageCaptureDescriptorDataInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageCaptureDescriptorDataInfoEXT<'a> {
    #[inline]
    pub fn image(mut self, value: &'a Image) -> Self {
        self.image = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCaptureDescriptorDataInfoEXT.html>"]
#[doc(alias = "VkImageViewCaptureDescriptorDataInfoEXT")]
pub struct ImageViewCaptureDescriptorDataInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_view: Option<ImageView>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageViewCaptureDescriptorDataInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageViewCaptureDescriptorDataInfoEXT;
}
unsafe impl<'a> Send for ImageViewCaptureDescriptorDataInfoEXT<'a> {}
unsafe impl<'a> Sync for ImageViewCaptureDescriptorDataInfoEXT<'a> {}
impl<'a> Default for ImageViewCaptureDescriptorDataInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_view: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageViewCaptureDescriptorDataInfoEXT<'a> {
    #[inline]
    pub fn image_view(mut self, value: &'a ImageView) -> Self {
        self.image_view = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCaptureDescriptorDataInfoEXT.html>"]
#[doc(alias = "VkSamplerCaptureDescriptorDataInfoEXT")]
pub struct SamplerCaptureDescriptorDataInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub sampler: Option<Sampler>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SamplerCaptureDescriptorDataInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SamplerCaptureDescriptorDataInfoEXT;
}
unsafe impl<'a> Send for SamplerCaptureDescriptorDataInfoEXT<'a> {}
unsafe impl<'a> Sync for SamplerCaptureDescriptorDataInfoEXT<'a> {}
impl<'a> Default for SamplerCaptureDescriptorDataInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            sampler: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SamplerCaptureDescriptorDataInfoEXT<'a> {
    #[inline]
    pub fn sampler(mut self, value: &'a Sampler) -> Self {
        self.sampler = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpaqueCaptureDescriptorDataCreateInfoEXT.html>"]
#[doc(alias = "VkOpaqueCaptureDescriptorDataCreateInfoEXT")]
pub struct OpaqueCaptureDescriptorDataCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub opaque_capture_descriptor_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for OpaqueCaptureDescriptorDataCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::OpaqueCaptureDescriptorDataCreateInfoEXT;
}
unsafe impl<'a> Send for OpaqueCaptureDescriptorDataCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for OpaqueCaptureDescriptorDataCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BufferCreateInfo<'b>>
    for OpaqueCaptureDescriptorDataCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>>
    for OpaqueCaptureDescriptorDataCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<ImageViewCreateInfo<'b>>
    for OpaqueCaptureDescriptorDataCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<SamplerCreateInfo<'b>>
    for OpaqueCaptureDescriptorDataCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<AccelerationStructureCreateInfoKHR<'b>>
    for OpaqueCaptureDescriptorDataCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<AccelerationStructureCreateInfoNV<'b>>
    for OpaqueCaptureDescriptorDataCreateInfoEXT<'a>
{
}
impl<'a> Default for OpaqueCaptureDescriptorDataCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            opaque_capture_descriptor_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> OpaqueCaptureDescriptorDataCreateInfoEXT<'a> {
    #[inline]
    pub fn opaque_capture_descriptor_data(mut self, value: VoidPtr) -> Self {
        self.opaque_capture_descriptor_data = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureCaptureDescriptorDataInfoEXT.html>"]
#[doc(alias = "VkAccelerationStructureCaptureDescriptorDataInfoEXT")]
pub struct AccelerationStructureCaptureDescriptorDataInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub acceleration_structure: Option<AccelerationStructureKHR>,
    pub acceleration_structure_nv: Option<AccelerationStructureNV>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureCaptureDescriptorDataInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::AccelerationStructureCaptureDescriptorDataInfoEXT;
}
unsafe impl<'a> Send for AccelerationStructureCaptureDescriptorDataInfoEXT<'a> {}
unsafe impl<'a> Sync for AccelerationStructureCaptureDescriptorDataInfoEXT<'a> {}
impl<'a> Default for AccelerationStructureCaptureDescriptorDataInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            acceleration_structure: Default::default(),
            acceleration_structure_nv: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureCaptureDescriptorDataInfoEXT<'a> {
    #[inline]
    pub fn acceleration_structure(mut self, value: Option<&'a AccelerationStructureKHR>) -> Self {
        self.acceleration_structure = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn acceleration_structure_nv(mut self, value: Option<&'a AccelerationStructureNV>) -> Self {
        self.acceleration_structure_nv = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT")]
pub struct PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub graphics_pipeline_library: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            graphics_pipeline_library: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'a> {
    #[inline]
    pub fn graphics_pipeline_library(mut self, value: impl Into<Bool32>) -> Self {
        self.graphics_pipeline_library = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT")]
pub struct PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub graphics_pipeline_library_fast_linking: Bool32,
    pub graphics_pipeline_library_independent_interpolation_decoration: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            graphics_pipeline_library_fast_linking: Default::default(),
            graphics_pipeline_library_independent_interpolation_decoration: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT<'a> {
    #[inline]
    pub fn graphics_pipeline_library_fast_linking(mut self, value: impl Into<Bool32>) -> Self {
        self.graphics_pipeline_library_fast_linking = value.into();
        self
    }
    #[inline]
    pub fn graphics_pipeline_library_independent_interpolation_decoration(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.graphics_pipeline_library_independent_interpolation_decoration = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineLibraryCreateInfoEXT.html>"]
#[doc(alias = "VkGraphicsPipelineLibraryCreateInfoEXT")]
pub struct GraphicsPipelineLibraryCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: GraphicsPipelineLibraryFlagsEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for GraphicsPipelineLibraryCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GraphicsPipelineLibraryCreateInfoEXT;
}
unsafe impl<'a> Send for GraphicsPipelineLibraryCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for GraphicsPipelineLibraryCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for GraphicsPipelineLibraryCreateInfoEXT<'a>
{
}
impl<'a> Default for GraphicsPipelineLibraryCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> GraphicsPipelineLibraryCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: GraphicsPipelineLibraryFlagsEXT) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.html>"]
#[doc(alias = "VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD")]
pub struct PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_early_and_late_fragment_tests: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure
    for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'a>
{
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD;
}
unsafe impl<'a> Send for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_early_and_late_fragment_tests: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'a> {
    #[inline]
    pub fn shader_early_and_late_fragment_tests(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_early_and_late_fragment_tests = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR")]
pub struct PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fragment_shader_barycentric: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fragment_shader_barycentric: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'a> {
    #[inline]
    pub fn fragment_shader_barycentric(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_shader_barycentric = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceFragmentShaderBarycentricFeaturesNV<'a> =
    PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR")]
pub struct PhysicalDeviceFragmentShaderBarycentricPropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub tri_strip_vertex_order_independent_of_provoking_vertex: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentShaderBarycentricPropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            tri_strip_vertex_order_independent_of_provoking_vertex: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentShaderBarycentricPropertiesKHR<'a> {
    #[inline]
    pub fn tri_strip_vertex_order_independent_of_provoking_vertex(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.tri_strip_vertex_order_independent_of_provoking_vertex = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR")]
pub struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_subgroup_uniform_control_flow: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure
    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'a>
{
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_subgroup_uniform_control_flow: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'a> {
    #[inline]
    pub fn shader_subgroup_uniform_control_flow(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_subgroup_uniform_control_flow = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV")]
pub struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fragment_shading_rate_enums: Bool32,
    pub supersample_fragment_shading_rates: Bool32,
    pub no_invocation_fragment_shading_rates: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fragment_shading_rate_enums: Default::default(),
            supersample_fragment_shading_rates: Default::default(),
            no_invocation_fragment_shading_rates: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'a> {
    #[inline]
    pub fn fragment_shading_rate_enums(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_shading_rate_enums = value.into();
        self
    }
    #[inline]
    pub fn supersample_fragment_shading_rates(mut self, value: impl Into<Bool32>) -> Self {
        self.supersample_fragment_shading_rates = value.into();
        self
    }
    #[inline]
    pub fn no_invocation_fragment_shading_rates(mut self, value: impl Into<Bool32>) -> Self {
        self.no_invocation_fragment_shading_rates = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV")]
pub struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_fragment_shading_rate_invocation_count: SampleCountFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentShadingRateEnumsPropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_fragment_shading_rate_invocation_count: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentShadingRateEnumsPropertiesNV<'a> {
    #[inline]
    pub fn max_fragment_shading_rate_invocation_count(mut self, value: SampleCountFlags) -> Self {
        self.max_fragment_shading_rate_invocation_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineFragmentShadingRateEnumStateCreateInfoNV.html>"]
#[doc(alias = "VkPipelineFragmentShadingRateEnumStateCreateInfoNV")]
pub struct PipelineFragmentShadingRateEnumStateCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shading_rate_type: FragmentShadingRateTypeNV,
    pub shading_rate: FragmentShadingRateNV,
    pub combiner_ops: [FragmentShadingRateCombinerOpKHR; 2u16 as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineFragmentShadingRateEnumStateCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineFragmentShadingRateEnumStateCreateInfoNV;
}
unsafe impl<'a> Send for PipelineFragmentShadingRateEnumStateCreateInfoNV<'a> {}
unsafe impl<'a> Sync for PipelineFragmentShadingRateEnumStateCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for PipelineFragmentShadingRateEnumStateCreateInfoNV<'a>
{
}
impl<'a> Default for PipelineFragmentShadingRateEnumStateCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shading_rate_type: FragmentShadingRateTypeNV::FragmentSize,
            shading_rate: FragmentShadingRateNV::Rate1InvocationPerPixel,
            combiner_ops: array::from_fn(|_| FragmentShadingRateCombinerOpKHR::Keep),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineFragmentShadingRateEnumStateCreateInfoNV<'a> {
    #[inline]
    pub fn shading_rate_type(mut self, value: FragmentShadingRateTypeNV) -> Self {
        self.shading_rate_type = value;
        self
    }
    #[inline]
    pub fn shading_rate(mut self, value: FragmentShadingRateNV) -> Self {
        self.shading_rate = value;
        self
    }
    #[inline]
    pub fn combiner_ops(mut self, value: [FragmentShadingRateCombinerOpKHR; 2u16 as _]) -> Self {
        self.combiner_ops = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryMotionTrianglesDataNV.html>"]
#[doc(alias = "VkAccelerationStructureGeometryMotionTrianglesDataNV")]
pub struct AccelerationStructureGeometryMotionTrianglesDataNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub vertex_data: DeviceOrHostAddressConstKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureGeometryMotionTrianglesDataNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::AccelerationStructureGeometryMotionTrianglesDataNV;
}
unsafe impl<'a> Send for AccelerationStructureGeometryMotionTrianglesDataNV<'a> {}
unsafe impl<'a> Sync for AccelerationStructureGeometryMotionTrianglesDataNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<AccelerationStructureGeometryTrianglesDataKHR<'b>>
    for AccelerationStructureGeometryMotionTrianglesDataNV<'a>
{
}
impl<'a> Default for AccelerationStructureGeometryMotionTrianglesDataNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            vertex_data: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureGeometryMotionTrianglesDataNV<'a> {
    #[inline]
    pub fn vertex_data(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.vertex_data = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInfoNV.html>"]
#[doc(alias = "VkAccelerationStructureMotionInfoNV")]
pub struct AccelerationStructureMotionInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_instances: u32,
    pub flags: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureMotionInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AccelerationStructureMotionInfoNV;
}
unsafe impl<'a> Send for AccelerationStructureMotionInfoNV<'a> {}
unsafe impl<'a> Sync for AccelerationStructureMotionInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<AccelerationStructureCreateInfoKHR<'b>>
    for AccelerationStructureMotionInfoNV<'a>
{
}
impl<'a> Default for AccelerationStructureMotionInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_instances: Default::default(),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureMotionInfoNV<'a> {
    #[inline]
    pub fn max_instances(mut self, value: u32) -> Self {
        self.max_instances = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInstanceNV.html>"]
#[doc(alias = "VkAccelerationStructureMotionInstanceNV")]
pub struct AccelerationStructureMotionInstanceNV {
    pub ty: AccelerationStructureMotionInstanceTypeNV,
    pub flags: u32,
    pub data: AccelerationStructureMotionInstanceDataNV,
}
unsafe impl Send for AccelerationStructureMotionInstanceNV {}
unsafe impl Sync for AccelerationStructureMotionInstanceNV {}
impl Default for AccelerationStructureMotionInstanceNV {
    fn default() -> Self {
        Self {
            ty: AccelerationStructureMotionInstanceTypeNV::Static,
            flags: Default::default(),
            data: Default::default(),
        }
    }
}
impl AccelerationStructureMotionInstanceNV {
    #[inline]
    pub fn ty(mut self, value: AccelerationStructureMotionInstanceTypeNV) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn data(mut self, value: AccelerationStructureMotionInstanceDataNV) -> Self {
        self.data = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInstanceDataNV.html>"]
#[doc(alias = "VkAccelerationStructureMotionInstanceDataNV")]
pub union AccelerationStructureMotionInstanceDataNV {
    pub static_instance: AccelerationStructureInstanceKHR,
    pub matrix_motion_instance: AccelerationStructureMatrixMotionInstanceNV,
    pub srt_motion_instance: AccelerationStructureSRTMotionInstanceNV,
}
impl Default for AccelerationStructureMotionInstanceDataNV {
    fn default() -> Self {
        Self {
            static_instance: Default::default(),
        }
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMatrixMotionInstanceNV.html>"]
#[doc(alias = "VkAccelerationStructureMatrixMotionInstanceNV")]
pub struct AccelerationStructureMatrixMotionInstanceNV {
    pub transform_t0: TransformMatrixKHR,
    pub transform_t1: TransformMatrixKHR,
    pub instance_custom_index: [u8; 3u8 as _],
    pub mask: [u8; 1u8 as _],
    pub instance_shader_binding_table_record_offset: [u8; 3u8 as _],
    pub flags: [u8; 1u8 as _],
    pub acceleration_structure_reference: u64,
}
unsafe impl Send for AccelerationStructureMatrixMotionInstanceNV {}
unsafe impl Sync for AccelerationStructureMatrixMotionInstanceNV {}
impl Default for AccelerationStructureMatrixMotionInstanceNV {
    fn default() -> Self {
        Self {
            transform_t0: Default::default(),
            transform_t1: Default::default(),
            instance_custom_index: Default::default(),
            mask: Default::default(),
            instance_shader_binding_table_record_offset: Default::default(),
            flags: Default::default(),
            acceleration_structure_reference: Default::default(),
        }
    }
}
impl AccelerationStructureMatrixMotionInstanceNV {
    #[inline]
    pub fn transform_t0(mut self, value: TransformMatrixKHR) -> Self {
        self.transform_t0 = value;
        self
    }
    #[inline]
    pub fn transform_t1(mut self, value: TransformMatrixKHR) -> Self {
        self.transform_t1 = value;
        self
    }
    #[inline]
    pub fn instance_custom_index(mut self, value: u32) -> Self {
        self.instance_custom_index = (value as u32).to_ne_bytes()[..3usize].try_into().unwrap();
        self
    }
    #[inline]
    pub fn mask(mut self, value: u32) -> Self {
        self.mask = (value as u32).to_ne_bytes()[..1usize].try_into().unwrap();
        self
    }
    #[inline]
    pub fn instance_shader_binding_table_record_offset(mut self, value: u32) -> Self {
        self.instance_shader_binding_table_record_offset =
            (value as u32).to_ne_bytes()[..3usize].try_into().unwrap();
        self
    }
    #[inline]
    pub fn flags(mut self, value: GeometryInstanceFlagsKHR) -> Self {
        self.flags = value.bits().to_ne_bytes()[..1usize].try_into().unwrap();
        self
    }
    #[inline]
    pub fn acceleration_structure_reference(mut self, value: u64) -> Self {
        self.acceleration_structure_reference = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureSRTMotionInstanceNV.html>"]
#[doc(alias = "VkAccelerationStructureSRTMotionInstanceNV")]
pub struct AccelerationStructureSRTMotionInstanceNV {
    pub transform_t0: SRTDataNV,
    pub transform_t1: SRTDataNV,
    pub instance_custom_index: [u8; 3u8 as _],
    pub mask: [u8; 1u8 as _],
    pub instance_shader_binding_table_record_offset: [u8; 3u8 as _],
    pub flags: [u8; 1u8 as _],
    pub acceleration_structure_reference: u64,
}
unsafe impl Send for AccelerationStructureSRTMotionInstanceNV {}
unsafe impl Sync for AccelerationStructureSRTMotionInstanceNV {}
impl Default for AccelerationStructureSRTMotionInstanceNV {
    fn default() -> Self {
        Self {
            transform_t0: Default::default(),
            transform_t1: Default::default(),
            instance_custom_index: Default::default(),
            mask: Default::default(),
            instance_shader_binding_table_record_offset: Default::default(),
            flags: Default::default(),
            acceleration_structure_reference: Default::default(),
        }
    }
}
impl AccelerationStructureSRTMotionInstanceNV {
    #[inline]
    pub fn transform_t0(mut self, value: SRTDataNV) -> Self {
        self.transform_t0 = value;
        self
    }
    #[inline]
    pub fn transform_t1(mut self, value: SRTDataNV) -> Self {
        self.transform_t1 = value;
        self
    }
    #[inline]
    pub fn instance_custom_index(mut self, value: u32) -> Self {
        self.instance_custom_index = (value as u32).to_ne_bytes()[..3usize].try_into().unwrap();
        self
    }
    #[inline]
    pub fn mask(mut self, value: u32) -> Self {
        self.mask = (value as u32).to_ne_bytes()[..1usize].try_into().unwrap();
        self
    }
    #[inline]
    pub fn instance_shader_binding_table_record_offset(mut self, value: u32) -> Self {
        self.instance_shader_binding_table_record_offset =
            (value as u32).to_ne_bytes()[..3usize].try_into().unwrap();
        self
    }
    #[inline]
    pub fn flags(mut self, value: GeometryInstanceFlagsKHR) -> Self {
        self.flags = value.bits().to_ne_bytes()[..1usize].try_into().unwrap();
        self
    }
    #[inline]
    pub fn acceleration_structure_reference(mut self, value: u64) -> Self {
        self.acceleration_structure_reference = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSRTDataNV.html>"]
#[doc(alias = "VkSRTDataNV")]
pub struct SRTDataNV {
    pub sx: f32,
    pub a: f32,
    pub b: f32,
    pub pvx: f32,
    pub sy: f32,
    pub c: f32,
    pub pvy: f32,
    pub sz: f32,
    pub pvz: f32,
    pub qx: f32,
    pub qy: f32,
    pub qz: f32,
    pub qw: f32,
    pub tx: f32,
    pub ty: f32,
    pub tz: f32,
}
unsafe impl Send for SRTDataNV {}
unsafe impl Sync for SRTDataNV {}
impl Default for SRTDataNV {
    fn default() -> Self {
        Self {
            sx: Default::default(),
            a: Default::default(),
            b: Default::default(),
            pvx: Default::default(),
            sy: Default::default(),
            c: Default::default(),
            pvy: Default::default(),
            sz: Default::default(),
            pvz: Default::default(),
            qx: Default::default(),
            qy: Default::default(),
            qz: Default::default(),
            qw: Default::default(),
            tx: Default::default(),
            ty: Default::default(),
            tz: Default::default(),
        }
    }
}
impl SRTDataNV {
    #[inline]
    pub fn sx(mut self, value: f32) -> Self {
        self.sx = value;
        self
    }
    #[inline]
    pub fn a(mut self, value: f32) -> Self {
        self.a = value;
        self
    }
    #[inline]
    pub fn b(mut self, value: f32) -> Self {
        self.b = value;
        self
    }
    #[inline]
    pub fn pvx(mut self, value: f32) -> Self {
        self.pvx = value;
        self
    }
    #[inline]
    pub fn sy(mut self, value: f32) -> Self {
        self.sy = value;
        self
    }
    #[inline]
    pub fn c(mut self, value: f32) -> Self {
        self.c = value;
        self
    }
    #[inline]
    pub fn pvy(mut self, value: f32) -> Self {
        self.pvy = value;
        self
    }
    #[inline]
    pub fn sz(mut self, value: f32) -> Self {
        self.sz = value;
        self
    }
    #[inline]
    pub fn pvz(mut self, value: f32) -> Self {
        self.pvz = value;
        self
    }
    #[inline]
    pub fn qx(mut self, value: f32) -> Self {
        self.qx = value;
        self
    }
    #[inline]
    pub fn qy(mut self, value: f32) -> Self {
        self.qy = value;
        self
    }
    #[inline]
    pub fn qz(mut self, value: f32) -> Self {
        self.qz = value;
        self
    }
    #[inline]
    pub fn qw(mut self, value: f32) -> Self {
        self.qw = value;
        self
    }
    #[inline]
    pub fn tx(mut self, value: f32) -> Self {
        self.tx = value;
        self
    }
    #[inline]
    pub fn ty(mut self, value: f32) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn tz(mut self, value: f32) -> Self {
        self.tz = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceRayTracingMotionBlurFeaturesNV")]
pub struct PhysicalDeviceRayTracingMotionBlurFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ray_tracing_motion_blur: Bool32,
    pub ray_tracing_motion_blur_pipeline_trace_rays_indirect: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRayTracingMotionBlurFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceRayTracingMotionBlurFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceRayTracingMotionBlurFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRayTracingMotionBlurFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRayTracingMotionBlurFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRayTracingMotionBlurFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceRayTracingMotionBlurFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ray_tracing_motion_blur: Default::default(),
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRayTracingMotionBlurFeaturesNV<'a> {
    #[inline]
    pub fn ray_tracing_motion_blur(mut self, value: impl Into<Bool32>) -> Self {
        self.ray_tracing_motion_blur = value.into();
        self
    }
    #[inline]
    pub fn ray_tracing_motion_blur_pipeline_trace_rays_indirect(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.ray_tracing_motion_blur_pipeline_trace_rays_indirect = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceMeshShaderFeaturesEXT")]
pub struct PhysicalDeviceMeshShaderFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub task_shader: Bool32,
    pub mesh_shader: Bool32,
    pub multiview_mesh_shader: Bool32,
    pub primitive_fragment_shading_rate_mesh_shader: Bool32,
    pub mesh_shader_queries: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMeshShaderFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMeshShaderFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceMeshShaderFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMeshShaderFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMeshShaderFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMeshShaderFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceMeshShaderFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            task_shader: Default::default(),
            mesh_shader: Default::default(),
            multiview_mesh_shader: Default::default(),
            primitive_fragment_shading_rate_mesh_shader: Default::default(),
            mesh_shader_queries: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMeshShaderFeaturesEXT<'a> {
    #[inline]
    pub fn task_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.task_shader = value.into();
        self
    }
    #[inline]
    pub fn mesh_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.mesh_shader = value.into();
        self
    }
    #[inline]
    pub fn multiview_mesh_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.multiview_mesh_shader = value.into();
        self
    }
    #[inline]
    pub fn primitive_fragment_shading_rate_mesh_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.primitive_fragment_shading_rate_mesh_shader = value.into();
        self
    }
    #[inline]
    pub fn mesh_shader_queries(mut self, value: impl Into<Bool32>) -> Self {
        self.mesh_shader_queries = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceMeshShaderPropertiesEXT")]
pub struct PhysicalDeviceMeshShaderPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_task_work_group_total_count: u32,
    pub max_task_work_group_count: [u32; 3u16 as _],
    pub max_task_work_group_invocations: u32,
    pub max_task_work_group_size: [u32; 3u16 as _],
    pub max_task_payload_size: u32,
    pub max_task_shared_memory_size: u32,
    pub max_task_payload_and_shared_memory_size: u32,
    pub max_mesh_work_group_total_count: u32,
    pub max_mesh_work_group_count: [u32; 3u16 as _],
    pub max_mesh_work_group_invocations: u32,
    pub max_mesh_work_group_size: [u32; 3u16 as _],
    pub max_mesh_shared_memory_size: u32,
    pub max_mesh_payload_and_shared_memory_size: u32,
    pub max_mesh_output_memory_size: u32,
    pub max_mesh_payload_and_output_memory_size: u32,
    pub max_mesh_output_components: u32,
    pub max_mesh_output_vertices: u32,
    pub max_mesh_output_primitives: u32,
    pub max_mesh_output_layers: u32,
    pub max_mesh_multiview_view_count: u32,
    pub mesh_output_per_vertex_granularity: u32,
    pub mesh_output_per_primitive_granularity: u32,
    pub max_preferred_task_work_group_invocations: u32,
    pub max_preferred_mesh_work_group_invocations: u32,
    pub prefers_local_invocation_vertex_output: Bool32,
    pub prefers_local_invocation_primitive_output: Bool32,
    pub prefers_compact_vertex_output: Bool32,
    pub prefers_compact_primitive_output: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMeshShaderPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMeshShaderPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceMeshShaderPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMeshShaderPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceMeshShaderPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceMeshShaderPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_task_work_group_total_count: Default::default(),
            max_task_work_group_count: array::from_fn(|_| Default::default()),
            max_task_work_group_invocations: Default::default(),
            max_task_work_group_size: array::from_fn(|_| Default::default()),
            max_task_payload_size: Default::default(),
            max_task_shared_memory_size: Default::default(),
            max_task_payload_and_shared_memory_size: Default::default(),
            max_mesh_work_group_total_count: Default::default(),
            max_mesh_work_group_count: array::from_fn(|_| Default::default()),
            max_mesh_work_group_invocations: Default::default(),
            max_mesh_work_group_size: array::from_fn(|_| Default::default()),
            max_mesh_shared_memory_size: Default::default(),
            max_mesh_payload_and_shared_memory_size: Default::default(),
            max_mesh_output_memory_size: Default::default(),
            max_mesh_payload_and_output_memory_size: Default::default(),
            max_mesh_output_components: Default::default(),
            max_mesh_output_vertices: Default::default(),
            max_mesh_output_primitives: Default::default(),
            max_mesh_output_layers: Default::default(),
            max_mesh_multiview_view_count: Default::default(),
            mesh_output_per_vertex_granularity: Default::default(),
            mesh_output_per_primitive_granularity: Default::default(),
            max_preferred_task_work_group_invocations: Default::default(),
            max_preferred_mesh_work_group_invocations: Default::default(),
            prefers_local_invocation_vertex_output: Default::default(),
            prefers_local_invocation_primitive_output: Default::default(),
            prefers_compact_vertex_output: Default::default(),
            prefers_compact_primitive_output: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMeshShaderPropertiesEXT<'a> {
    #[inline]
    pub fn max_task_work_group_total_count(mut self, value: u32) -> Self {
        self.max_task_work_group_total_count = value;
        self
    }
    #[inline]
    pub fn max_task_work_group_count(mut self, value: [u32; 3u16 as _]) -> Self {
        self.max_task_work_group_count = value;
        self
    }
    #[inline]
    pub fn max_task_work_group_invocations(mut self, value: u32) -> Self {
        self.max_task_work_group_invocations = value;
        self
    }
    #[inline]
    pub fn max_task_work_group_size(mut self, value: [u32; 3u16 as _]) -> Self {
        self.max_task_work_group_size = value;
        self
    }
    #[inline]
    pub fn max_task_payload_size(mut self, value: u32) -> Self {
        self.max_task_payload_size = value;
        self
    }
    #[inline]
    pub fn max_task_shared_memory_size(mut self, value: u32) -> Self {
        self.max_task_shared_memory_size = value;
        self
    }
    #[inline]
    pub fn max_task_payload_and_shared_memory_size(mut self, value: u32) -> Self {
        self.max_task_payload_and_shared_memory_size = value;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_total_count(mut self, value: u32) -> Self {
        self.max_mesh_work_group_total_count = value;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_count(mut self, value: [u32; 3u16 as _]) -> Self {
        self.max_mesh_work_group_count = value;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_invocations(mut self, value: u32) -> Self {
        self.max_mesh_work_group_invocations = value;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_size(mut self, value: [u32; 3u16 as _]) -> Self {
        self.max_mesh_work_group_size = value;
        self
    }
    #[inline]
    pub fn max_mesh_shared_memory_size(mut self, value: u32) -> Self {
        self.max_mesh_shared_memory_size = value;
        self
    }
    #[inline]
    pub fn max_mesh_payload_and_shared_memory_size(mut self, value: u32) -> Self {
        self.max_mesh_payload_and_shared_memory_size = value;
        self
    }
    #[inline]
    pub fn max_mesh_output_memory_size(mut self, value: u32) -> Self {
        self.max_mesh_output_memory_size = value;
        self
    }
    #[inline]
    pub fn max_mesh_payload_and_output_memory_size(mut self, value: u32) -> Self {
        self.max_mesh_payload_and_output_memory_size = value;
        self
    }
    #[inline]
    pub fn max_mesh_output_components(mut self, value: u32) -> Self {
        self.max_mesh_output_components = value;
        self
    }
    #[inline]
    pub fn max_mesh_output_vertices(mut self, value: u32) -> Self {
        self.max_mesh_output_vertices = value;
        self
    }
    #[inline]
    pub fn max_mesh_output_primitives(mut self, value: u32) -> Self {
        self.max_mesh_output_primitives = value;
        self
    }
    #[inline]
    pub fn max_mesh_output_layers(mut self, value: u32) -> Self {
        self.max_mesh_output_layers = value;
        self
    }
    #[inline]
    pub fn max_mesh_multiview_view_count(mut self, value: u32) -> Self {
        self.max_mesh_multiview_view_count = value;
        self
    }
    #[inline]
    pub fn mesh_output_per_vertex_granularity(mut self, value: u32) -> Self {
        self.mesh_output_per_vertex_granularity = value;
        self
    }
    #[inline]
    pub fn mesh_output_per_primitive_granularity(mut self, value: u32) -> Self {
        self.mesh_output_per_primitive_granularity = value;
        self
    }
    #[inline]
    pub fn max_preferred_task_work_group_invocations(mut self, value: u32) -> Self {
        self.max_preferred_task_work_group_invocations = value;
        self
    }
    #[inline]
    pub fn max_preferred_mesh_work_group_invocations(mut self, value: u32) -> Self {
        self.max_preferred_mesh_work_group_invocations = value;
        self
    }
    #[inline]
    pub fn prefers_local_invocation_vertex_output(mut self, value: impl Into<Bool32>) -> Self {
        self.prefers_local_invocation_vertex_output = value.into();
        self
    }
    #[inline]
    pub fn prefers_local_invocation_primitive_output(mut self, value: impl Into<Bool32>) -> Self {
        self.prefers_local_invocation_primitive_output = value.into();
        self
    }
    #[inline]
    pub fn prefers_compact_vertex_output(mut self, value: impl Into<Bool32>) -> Self {
        self.prefers_compact_vertex_output = value.into();
        self
    }
    #[inline]
    pub fn prefers_compact_primitive_output(mut self, value: impl Into<Bool32>) -> Self {
        self.prefers_compact_primitive_output = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawMeshTasksIndirectCommandEXT.html>"]
#[doc(alias = "VkDrawMeshTasksIndirectCommandEXT")]
pub struct DrawMeshTasksIndirectCommandEXT {
    pub group_count_x: u32,
    pub group_count_y: u32,
    pub group_count_z: u32,
}
unsafe impl Send for DrawMeshTasksIndirectCommandEXT {}
unsafe impl Sync for DrawMeshTasksIndirectCommandEXT {}
impl Default for DrawMeshTasksIndirectCommandEXT {
    fn default() -> Self {
        Self {
            group_count_x: Default::default(),
            group_count_y: Default::default(),
            group_count_z: Default::default(),
        }
    }
}
impl DrawMeshTasksIndirectCommandEXT {
    #[inline]
    pub fn group_count_x(mut self, value: u32) -> Self {
        self.group_count_x = value;
        self
    }
    #[inline]
    pub fn group_count_y(mut self, value: u32) -> Self {
        self.group_count_y = value;
        self
    }
    #[inline]
    pub fn group_count_z(mut self, value: u32) -> Self {
        self.group_count_z = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT")]
pub struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ycbcr2plane444_formats: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ycbcr2plane444_formats: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'a> {
    #[inline]
    pub fn ycbcr2plane444_formats(mut self, value: impl Into<Bool32>) -> Self {
        self.ycbcr2plane444_formats = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT")]
pub struct PhysicalDeviceFragmentDensityMap2FeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fragment_density_map_deferred: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentDensityMap2FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentDensityMap2FeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentDensityMap2FeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentDensityMap2FeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceFragmentDensityMap2FeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceFragmentDensityMap2FeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentDensityMap2FeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fragment_density_map_deferred: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentDensityMap2FeaturesEXT<'a> {
    #[inline]
    pub fn fragment_density_map_deferred(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_density_map_deferred = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentDensityMap2PropertiesEXT")]
pub struct PhysicalDeviceFragmentDensityMap2PropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub subsampled_loads: Bool32,
    pub subsampled_coarse_reconstruction_early_access: Bool32,
    pub max_subsampled_array_layers: u32,
    pub max_descriptor_set_subsampled_samplers: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentDensityMap2PropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentDensityMap2PropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentDensityMap2PropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentDensityMap2PropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceFragmentDensityMap2PropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentDensityMap2PropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            subsampled_loads: Default::default(),
            subsampled_coarse_reconstruction_early_access: Default::default(),
            max_subsampled_array_layers: Default::default(),
            max_descriptor_set_subsampled_samplers: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentDensityMap2PropertiesEXT<'a> {
    #[inline]
    pub fn subsampled_loads(mut self, value: impl Into<Bool32>) -> Self {
        self.subsampled_loads = value.into();
        self
    }
    #[inline]
    pub fn subsampled_coarse_reconstruction_early_access(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.subsampled_coarse_reconstruction_early_access = value.into();
        self
    }
    #[inline]
    pub fn max_subsampled_array_layers(mut self, value: u32) -> Self {
        self.max_subsampled_array_layers = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_subsampled_samplers(mut self, value: u32) -> Self {
        self.max_descriptor_set_subsampled_samplers = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyCommandTransformInfoQCOM.html>"]
#[doc(alias = "VkCopyCommandTransformInfoQCOM")]
pub struct CopyCommandTransformInfoQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub transform: SurfaceTransformFlagsKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyCommandTransformInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyCommandTransformInfoQCOM;
}
unsafe impl<'a> Send for CopyCommandTransformInfoQCOM<'a> {}
unsafe impl<'a> Sync for CopyCommandTransformInfoQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BufferImageCopy2<'b>> for CopyCommandTransformInfoQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageBlit2<'b>> for CopyCommandTransformInfoQCOM<'a> {}
impl<'a> Default for CopyCommandTransformInfoQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            transform: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyCommandTransformInfoQCOM<'a> {
    #[inline]
    pub fn transform(mut self, value: SurfaceTransformFlagsKHR) -> Self {
        self.transform = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR")]
pub struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub workgroup_memory_explicit_layout: Bool32,
    pub workgroup_memory_explicit_layout_scalar_block_layout: Bool32,
    pub workgroup_memory_explicit_layout8_bit_access: Bool32,
    pub workgroup_memory_explicit_layout16_bit_access: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            workgroup_memory_explicit_layout: Default::default(),
            workgroup_memory_explicit_layout_scalar_block_layout: Default::default(),
            workgroup_memory_explicit_layout8_bit_access: Default::default(),
            workgroup_memory_explicit_layout16_bit_access: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'a> {
    #[inline]
    pub fn workgroup_memory_explicit_layout(mut self, value: impl Into<Bool32>) -> Self {
        self.workgroup_memory_explicit_layout = value.into();
        self
    }
    #[inline]
    pub fn workgroup_memory_explicit_layout_scalar_block_layout(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.workgroup_memory_explicit_layout_scalar_block_layout = value.into();
        self
    }
    #[inline]
    pub fn workgroup_memory_explicit_layout8_bit_access(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.workgroup_memory_explicit_layout8_bit_access = value.into();
        self
    }
    #[inline]
    pub fn workgroup_memory_explicit_layout16_bit_access(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.workgroup_memory_explicit_layout16_bit_access = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageCompressionControlFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceImageCompressionControlFeaturesEXT")]
pub struct PhysicalDeviceImageCompressionControlFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_compression_control: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageCompressionControlFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceImageCompressionControlFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceImageCompressionControlFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageCompressionControlFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceImageCompressionControlFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceImageCompressionControlFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceImageCompressionControlFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_compression_control: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageCompressionControlFeaturesEXT<'a> {
    #[inline]
    pub fn image_compression_control(mut self, value: impl Into<Bool32>) -> Self {
        self.image_compression_control = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCompressionControlEXT.html>"]
#[doc(alias = "VkImageCompressionControlEXT")]
pub struct ImageCompressionControlEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: ImageCompressionFlagsEXT,
    pub(crate) compression_control_plane_count: u32,
    pub(crate) p_fixed_rate_flags: *const ImageCompressionFixedRateFlagsEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageCompressionControlEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageCompressionControlEXT;
}
unsafe impl<'a> Send for ImageCompressionControlEXT<'a> {}
unsafe impl<'a> Sync for ImageCompressionControlEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>> for ImageCompressionControlEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SwapchainCreateInfoKHR<'b>>
    for ImageCompressionControlEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceImageFormatInfo2<'b>>
    for ImageCompressionControlEXT<'a>
{
}
impl<'a> Default for ImageCompressionControlEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            compression_control_plane_count: Default::default(),
            p_fixed_rate_flags: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageCompressionControlEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: ImageCompressionFlagsEXT) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn fixed_rate_flags(
        mut self,
        p_fixed_rate_flags: impl AsSlice<'a, ImageCompressionFixedRateFlagsEXT>,
    ) -> Self {
        self.p_fixed_rate_flags = p_fixed_rate_flags.as_slice().as_ptr().cast();
        self.compression_control_plane_count = p_fixed_rate_flags.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCompressionPropertiesEXT.html>"]
#[doc(alias = "VkImageCompressionPropertiesEXT")]
pub struct ImageCompressionPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_compression_flags: ImageCompressionFlagsEXT,
    pub image_compression_fixed_rate_flags: ImageCompressionFixedRateFlagsEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageCompressionPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageCompressionPropertiesEXT;
}
unsafe impl<'a> Send for ImageCompressionPropertiesEXT<'a> {}
unsafe impl<'a> Sync for ImageCompressionPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageFormatProperties2<'b>>
    for ImageCompressionPropertiesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<SurfaceFormat2KHR<'b>>
    for ImageCompressionPropertiesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<SubresourceLayout2KHR<'b>>
    for ImageCompressionPropertiesEXT<'a>
{
}
impl<'a> Default for ImageCompressionPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_compression_flags: Default::default(),
            image_compression_fixed_rate_flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageCompressionPropertiesEXT<'a> {
    #[inline]
    pub fn image_compression_flags(mut self, value: ImageCompressionFlagsEXT) -> Self {
        self.image_compression_flags = value;
        self
    }
    #[inline]
    pub fn image_compression_fixed_rate_flags(
        mut self,
        value: ImageCompressionFixedRateFlagsEXT,
    ) -> Self {
        self.image_compression_fixed_rate_flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT")]
pub struct PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub attachment_feedback_loop_layout: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            attachment_feedback_loop_layout: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT<'a> {
    #[inline]
    pub fn attachment_feedback_loop_layout(mut self, value: impl Into<Bool32>) -> Self {
        self.attachment_feedback_loop_layout = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice4444FormatsFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDevice4444FormatsFeaturesEXT")]
pub struct PhysicalDevice4444FormatsFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub format_a4_r4_g4_b4: Bool32,
    pub format_a4_b4_g4_r4: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevice4444FormatsFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDevice4444FormatsFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDevice4444FormatsFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDevice4444FormatsFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevice4444FormatsFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevice4444FormatsFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDevice4444FormatsFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            format_a4_r4_g4_b4: Default::default(),
            format_a4_b4_g4_r4: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevice4444FormatsFeaturesEXT<'a> {
    #[inline]
    pub fn format_a4_r4_g4_b4(mut self, value: impl Into<Bool32>) -> Self {
        self.format_a4_r4_g4_b4 = value.into();
        self
    }
    #[inline]
    pub fn format_a4_b4_g4_r4(mut self, value: impl Into<Bool32>) -> Self {
        self.format_a4_b4_g4_r4 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFaultFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceFaultFeaturesEXT")]
pub struct PhysicalDeviceFaultFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_fault: Bool32,
    pub device_fault_vendor_binary: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFaultFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceFaultFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceFaultFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFaultFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceFaultFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceFaultFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceFaultFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_fault: Default::default(),
            device_fault_vendor_binary: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFaultFeaturesEXT<'a> {
    #[inline]
    pub fn device_fault(mut self, value: impl Into<Bool32>) -> Self {
        self.device_fault = value.into();
        self
    }
    #[inline]
    pub fn device_fault_vendor_binary(mut self, value: impl Into<Bool32>) -> Self {
        self.device_fault_vendor_binary = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceFaultCountsEXT.html>"]
#[doc(alias = "VkDeviceFaultCountsEXT")]
pub struct DeviceFaultCountsEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub address_info_count: u32,
    pub vendor_info_count: u32,
    pub vendor_binary_size: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceFaultCountsEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceFaultCountsEXT;
}
unsafe impl<'a> Send for DeviceFaultCountsEXT<'a> {}
unsafe impl<'a> Sync for DeviceFaultCountsEXT<'a> {}
impl<'a> Default for DeviceFaultCountsEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            address_info_count: Default::default(),
            vendor_info_count: Default::default(),
            vendor_binary_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceFaultCountsEXT<'a> {
    #[inline]
    pub fn address_info_count(mut self, value: u32) -> Self {
        self.address_info_count = value;
        self
    }
    #[inline]
    pub fn vendor_info_count(mut self, value: u32) -> Self {
        self.vendor_info_count = value;
        self
    }
    #[inline]
    pub fn vendor_binary_size(mut self, value: DeviceSize) -> Self {
        self.vendor_binary_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceFaultInfoEXT.html>"]
#[doc(alias = "VkDeviceFaultInfoEXT")]
pub struct DeviceFaultInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) description: [c_char; MAX_DESCRIPTION_SIZE as _],
    pub p_address_infos: *const DeviceFaultAddressInfoEXT,
    pub p_vendor_infos: *const DeviceFaultVendorInfoEXT,
    pub p_vendor_binary_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceFaultInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceFaultInfoEXT;
}
unsafe impl<'a> Send for DeviceFaultInfoEXT<'a> {}
unsafe impl<'a> Sync for DeviceFaultInfoEXT<'a> {}
impl<'a> Default for DeviceFaultInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            description: array::from_fn(|_| Default::default()),
            p_address_infos: ptr::null(),
            p_vendor_infos: ptr::null(),
            p_vendor_binary_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceFaultInfoEXT<'a> {
    #[inline]
    pub fn address_infos(mut self, value: Option<&'a DeviceFaultAddressInfoEXT>) -> Self {
        self.p_address_infos = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn vendor_infos(mut self, value: Option<&'a DeviceFaultVendorInfoEXT>) -> Self {
        self.p_vendor_infos = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn vendor_binary_data(mut self, value: VoidPtr) -> Self {
        self.p_vendor_binary_data = value;
        self
    }
    pub fn get_description(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.description) }
                .as_slice(),
        )
        .unwrap()
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceFaultAddressInfoEXT.html>"]
#[doc(alias = "VkDeviceFaultAddressInfoEXT")]
pub struct DeviceFaultAddressInfoEXT {
    pub address_type: DeviceFaultAddressTypeEXT,
    pub reported_address: DeviceAddress,
    pub address_precision: DeviceSize,
}
unsafe impl Send for DeviceFaultAddressInfoEXT {}
unsafe impl Sync for DeviceFaultAddressInfoEXT {}
impl Default for DeviceFaultAddressInfoEXT {
    fn default() -> Self {
        Self {
            address_type: DeviceFaultAddressTypeEXT::None,
            reported_address: Default::default(),
            address_precision: Default::default(),
        }
    }
}
impl DeviceFaultAddressInfoEXT {
    #[inline]
    pub fn address_type(mut self, value: DeviceFaultAddressTypeEXT) -> Self {
        self.address_type = value;
        self
    }
    #[inline]
    pub fn reported_address(mut self, value: DeviceAddress) -> Self {
        self.reported_address = value;
        self
    }
    #[inline]
    pub fn address_precision(mut self, value: DeviceSize) -> Self {
        self.address_precision = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceFaultVendorInfoEXT.html>"]
#[doc(alias = "VkDeviceFaultVendorInfoEXT")]
pub struct DeviceFaultVendorInfoEXT {
    pub(crate) description: [c_char; MAX_DESCRIPTION_SIZE as _],
    pub vendor_fault_code: u64,
    pub vendor_fault_data: u64,
}
unsafe impl Send for DeviceFaultVendorInfoEXT {}
unsafe impl Sync for DeviceFaultVendorInfoEXT {}
impl Default for DeviceFaultVendorInfoEXT {
    fn default() -> Self {
        Self {
            description: array::from_fn(|_| Default::default()),
            vendor_fault_code: Default::default(),
            vendor_fault_data: Default::default(),
        }
    }
}
impl DeviceFaultVendorInfoEXT {
    #[inline]
    pub fn vendor_fault_code(mut self, value: u64) -> Self {
        self.vendor_fault_code = value;
        self
    }
    #[inline]
    pub fn vendor_fault_data(mut self, value: u64) -> Self {
        self.vendor_fault_data = value;
        self
    }
    pub fn get_description(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.description) }
                .as_slice(),
        )
        .unwrap()
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceFaultVendorBinaryHeaderVersionOneEXT.html>"]
#[doc(alias = "VkDeviceFaultVendorBinaryHeaderVersionOneEXT")]
pub struct DeviceFaultVendorBinaryHeaderVersionOneEXT {
    pub header_size: u32,
    pub header_version: DeviceFaultVendorBinaryHeaderVersionEXT,
    pub vendor_id: u32,
    pub device_id: u32,
    pub driver_version: u32,
    pub pipeline_cache_uuid: [u8; UUID_SIZE as _],
    pub application_name_offset: u32,
    pub application_version: u32,
    pub engine_name_offset: u32,
    pub engine_version: u32,
    pub api_version: ApiVersion,
}
unsafe impl Send for DeviceFaultVendorBinaryHeaderVersionOneEXT {}
unsafe impl Sync for DeviceFaultVendorBinaryHeaderVersionOneEXT {}
impl Default for DeviceFaultVendorBinaryHeaderVersionOneEXT {
    fn default() -> Self {
        Self {
            header_size: Default::default(),
            header_version: DeviceFaultVendorBinaryHeaderVersionEXT::One,
            vendor_id: Default::default(),
            device_id: Default::default(),
            driver_version: Default::default(),
            pipeline_cache_uuid: array::from_fn(|_| Default::default()),
            application_name_offset: Default::default(),
            application_version: Default::default(),
            engine_name_offset: Default::default(),
            engine_version: Default::default(),
            api_version: Default::default(),
        }
    }
}
impl DeviceFaultVendorBinaryHeaderVersionOneEXT {
    #[inline]
    pub fn header_size(mut self, value: u32) -> Self {
        self.header_size = value;
        self
    }
    #[inline]
    pub fn header_version(mut self, value: DeviceFaultVendorBinaryHeaderVersionEXT) -> Self {
        self.header_version = value;
        self
    }
    #[inline]
    pub fn vendor_id(mut self, value: u32) -> Self {
        self.vendor_id = value;
        self
    }
    #[inline]
    pub fn device_id(mut self, value: u32) -> Self {
        self.device_id = value;
        self
    }
    #[inline]
    pub fn driver_version(mut self, value: u32) -> Self {
        self.driver_version = value;
        self
    }
    #[inline]
    pub fn pipeline_cache_uuid(mut self, value: [u8; UUID_SIZE as _]) -> Self {
        self.pipeline_cache_uuid = value;
        self
    }
    #[inline]
    pub fn application_name_offset(mut self, value: u32) -> Self {
        self.application_name_offset = value;
        self
    }
    #[inline]
    pub fn application_version(mut self, value: u32) -> Self {
        self.application_version = value;
        self
    }
    #[inline]
    pub fn engine_name_offset(mut self, value: u32) -> Self {
        self.engine_name_offset = value;
        self
    }
    #[inline]
    pub fn engine_version(mut self, value: u32) -> Self {
        self.engine_version = value;
        self
    }
    #[inline]
    pub fn api_version(mut self, value: ApiVersion) -> Self {
        self.api_version = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT")]
pub struct PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub format_rgba10x6_without_ycb_cr_sampler: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceRgba10X6FormatsFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            format_rgba10x6_without_ycb_cr_sampler: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'a> {
    #[inline]
    pub fn format_rgba10x6_without_ycb_cr_sampler(mut self, value: impl Into<Bool32>) -> Self {
        self.format_rgba10x6_without_ycb_cr_sampler = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDirectFBSurfaceCreateInfoEXT.html>"]
#[doc(alias = "VkDirectFBSurfaceCreateInfoEXT")]
pub struct DirectFBSurfaceCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub dfb: *const VoidPtr,
    pub surface: *const VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DirectFBSurfaceCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DirectfbSurfaceCreateInfoEXT;
}
unsafe impl<'a> Send for DirectFBSurfaceCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for DirectFBSurfaceCreateInfoEXT<'a> {}
impl<'a> Default for DirectFBSurfaceCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            dfb: ptr::null(),
            surface: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DirectFBSurfaceCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn dfb(mut self, value: &'a VoidPtr) -> Self {
        self.dfb = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn surface(mut self, value: &'a VoidPtr) -> Self {
        self.surface = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT")]
pub struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub vertex_input_dynamic_state: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceVertexInputDynamicStateFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            vertex_input_dynamic_state: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'a> {
    #[inline]
    pub fn vertex_input_dynamic_state(mut self, value: impl Into<Bool32>) -> Self {
        self.vertex_input_dynamic_state = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDescription2EXT.html>"]
#[doc(alias = "VkVertexInputBindingDescription2EXT")]
pub struct VertexInputBindingDescription2EXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub binding: u32,
    pub stride: u32,
    pub input_rate: VertexInputRate,
    pub divisor: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for VertexInputBindingDescription2EXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VertexInputBindingDescription2EXT;
}
unsafe impl<'a> Send for VertexInputBindingDescription2EXT<'a> {}
unsafe impl<'a> Sync for VertexInputBindingDescription2EXT<'a> {}
impl<'a> Default for VertexInputBindingDescription2EXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            binding: Default::default(),
            stride: Default::default(),
            input_rate: VertexInputRate::Vertex,
            divisor: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> VertexInputBindingDescription2EXT<'a> {
    #[inline]
    pub fn binding(mut self, value: u32) -> Self {
        self.binding = value;
        self
    }
    #[inline]
    pub fn stride(mut self, value: u32) -> Self {
        self.stride = value;
        self
    }
    #[inline]
    pub fn input_rate(mut self, value: VertexInputRate) -> Self {
        self.input_rate = value;
        self
    }
    #[inline]
    pub fn divisor(mut self, value: u32) -> Self {
        self.divisor = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription2EXT.html>"]
#[doc(alias = "VkVertexInputAttributeDescription2EXT")]
pub struct VertexInputAttributeDescription2EXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub location: u32,
    pub binding: u32,
    pub format: Format,
    pub offset: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for VertexInputAttributeDescription2EXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::VertexInputAttributeDescription2EXT;
}
unsafe impl<'a> Send for VertexInputAttributeDescription2EXT<'a> {}
unsafe impl<'a> Sync for VertexInputAttributeDescription2EXT<'a> {}
impl<'a> Default for VertexInputAttributeDescription2EXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            location: Default::default(),
            binding: Default::default(),
            format: Format::Undefined,
            offset: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> VertexInputAttributeDescription2EXT<'a> {
    #[inline]
    pub fn location(mut self, value: u32) -> Self {
        self.location = value;
        self
    }
    #[inline]
    pub fn binding(mut self, value: u32) -> Self {
        self.binding = value;
        self
    }
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn offset(mut self, value: u32) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDrmPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceDrmPropertiesEXT")]
pub struct PhysicalDeviceDrmPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub has_primary: Bool32,
    pub has_render: Bool32,
    pub primary_major: i64,
    pub primary_minor: i64,
    pub render_major: i64,
    pub render_minor: i64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDrmPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceDrmPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceDrmPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDrmPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceDrmPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceDrmPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            has_primary: Default::default(),
            has_render: Default::default(),
            primary_major: Default::default(),
            primary_minor: Default::default(),
            render_major: Default::default(),
            render_minor: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDrmPropertiesEXT<'a> {
    #[inline]
    pub fn has_primary(mut self, value: impl Into<Bool32>) -> Self {
        self.has_primary = value.into();
        self
    }
    #[inline]
    pub fn has_render(mut self, value: impl Into<Bool32>) -> Self {
        self.has_render = value.into();
        self
    }
    #[inline]
    pub fn primary_major(mut self, value: i64) -> Self {
        self.primary_major = value;
        self
    }
    #[inline]
    pub fn primary_minor(mut self, value: i64) -> Self {
        self.primary_minor = value;
        self
    }
    #[inline]
    pub fn render_major(mut self, value: i64) -> Self {
        self.render_major = value;
        self
    }
    #[inline]
    pub fn render_minor(mut self, value: i64) -> Self {
        self.render_minor = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAddressBindingReportFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceAddressBindingReportFeaturesEXT")]
pub struct PhysicalDeviceAddressBindingReportFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub report_address_binding: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceAddressBindingReportFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceAddressBindingReportFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceAddressBindingReportFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceAddressBindingReportFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceAddressBindingReportFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceAddressBindingReportFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceAddressBindingReportFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            report_address_binding: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceAddressBindingReportFeaturesEXT<'a> {
    #[inline]
    pub fn report_address_binding(mut self, value: impl Into<Bool32>) -> Self {
        self.report_address_binding = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceAddressBindingCallbackDataEXT.html>"]
#[doc(alias = "VkDeviceAddressBindingCallbackDataEXT")]
pub struct DeviceAddressBindingCallbackDataEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: DeviceAddressBindingFlagsEXT,
    pub base_address: DeviceAddress,
    pub size: DeviceSize,
    pub binding_type: DeviceAddressBindingTypeEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceAddressBindingCallbackDataEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceAddressBindingCallbackDataEXT;
}
unsafe impl<'a> Send for DeviceAddressBindingCallbackDataEXT<'a> {}
unsafe impl<'a> Sync for DeviceAddressBindingCallbackDataEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DebugUtilsMessengerCallbackDataEXT<'b>>
    for DeviceAddressBindingCallbackDataEXT<'a>
{
}
impl<'a> Default for DeviceAddressBindingCallbackDataEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            base_address: Default::default(),
            size: Default::default(),
            binding_type: DeviceAddressBindingTypeEXT::Bind,
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceAddressBindingCallbackDataEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: DeviceAddressBindingFlagsEXT) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn base_address(mut self, value: DeviceAddress) -> Self {
        self.base_address = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn binding_type(mut self, value: DeviceAddressBindingTypeEXT) -> Self {
        self.binding_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthClipControlFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceDepthClipControlFeaturesEXT")]
pub struct PhysicalDeviceDepthClipControlFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub depth_clip_control: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDepthClipControlFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceDepthClipControlFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceDepthClipControlFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDepthClipControlFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDepthClipControlFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDepthClipControlFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceDepthClipControlFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            depth_clip_control: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDepthClipControlFeaturesEXT<'a> {
    #[inline]
    pub fn depth_clip_control(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_clip_control = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportDepthClipControlCreateInfoEXT.html>"]
#[doc(alias = "VkPipelineViewportDepthClipControlCreateInfoEXT")]
pub struct PipelineViewportDepthClipControlCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub negative_one_to_one: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineViewportDepthClipControlCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineViewportDepthClipControlCreateInfoEXT;
}
unsafe impl<'a> Send for PipelineViewportDepthClipControlCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for PipelineViewportDepthClipControlCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineViewportStateCreateInfo<'b>>
    for PipelineViewportDepthClipControlCreateInfoEXT<'a>
{
}
impl<'a> Default for PipelineViewportDepthClipControlCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            negative_one_to_one: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineViewportDepthClipControlCreateInfoEXT<'a> {
    #[inline]
    pub fn negative_one_to_one(mut self, value: impl Into<Bool32>) -> Self {
        self.negative_one_to_one = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT")]
pub struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub primitive_topology_list_restart: Bool32,
    pub primitive_topology_patch_list_restart: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            primitive_topology_list_restart: Default::default(),
            primitive_topology_patch_list_restart: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'a> {
    #[inline]
    pub fn primitive_topology_list_restart(mut self, value: impl Into<Bool32>) -> Self {
        self.primitive_topology_list_restart = value.into();
        self
    }
    #[inline]
    pub fn primitive_topology_patch_list_restart(mut self, value: impl Into<Bool32>) -> Self {
        self.primitive_topology_patch_list_restart = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryZirconHandleInfoFUCHSIA.html>"]
#[doc(alias = "VkImportMemoryZirconHandleInfoFUCHSIA")]
pub struct ImportMemoryZirconHandleInfoFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub handle: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportMemoryZirconHandleInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportMemoryZirconHandleInfoFUCHSIA;
}
unsafe impl<'a> Send for ImportMemoryZirconHandleInfoFUCHSIA<'a> {}
unsafe impl<'a> Sync for ImportMemoryZirconHandleInfoFUCHSIA<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>>
    for ImportMemoryZirconHandleInfoFUCHSIA<'a>
{
}
impl<'a> Default for ImportMemoryZirconHandleInfoFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            handle_type: Default::default(),
            handle: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportMemoryZirconHandleInfoFUCHSIA<'a> {
    #[inline]
    pub fn handle_type(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn handle(mut self, value: VoidPtr) -> Self {
        self.handle = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryZirconHandlePropertiesFUCHSIA.html>"]
#[doc(alias = "VkMemoryZirconHandlePropertiesFUCHSIA")]
pub struct MemoryZirconHandlePropertiesFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory_type_bits: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryZirconHandlePropertiesFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryZirconHandlePropertiesFUCHSIA;
}
unsafe impl<'a> Send for MemoryZirconHandlePropertiesFUCHSIA<'a> {}
unsafe impl<'a> Sync for MemoryZirconHandlePropertiesFUCHSIA<'a> {}
impl<'a> Default for MemoryZirconHandlePropertiesFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory_type_bits: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryZirconHandlePropertiesFUCHSIA<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, value: u32) -> Self {
        self.memory_type_bits = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetZirconHandleInfoFUCHSIA.html>"]
#[doc(alias = "VkMemoryGetZirconHandleInfoFUCHSIA")]
pub struct MemoryGetZirconHandleInfoFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory: Option<DeviceMemory>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryGetZirconHandleInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryGetZirconHandleInfoFUCHSIA;
}
unsafe impl<'a> Send for MemoryGetZirconHandleInfoFUCHSIA<'a> {}
unsafe impl<'a> Sync for MemoryGetZirconHandleInfoFUCHSIA<'a> {}
impl<'a> Default for MemoryGetZirconHandleInfoFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory: Default::default(),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryGetZirconHandleInfoFUCHSIA<'a> {
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportSemaphoreZirconHandleInfoFUCHSIA.html>"]
#[doc(alias = "VkImportSemaphoreZirconHandleInfoFUCHSIA")]
pub struct ImportSemaphoreZirconHandleInfoFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub semaphore: Option<Semaphore>,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub zircon_handle: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportSemaphoreZirconHandleInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportSemaphoreZirconHandleInfoFUCHSIA;
}
unsafe impl<'a> Send for ImportSemaphoreZirconHandleInfoFUCHSIA<'a> {}
unsafe impl<'a> Sync for ImportSemaphoreZirconHandleInfoFUCHSIA<'a> {}
impl<'a> Default for ImportSemaphoreZirconHandleInfoFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            semaphore: Default::default(),
            flags: Default::default(),
            handle_type: Default::default(),
            zircon_handle: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportSemaphoreZirconHandleInfoFUCHSIA<'a> {
    #[inline]
    pub fn semaphore(mut self, value: &'a Semaphore) -> Self {
        self.semaphore = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn flags(mut self, value: SemaphoreImportFlags) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn zircon_handle(mut self, value: VoidPtr) -> Self {
        self.zircon_handle = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreGetZirconHandleInfoFUCHSIA.html>"]
#[doc(alias = "VkSemaphoreGetZirconHandleInfoFUCHSIA")]
pub struct SemaphoreGetZirconHandleInfoFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub semaphore: Option<Semaphore>,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SemaphoreGetZirconHandleInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SemaphoreGetZirconHandleInfoFUCHSIA;
}
unsafe impl<'a> Send for SemaphoreGetZirconHandleInfoFUCHSIA<'a> {}
unsafe impl<'a> Sync for SemaphoreGetZirconHandleInfoFUCHSIA<'a> {}
impl<'a> Default for SemaphoreGetZirconHandleInfoFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            semaphore: Default::default(),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SemaphoreGetZirconHandleInfoFUCHSIA<'a> {
    #[inline]
    pub fn semaphore(mut self, value: &'a Semaphore) -> Self {
        self.semaphore = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionCreateInfoFUCHSIA.html>"]
#[doc(alias = "VkBufferCollectionCreateInfoFUCHSIA")]
pub struct BufferCollectionCreateInfoFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub collection_token: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferCollectionCreateInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferCollectionCreateInfoFUCHSIA;
}
unsafe impl<'a> Send for BufferCollectionCreateInfoFUCHSIA<'a> {}
unsafe impl<'a> Sync for BufferCollectionCreateInfoFUCHSIA<'a> {}
impl<'a> Default for BufferCollectionCreateInfoFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            collection_token: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferCollectionCreateInfoFUCHSIA<'a> {
    #[inline]
    pub fn collection_token(mut self, value: VoidPtr) -> Self {
        self.collection_token = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryBufferCollectionFUCHSIA.html>"]
#[doc(alias = "VkImportMemoryBufferCollectionFUCHSIA")]
pub struct ImportMemoryBufferCollectionFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub collection: Option<BufferCollectionFUCHSIA>,
    pub index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportMemoryBufferCollectionFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportMemoryBufferCollectionFUCHSIA;
}
unsafe impl<'a> Send for ImportMemoryBufferCollectionFUCHSIA<'a> {}
unsafe impl<'a> Sync for ImportMemoryBufferCollectionFUCHSIA<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>>
    for ImportMemoryBufferCollectionFUCHSIA<'a>
{
}
impl<'a> Default for ImportMemoryBufferCollectionFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            collection: Default::default(),
            index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportMemoryBufferCollectionFUCHSIA<'a> {
    #[inline]
    pub fn collection(mut self, value: &'a BufferCollectionFUCHSIA) -> Self {
        self.collection = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn index(mut self, value: u32) -> Self {
        self.index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionImageCreateInfoFUCHSIA.html>"]
#[doc(alias = "VkBufferCollectionImageCreateInfoFUCHSIA")]
pub struct BufferCollectionImageCreateInfoFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub collection: Option<BufferCollectionFUCHSIA>,
    pub index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferCollectionImageCreateInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferCollectionImageCreateInfoFUCHSIA;
}
unsafe impl<'a> Send for BufferCollectionImageCreateInfoFUCHSIA<'a> {}
unsafe impl<'a> Sync for BufferCollectionImageCreateInfoFUCHSIA<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>>
    for BufferCollectionImageCreateInfoFUCHSIA<'a>
{
}
impl<'a> Default for BufferCollectionImageCreateInfoFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            collection: Default::default(),
            index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferCollectionImageCreateInfoFUCHSIA<'a> {
    #[inline]
    pub fn collection(mut self, value: &'a BufferCollectionFUCHSIA) -> Self {
        self.collection = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn index(mut self, value: u32) -> Self {
        self.index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferConstraintsInfoFUCHSIA.html>"]
#[doc(alias = "VkBufferConstraintsInfoFUCHSIA")]
pub struct BufferConstraintsInfoFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub create_info: BufferCreateInfo<'a>,
    pub required_format_features: FormatFeatureFlags,
    pub buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferConstraintsInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferConstraintsInfoFUCHSIA;
}
unsafe impl<'a> Send for BufferConstraintsInfoFUCHSIA<'a> {}
unsafe impl<'a> Sync for BufferConstraintsInfoFUCHSIA<'a> {}
impl<'a> Default for BufferConstraintsInfoFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            create_info: Default::default(),
            required_format_features: Default::default(),
            buffer_collection_constraints: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferConstraintsInfoFUCHSIA<'a> {
    #[inline]
    pub fn create_info(mut self, value: BufferCreateInfo<'a>) -> Self {
        self.create_info = value;
        self
    }
    #[inline]
    pub fn required_format_features(mut self, value: FormatFeatureFlags) -> Self {
        self.required_format_features = value;
        self
    }
    #[inline]
    pub fn buffer_collection_constraints(
        mut self,
        value: BufferCollectionConstraintsInfoFUCHSIA<'a>,
    ) -> Self {
        self.buffer_collection_constraints = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionBufferCreateInfoFUCHSIA.html>"]
#[doc(alias = "VkBufferCollectionBufferCreateInfoFUCHSIA")]
pub struct BufferCollectionBufferCreateInfoFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub collection: Option<BufferCollectionFUCHSIA>,
    pub index: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferCollectionBufferCreateInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferCollectionBufferCreateInfoFUCHSIA;
}
unsafe impl<'a> Send for BufferCollectionBufferCreateInfoFUCHSIA<'a> {}
unsafe impl<'a> Sync for BufferCollectionBufferCreateInfoFUCHSIA<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BufferCreateInfo<'b>>
    for BufferCollectionBufferCreateInfoFUCHSIA<'a>
{
}
impl<'a> Default for BufferCollectionBufferCreateInfoFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            collection: Default::default(),
            index: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferCollectionBufferCreateInfoFUCHSIA<'a> {
    #[inline]
    pub fn collection(mut self, value: &'a BufferCollectionFUCHSIA) -> Self {
        self.collection = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn index(mut self, value: u32) -> Self {
        self.index = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionPropertiesFUCHSIA.html>"]
#[doc(alias = "VkBufferCollectionPropertiesFUCHSIA")]
pub struct BufferCollectionPropertiesFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory_type_bits: u32,
    pub buffer_count: u32,
    pub create_info_index: u32,
    pub sysmem_pixel_format: u64,
    pub format_features: FormatFeatureFlags,
    pub sysmem_color_space_index: SysmemColorSpaceFUCHSIA<'a>,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_xchroma_offset: ChromaLocation,
    pub suggested_ychroma_offset: ChromaLocation,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferCollectionPropertiesFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferCollectionPropertiesFUCHSIA;
}
unsafe impl<'a> Send for BufferCollectionPropertiesFUCHSIA<'a> {}
unsafe impl<'a> Sync for BufferCollectionPropertiesFUCHSIA<'a> {}
impl<'a> Default for BufferCollectionPropertiesFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory_type_bits: Default::default(),
            buffer_count: Default::default(),
            create_info_index: Default::default(),
            sysmem_pixel_format: Default::default(),
            format_features: Default::default(),
            sysmem_color_space_index: Default::default(),
            sampler_ycbcr_conversion_components: Default::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::RgbIdentity,
            suggested_ycbcr_range: SamplerYcbcrRange::ItuFull,
            suggested_xchroma_offset: ChromaLocation::CositedEven,
            suggested_ychroma_offset: ChromaLocation::CositedEven,
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferCollectionPropertiesFUCHSIA<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, value: u32) -> Self {
        self.memory_type_bits = value;
        self
    }
    #[inline]
    pub fn buffer_count(mut self, value: u32) -> Self {
        self.buffer_count = value;
        self
    }
    #[inline]
    pub fn create_info_index(mut self, value: u32) -> Self {
        self.create_info_index = value;
        self
    }
    #[inline]
    pub fn sysmem_pixel_format(mut self, value: u64) -> Self {
        self.sysmem_pixel_format = value;
        self
    }
    #[inline]
    pub fn format_features(mut self, value: FormatFeatureFlags) -> Self {
        self.format_features = value;
        self
    }
    #[inline]
    pub fn sysmem_color_space_index(mut self, value: SysmemColorSpaceFUCHSIA<'a>) -> Self {
        self.sysmem_color_space_index = value;
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion_components(mut self, value: ComponentMapping) -> Self {
        self.sampler_ycbcr_conversion_components = value;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_model(mut self, value: SamplerYcbcrModelConversion) -> Self {
        self.suggested_ycbcr_model = value;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_range(mut self, value: SamplerYcbcrRange) -> Self {
        self.suggested_ycbcr_range = value;
        self
    }
    #[inline]
    pub fn suggested_xchroma_offset(mut self, value: ChromaLocation) -> Self {
        self.suggested_xchroma_offset = value;
        self
    }
    #[inline]
    pub fn suggested_ychroma_offset(mut self, value: ChromaLocation) -> Self {
        self.suggested_ychroma_offset = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSysmemColorSpaceFUCHSIA.html>"]
#[doc(alias = "VkSysmemColorSpaceFUCHSIA")]
pub struct SysmemColorSpaceFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub color_space: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SysmemColorSpaceFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SysmemColorSpaceFUCHSIA;
}
unsafe impl<'a> Send for SysmemColorSpaceFUCHSIA<'a> {}
unsafe impl<'a> Sync for SysmemColorSpaceFUCHSIA<'a> {}
impl<'a> Default for SysmemColorSpaceFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            color_space: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SysmemColorSpaceFUCHSIA<'a> {
    #[inline]
    pub fn color_space(mut self, value: u32) -> Self {
        self.color_space = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageConstraintsInfoFUCHSIA.html>"]
#[doc(alias = "VkImageConstraintsInfoFUCHSIA")]
pub struct ImageConstraintsInfoFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) format_constraints_count: u32,
    pub(crate) p_format_constraints: *const ImageFormatConstraintsInfoFUCHSIA<'a>,
    pub buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA<'a>,
    pub flags: ImageConstraintsInfoFlagsFUCHSIA,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageConstraintsInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageConstraintsInfoFUCHSIA;
}
unsafe impl<'a> Send for ImageConstraintsInfoFUCHSIA<'a> {}
unsafe impl<'a> Sync for ImageConstraintsInfoFUCHSIA<'a> {}
impl<'a> Default for ImageConstraintsInfoFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            format_constraints_count: Default::default(),
            p_format_constraints: ptr::null(),
            buffer_collection_constraints: Default::default(),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageConstraintsInfoFUCHSIA<'a> {
    #[inline]
    pub fn buffer_collection_constraints(
        mut self,
        value: BufferCollectionConstraintsInfoFUCHSIA<'a>,
    ) -> Self {
        self.buffer_collection_constraints = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: ImageConstraintsInfoFlagsFUCHSIA) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn format_constraints(
        mut self,
        p_format_constraints: impl AsSlice<'a, ImageFormatConstraintsInfoFUCHSIA<'a>>,
    ) -> Self {
        self.p_format_constraints = p_format_constraints.as_slice().as_ptr().cast();
        self.format_constraints_count = p_format_constraints.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatConstraintsInfoFUCHSIA.html>"]
#[doc(alias = "VkImageFormatConstraintsInfoFUCHSIA")]
pub struct ImageFormatConstraintsInfoFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_create_info: ImageCreateInfo<'a>,
    pub required_format_features: FormatFeatureFlags,
    pub flags: u32,
    pub sysmem_pixel_format: u64,
    pub(crate) color_space_count: u32,
    pub(crate) p_color_spaces: *const SysmemColorSpaceFUCHSIA<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageFormatConstraintsInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageFormatConstraintsInfoFUCHSIA;
}
unsafe impl<'a> Send for ImageFormatConstraintsInfoFUCHSIA<'a> {}
unsafe impl<'a> Sync for ImageFormatConstraintsInfoFUCHSIA<'a> {}
impl<'a> Default for ImageFormatConstraintsInfoFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_create_info: Default::default(),
            required_format_features: Default::default(),
            flags: Default::default(),
            sysmem_pixel_format: Default::default(),
            color_space_count: Default::default(),
            p_color_spaces: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageFormatConstraintsInfoFUCHSIA<'a> {
    #[inline]
    pub fn image_create_info(mut self, value: ImageCreateInfo<'a>) -> Self {
        self.image_create_info = value;
        self
    }
    #[inline]
    pub fn required_format_features(mut self, value: FormatFeatureFlags) -> Self {
        self.required_format_features = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn sysmem_pixel_format(mut self, value: u64) -> Self {
        self.sysmem_pixel_format = value;
        self
    }
    #[inline]
    pub fn color_spaces(
        mut self,
        p_color_spaces: impl AsSlice<'a, SysmemColorSpaceFUCHSIA<'a>>,
    ) -> Self {
        self.p_color_spaces = p_color_spaces.as_slice().as_ptr().cast();
        self.color_space_count = p_color_spaces.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionConstraintsInfoFUCHSIA.html>"]
#[doc(alias = "VkBufferCollectionConstraintsInfoFUCHSIA")]
pub struct BufferCollectionConstraintsInfoFUCHSIA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub min_buffer_count: u32,
    pub max_buffer_count: u32,
    pub min_buffer_count_for_camping: u32,
    pub min_buffer_count_for_dedicated_slack: u32,
    pub min_buffer_count_for_shared_slack: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferCollectionConstraintsInfoFUCHSIA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferCollectionConstraintsInfoFUCHSIA;
}
unsafe impl<'a> Send for BufferCollectionConstraintsInfoFUCHSIA<'a> {}
unsafe impl<'a> Sync for BufferCollectionConstraintsInfoFUCHSIA<'a> {}
impl<'a> Default for BufferCollectionConstraintsInfoFUCHSIA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            min_buffer_count: Default::default(),
            max_buffer_count: Default::default(),
            min_buffer_count_for_camping: Default::default(),
            min_buffer_count_for_dedicated_slack: Default::default(),
            min_buffer_count_for_shared_slack: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferCollectionConstraintsInfoFUCHSIA<'a> {
    #[inline]
    pub fn min_buffer_count(mut self, value: u32) -> Self {
        self.min_buffer_count = value;
        self
    }
    #[inline]
    pub fn max_buffer_count(mut self, value: u32) -> Self {
        self.max_buffer_count = value;
        self
    }
    #[inline]
    pub fn min_buffer_count_for_camping(mut self, value: u32) -> Self {
        self.min_buffer_count_for_camping = value;
        self
    }
    #[inline]
    pub fn min_buffer_count_for_dedicated_slack(mut self, value: u32) -> Self {
        self.min_buffer_count_for_dedicated_slack = value;
        self
    }
    #[inline]
    pub fn min_buffer_count_for_shared_slack(mut self, value: u32) -> Self {
        self.min_buffer_count_for_shared_slack = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassShadingPipelineCreateInfoHUAWEI.html>"]
#[doc(alias = "VkSubpassShadingPipelineCreateInfoHUAWEI")]
pub struct SubpassShadingPipelineCreateInfoHUAWEI<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub render_pass: Option<RenderPass>,
    pub subpass: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SubpassShadingPipelineCreateInfoHUAWEI<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SubpassShadingPipelineCreateInfoHUAWEI;
}
unsafe impl<'a> Send for SubpassShadingPipelineCreateInfoHUAWEI<'a> {}
unsafe impl<'a> Sync for SubpassShadingPipelineCreateInfoHUAWEI<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ComputePipelineCreateInfo<'b>>
    for SubpassShadingPipelineCreateInfoHUAWEI<'a>
{
}
impl<'a> Default for SubpassShadingPipelineCreateInfoHUAWEI<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            render_pass: Default::default(),
            subpass: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubpassShadingPipelineCreateInfoHUAWEI<'a> {
    #[inline]
    pub fn render_pass(mut self, value: &'a RenderPass) -> Self {
        self.render_pass = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn subpass(mut self, value: u32) -> Self {
        self.subpass = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.html>"]
#[doc(alias = "VkPhysicalDeviceSubpassShadingFeaturesHUAWEI")]
pub struct PhysicalDeviceSubpassShadingFeaturesHUAWEI<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub subpass_shading: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSubpassShadingFeaturesHUAWEI<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceSubpassShadingFeaturesHUAWEI;
}
unsafe impl<'a> Send for PhysicalDeviceSubpassShadingFeaturesHUAWEI<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSubpassShadingFeaturesHUAWEI<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceSubpassShadingFeaturesHUAWEI<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceSubpassShadingFeaturesHUAWEI<'a>
{
}
impl<'a> Default for PhysicalDeviceSubpassShadingFeaturesHUAWEI<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            subpass_shading: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSubpassShadingFeaturesHUAWEI<'a> {
    #[inline]
    pub fn subpass_shading(mut self, value: impl Into<Bool32>) -> Self {
        self.subpass_shading = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubpassShadingPropertiesHUAWEI.html>"]
#[doc(alias = "VkPhysicalDeviceSubpassShadingPropertiesHUAWEI")]
pub struct PhysicalDeviceSubpassShadingPropertiesHUAWEI<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_subpass_shading_workgroup_size_aspect_ratio: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSubpassShadingPropertiesHUAWEI<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceSubpassShadingPropertiesHUAWEI;
}
unsafe impl<'a> Send for PhysicalDeviceSubpassShadingPropertiesHUAWEI<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSubpassShadingPropertiesHUAWEI<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceSubpassShadingPropertiesHUAWEI<'a>
{
}
impl<'a> Default for PhysicalDeviceSubpassShadingPropertiesHUAWEI<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_subpass_shading_workgroup_size_aspect_ratio: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSubpassShadingPropertiesHUAWEI<'a> {
    #[inline]
    pub fn max_subpass_shading_workgroup_size_aspect_ratio(mut self, value: u32) -> Self {
        self.max_subpass_shading_workgroup_size_aspect_ratio = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.html>"]
#[doc(alias = "VkPhysicalDeviceInvocationMaskFeaturesHUAWEI")]
pub struct PhysicalDeviceInvocationMaskFeaturesHUAWEI<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub invocation_mask: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceInvocationMaskFeaturesHUAWEI<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceInvocationMaskFeaturesHUAWEI;
}
unsafe impl<'a> Send for PhysicalDeviceInvocationMaskFeaturesHUAWEI<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceInvocationMaskFeaturesHUAWEI<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceInvocationMaskFeaturesHUAWEI<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceInvocationMaskFeaturesHUAWEI<'a>
{
}
impl<'a> Default for PhysicalDeviceInvocationMaskFeaturesHUAWEI<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            invocation_mask: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceInvocationMaskFeaturesHUAWEI<'a> {
    #[inline]
    pub fn invocation_mask(mut self, value: impl Into<Bool32>) -> Self {
        self.invocation_mask = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRemoteAddressNV.html>"]
#[doc(alias = "VkRemoteAddressNV")]
pub type RemoteAddressNV = VoidPtr;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetRemoteAddressInfoNV.html>"]
#[doc(alias = "VkMemoryGetRemoteAddressInfoNV")]
pub struct MemoryGetRemoteAddressInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory: Option<DeviceMemory>,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MemoryGetRemoteAddressInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MemoryGetRemoteAddressInfoNV;
}
unsafe impl<'a> Send for MemoryGetRemoteAddressInfoNV<'a> {}
unsafe impl<'a> Sync for MemoryGetRemoteAddressInfoNV<'a> {}
impl<'a> Default for MemoryGetRemoteAddressInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory: Default::default(),
            handle_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MemoryGetRemoteAddressInfoNV<'a> {
    #[inline]
    pub fn memory(mut self, value: &'a DeviceMemory) -> Self {
        self.memory = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn handle_type(mut self, value: ExternalMemoryHandleTypeFlags) -> Self {
        self.handle_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceExternalMemoryRDMAFeaturesNV")]
pub struct PhysicalDeviceExternalMemoryRDMAFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub external_memory_rdma: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExternalMemoryRDMAFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceExternalMemoryRdmaFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceExternalMemoryRDMAFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExternalMemoryRDMAFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceExternalMemoryRDMAFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceExternalMemoryRDMAFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceExternalMemoryRDMAFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            external_memory_rdma: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExternalMemoryRDMAFeaturesNV<'a> {
    #[inline]
    pub fn external_memory_rdma(mut self, value: impl Into<Bool32>) -> Self {
        self.external_memory_rdma = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelinePropertiesIdentifierEXT.html>"]
#[doc(alias = "VkPipelinePropertiesIdentifierEXT")]
pub struct PipelinePropertiesIdentifierEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline_identifier: [u8; UUID_SIZE as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelinePropertiesIdentifierEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelinePropertiesIdentifierEXT;
}
unsafe impl<'a> Send for PipelinePropertiesIdentifierEXT<'a> {}
unsafe impl<'a> Sync for PipelinePropertiesIdentifierEXT<'a> {}
impl<'a> Default for PipelinePropertiesIdentifierEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline_identifier: array::from_fn(|_| Default::default()),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelinePropertiesIdentifierEXT<'a> {
    #[inline]
    pub fn pipeline_identifier(mut self, value: [u8; UUID_SIZE as _]) -> Self {
        self.pipeline_identifier = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelinePropertiesFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDevicePipelinePropertiesFeaturesEXT")]
pub struct PhysicalDevicePipelinePropertiesFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline_properties_identifier: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePipelinePropertiesFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePipelinePropertiesFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDevicePipelinePropertiesFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePipelinePropertiesFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePipelinePropertiesFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePipelinePropertiesFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDevicePipelinePropertiesFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline_properties_identifier: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePipelinePropertiesFeaturesEXT<'a> {
    #[inline]
    pub fn pipeline_properties_identifier(mut self, value: impl Into<Bool32>) -> Self {
        self.pipeline_properties_identifier = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFrameBoundaryFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceFrameBoundaryFeaturesEXT")]
pub struct PhysicalDeviceFrameBoundaryFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub frame_boundary: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFrameBoundaryFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceFrameBoundaryFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceFrameBoundaryFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFrameBoundaryFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceFrameBoundaryFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceFrameBoundaryFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceFrameBoundaryFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            frame_boundary: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFrameBoundaryFeaturesEXT<'a> {
    #[inline]
    pub fn frame_boundary(mut self, value: impl Into<Bool32>) -> Self {
        self.frame_boundary = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFrameBoundaryEXT.html>"]
#[doc(alias = "VkFrameBoundaryEXT")]
pub struct FrameBoundaryEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: FrameBoundaryFlagsEXT,
    pub frame_id: u64,
    pub image_count: u32,
    pub(crate) p_images: *const Image,
    pub buffer_count: u32,
    pub(crate) p_buffers: *const Buffer,
    pub tag_name: u64,
    pub tag_size: usize,
    pub(crate) p_tag: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for FrameBoundaryEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::FrameBoundaryEXT;
}
unsafe impl<'a> Send for FrameBoundaryEXT<'a> {}
unsafe impl<'a> Sync for FrameBoundaryEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo<'b>> for FrameBoundaryEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo2<'b>> for FrameBoundaryEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PresentInfoKHR<'b>> for FrameBoundaryEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BindSparseInfo<'b>> for FrameBoundaryEXT<'a> {}
impl<'a> Default for FrameBoundaryEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            frame_id: Default::default(),
            image_count: Default::default(),
            p_images: ptr::null(),
            buffer_count: Default::default(),
            p_buffers: ptr::null(),
            tag_name: Default::default(),
            tag_size: Default::default(),
            p_tag: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> FrameBoundaryEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: FrameBoundaryFlagsEXT) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn frame_id(mut self, value: u64) -> Self {
        self.frame_id = value;
        self
    }
    #[inline]
    pub fn image_count(mut self, value: u32) -> Self {
        self.image_count = value;
        self
    }
    #[inline]
    pub fn buffer_count(mut self, value: u32) -> Self {
        self.buffer_count = value;
        self
    }
    #[inline]
    pub fn tag_name(mut self, value: u64) -> Self {
        self.tag_name = value;
        self
    }
    #[inline]
    pub fn tag_size(mut self, value: usize) -> Self {
        self.tag_size = value;
        self
    }
    #[inline]
    pub fn images<V0: Alias<raw::Image> + 'a>(mut self, p_images: impl AsSlice<'a, V0>) -> Self {
        self.p_images = p_images.as_slice().as_ptr().cast();
        self.image_count = p_images.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn buffers<V0: Alias<raw::Buffer> + 'a>(mut self, p_buffers: impl AsSlice<'a, V0>) -> Self {
        self.p_buffers = p_buffers.as_slice().as_ptr().cast();
        self.buffer_count = p_buffers.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn tag(mut self, p_tag: impl AsSlice<'a, u8>) -> Self {
        self.p_tag = p_tag.as_slice().as_ptr().cast();
        self.tag_size = p_tag.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT")]
pub struct PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub multisampled_render_to_single_sampled: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure
    for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'a>
{
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            multisampled_render_to_single_sampled: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'a> {
    #[inline]
    pub fn multisampled_render_to_single_sampled(mut self, value: impl Into<Bool32>) -> Self {
        self.multisampled_render_to_single_sampled = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassResolvePerformanceQueryEXT.html>"]
#[doc(alias = "VkSubpassResolvePerformanceQueryEXT")]
pub struct SubpassResolvePerformanceQueryEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub optimal: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SubpassResolvePerformanceQueryEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SubpassResolvePerformanceQueryEXT;
}
unsafe impl<'a> Send for SubpassResolvePerformanceQueryEXT<'a> {}
unsafe impl<'a> Sync for SubpassResolvePerformanceQueryEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<FormatProperties2<'b>>
    for SubpassResolvePerformanceQueryEXT<'a>
{
}
impl<'a> Default for SubpassResolvePerformanceQueryEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            optimal: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubpassResolvePerformanceQueryEXT<'a> {
    #[inline]
    pub fn optimal(mut self, value: impl Into<Bool32>) -> Self {
        self.optimal = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultisampledRenderToSingleSampledInfoEXT.html>"]
#[doc(alias = "VkMultisampledRenderToSingleSampledInfoEXT")]
pub struct MultisampledRenderToSingleSampledInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub multisampled_render_to_single_sampled_enable: Bool32,
    pub rasterization_samples: SampleCountFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MultisampledRenderToSingleSampledInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MultisampledRenderToSingleSampledInfoEXT;
}
unsafe impl<'a> Send for MultisampledRenderToSingleSampledInfoEXT<'a> {}
unsafe impl<'a> Sync for MultisampledRenderToSingleSampledInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubpassDescription2<'b>>
    for MultisampledRenderToSingleSampledInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<RenderingInfo<'b>>
    for MultisampledRenderToSingleSampledInfoEXT<'a>
{
}
impl<'a> Default for MultisampledRenderToSingleSampledInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            multisampled_render_to_single_sampled_enable: Default::default(),
            rasterization_samples: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MultisampledRenderToSingleSampledInfoEXT<'a> {
    #[inline]
    pub fn multisampled_render_to_single_sampled_enable(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.multisampled_render_to_single_sampled_enable = value.into();
        self
    }
    #[inline]
    pub fn rasterization_samples(mut self, value: SampleCountFlags) -> Self {
        self.rasterization_samples = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceExtendedDynamicState2FeaturesEXT")]
pub struct PhysicalDeviceExtendedDynamicState2FeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub extended_dynamic_state2: Bool32,
    pub extended_dynamic_state2_logic_op: Bool32,
    pub extended_dynamic_state2_patch_control_points: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExtendedDynamicState2FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceExtendedDynamicState2FeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceExtendedDynamicState2FeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExtendedDynamicState2FeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceExtendedDynamicState2FeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceExtendedDynamicState2FeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceExtendedDynamicState2FeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            extended_dynamic_state2: Default::default(),
            extended_dynamic_state2_logic_op: Default::default(),
            extended_dynamic_state2_patch_control_points: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExtendedDynamicState2FeaturesEXT<'a> {
    #[inline]
    pub fn extended_dynamic_state2(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state2 = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state2_logic_op(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state2_logic_op = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state2_patch_control_points(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state2_patch_control_points = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkScreenSurfaceCreateInfoQNX.html>"]
#[doc(alias = "VkScreenSurfaceCreateInfoQNX")]
pub struct ScreenSurfaceCreateInfoQNX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub context: *const VoidPtr,
    pub window: *const VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ScreenSurfaceCreateInfoQNX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ScreenSurfaceCreateInfoQNX;
}
unsafe impl<'a> Send for ScreenSurfaceCreateInfoQNX<'a> {}
unsafe impl<'a> Sync for ScreenSurfaceCreateInfoQNX<'a> {}
impl<'a> Default for ScreenSurfaceCreateInfoQNX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            context: ptr::null(),
            window: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ScreenSurfaceCreateInfoQNX<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn context(mut self, value: &'a VoidPtr) -> Self {
        self.context = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn window(mut self, value: &'a VoidPtr) -> Self {
        self.window = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceColorWriteEnableFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceColorWriteEnableFeaturesEXT")]
pub struct PhysicalDeviceColorWriteEnableFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub color_write_enable: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceColorWriteEnableFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceColorWriteEnableFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceColorWriteEnableFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceColorWriteEnableFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceColorWriteEnableFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceColorWriteEnableFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceColorWriteEnableFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            color_write_enable: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceColorWriteEnableFeaturesEXT<'a> {
    #[inline]
    pub fn color_write_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.color_write_enable = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorWriteCreateInfoEXT.html>"]
#[doc(alias = "VkPipelineColorWriteCreateInfoEXT")]
pub struct PipelineColorWriteCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) attachment_count: u32,
    pub(crate) p_color_write_enables: *const Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineColorWriteCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineColorWriteCreateInfoEXT;
}
unsafe impl<'a> Send for PipelineColorWriteCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for PipelineColorWriteCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineColorBlendStateCreateInfo<'b>>
    for PipelineColorWriteCreateInfoEXT<'a>
{
}
impl<'a> Default for PipelineColorWriteCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            attachment_count: Default::default(),
            p_color_write_enables: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineColorWriteCreateInfoEXT<'a> {
    #[inline]
    pub fn color_write_enables(mut self, p_color_write_enables: impl AsSlice<'a, Bool32>) -> Self {
        self.p_color_write_enables = p_color_write_enables.as_slice().as_ptr().cast();
        self.attachment_count = p_color_write_enables.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT")]
pub struct PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub primitives_generated_query: Bool32,
    pub primitives_generated_query_with_rasterizer_discard: Bool32,
    pub primitives_generated_query_with_non_zero_streams: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            primitives_generated_query: Default::default(),
            primitives_generated_query_with_rasterizer_discard: Default::default(),
            primitives_generated_query_with_non_zero_streams: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'a> {
    #[inline]
    pub fn primitives_generated_query(mut self, value: impl Into<Bool32>) -> Self {
        self.primitives_generated_query = value.into();
        self
    }
    #[inline]
    pub fn primitives_generated_query_with_rasterizer_discard(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.primitives_generated_query_with_rasterizer_discard = value.into();
        self
    }
    #[inline]
    pub fn primitives_generated_query_with_non_zero_streams(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.primitives_generated_query_with_non_zero_streams = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR")]
pub struct PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ray_tracing_maintenance1: Bool32,
    pub ray_tracing_pipeline_trace_rays_indirect2: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceRayTracingMaintenance1FeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ray_tracing_maintenance1: Default::default(),
            ray_tracing_pipeline_trace_rays_indirect2: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'a> {
    #[inline]
    pub fn ray_tracing_maintenance1(mut self, value: impl Into<Bool32>) -> Self {
        self.ray_tracing_maintenance1 = value.into();
        self
    }
    #[inline]
    pub fn ray_tracing_pipeline_trace_rays_indirect2(mut self, value: impl Into<Bool32>) -> Self {
        self.ray_tracing_pipeline_trace_rays_indirect2 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTraceRaysIndirectCommand2KHR.html>"]
#[doc(alias = "VkTraceRaysIndirectCommand2KHR")]
pub struct TraceRaysIndirectCommand2KHR {
    pub raygen_shader_record_address: DeviceAddress,
    pub raygen_shader_record_size: DeviceSize,
    pub miss_shader_binding_table_address: DeviceAddress,
    pub miss_shader_binding_table_size: DeviceSize,
    pub miss_shader_binding_table_stride: DeviceSize,
    pub hit_shader_binding_table_address: DeviceAddress,
    pub hit_shader_binding_table_size: DeviceSize,
    pub hit_shader_binding_table_stride: DeviceSize,
    pub callable_shader_binding_table_address: DeviceAddress,
    pub callable_shader_binding_table_size: DeviceSize,
    pub callable_shader_binding_table_stride: DeviceSize,
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
unsafe impl Send for TraceRaysIndirectCommand2KHR {}
unsafe impl Sync for TraceRaysIndirectCommand2KHR {}
impl Default for TraceRaysIndirectCommand2KHR {
    fn default() -> Self {
        Self {
            raygen_shader_record_address: Default::default(),
            raygen_shader_record_size: Default::default(),
            miss_shader_binding_table_address: Default::default(),
            miss_shader_binding_table_size: Default::default(),
            miss_shader_binding_table_stride: Default::default(),
            hit_shader_binding_table_address: Default::default(),
            hit_shader_binding_table_size: Default::default(),
            hit_shader_binding_table_stride: Default::default(),
            callable_shader_binding_table_address: Default::default(),
            callable_shader_binding_table_size: Default::default(),
            callable_shader_binding_table_stride: Default::default(),
            width: Default::default(),
            height: Default::default(),
            depth: Default::default(),
        }
    }
}
impl TraceRaysIndirectCommand2KHR {
    #[inline]
    pub fn raygen_shader_record_address(mut self, value: DeviceAddress) -> Self {
        self.raygen_shader_record_address = value;
        self
    }
    #[inline]
    pub fn raygen_shader_record_size(mut self, value: DeviceSize) -> Self {
        self.raygen_shader_record_size = value;
        self
    }
    #[inline]
    pub fn miss_shader_binding_table_address(mut self, value: DeviceAddress) -> Self {
        self.miss_shader_binding_table_address = value;
        self
    }
    #[inline]
    pub fn miss_shader_binding_table_size(mut self, value: DeviceSize) -> Self {
        self.miss_shader_binding_table_size = value;
        self
    }
    #[inline]
    pub fn miss_shader_binding_table_stride(mut self, value: DeviceSize) -> Self {
        self.miss_shader_binding_table_stride = value;
        self
    }
    #[inline]
    pub fn hit_shader_binding_table_address(mut self, value: DeviceAddress) -> Self {
        self.hit_shader_binding_table_address = value;
        self
    }
    #[inline]
    pub fn hit_shader_binding_table_size(mut self, value: DeviceSize) -> Self {
        self.hit_shader_binding_table_size = value;
        self
    }
    #[inline]
    pub fn hit_shader_binding_table_stride(mut self, value: DeviceSize) -> Self {
        self.hit_shader_binding_table_stride = value;
        self
    }
    #[inline]
    pub fn callable_shader_binding_table_address(mut self, value: DeviceAddress) -> Self {
        self.callable_shader_binding_table_address = value;
        self
    }
    #[inline]
    pub fn callable_shader_binding_table_size(mut self, value: DeviceSize) -> Self {
        self.callable_shader_binding_table_size = value;
        self
    }
    #[inline]
    pub fn callable_shader_binding_table_stride(mut self, value: DeviceSize) -> Self {
        self.callable_shader_binding_table_stride = value;
        self
    }
    #[inline]
    pub fn width(mut self, value: u32) -> Self {
        self.width = value;
        self
    }
    #[inline]
    pub fn height(mut self, value: u32) -> Self {
        self.height = value;
        self
    }
    #[inline]
    pub fn depth(mut self, value: u32) -> Self {
        self.depth = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageViewMinLodFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceImageViewMinLodFeaturesEXT")]
pub struct PhysicalDeviceImageViewMinLodFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub min_lod: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageViewMinLodFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceImageViewMinLodFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceImageViewMinLodFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageViewMinLodFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceImageViewMinLodFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceImageViewMinLodFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceImageViewMinLodFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            min_lod: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageViewMinLodFeaturesEXT<'a> {
    #[inline]
    pub fn min_lod(mut self, value: impl Into<Bool32>) -> Self {
        self.min_lod = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewMinLodCreateInfoEXT.html>"]
#[doc(alias = "VkImageViewMinLodCreateInfoEXT")]
pub struct ImageViewMinLodCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub min_lod: f32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageViewMinLodCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageViewMinLodCreateInfoEXT;
}
unsafe impl<'a> Send for ImageViewMinLodCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for ImageViewMinLodCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageViewCreateInfo<'b>>
    for ImageViewMinLodCreateInfoEXT<'a>
{
}
impl<'a> Default for ImageViewMinLodCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            min_lod: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageViewMinLodCreateInfoEXT<'a> {
    #[inline]
    pub fn min_lod(mut self, value: f32) -> Self {
        self.min_lod = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiDrawFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceMultiDrawFeaturesEXT")]
pub struct PhysicalDeviceMultiDrawFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub multi_draw: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMultiDrawFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMultiDrawFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceMultiDrawFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMultiDrawFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMultiDrawFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMultiDrawFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceMultiDrawFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            multi_draw: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMultiDrawFeaturesEXT<'a> {
    #[inline]
    pub fn multi_draw(mut self, value: impl Into<Bool32>) -> Self {
        self.multi_draw = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiDrawPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceMultiDrawPropertiesEXT")]
pub struct PhysicalDeviceMultiDrawPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_multi_draw_count: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMultiDrawPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMultiDrawPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceMultiDrawPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMultiDrawPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceMultiDrawPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceMultiDrawPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_multi_draw_count: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMultiDrawPropertiesEXT<'a> {
    #[inline]
    pub fn max_multi_draw_count(mut self, value: u32) -> Self {
        self.max_multi_draw_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultiDrawInfoEXT.html>"]
#[doc(alias = "VkMultiDrawInfoEXT")]
pub struct MultiDrawInfoEXT {
    pub first_vertex: u32,
    pub vertex_count: u32,
}
unsafe impl Send for MultiDrawInfoEXT {}
unsafe impl Sync for MultiDrawInfoEXT {}
impl Default for MultiDrawInfoEXT {
    fn default() -> Self {
        Self {
            first_vertex: Default::default(),
            vertex_count: Default::default(),
        }
    }
}
impl MultiDrawInfoEXT {
    #[inline]
    pub fn first_vertex(mut self, value: u32) -> Self {
        self.first_vertex = value;
        self
    }
    #[inline]
    pub fn vertex_count(mut self, value: u32) -> Self {
        self.vertex_count = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultiDrawIndexedInfoEXT.html>"]
#[doc(alias = "VkMultiDrawIndexedInfoEXT")]
pub struct MultiDrawIndexedInfoEXT {
    pub first_index: u32,
    pub index_count: u32,
    pub vertex_offset: i32,
}
unsafe impl Send for MultiDrawIndexedInfoEXT {}
unsafe impl Sync for MultiDrawIndexedInfoEXT {}
impl Default for MultiDrawIndexedInfoEXT {
    fn default() -> Self {
        Self {
            first_index: Default::default(),
            index_count: Default::default(),
            vertex_offset: Default::default(),
        }
    }
}
impl MultiDrawIndexedInfoEXT {
    #[inline]
    pub fn first_index(mut self, value: u32) -> Self {
        self.first_index = value;
        self
    }
    #[inline]
    pub fn index_count(mut self, value: u32) -> Self {
        self.index_count = value;
        self
    }
    #[inline]
    pub fn vertex_offset(mut self, value: i32) -> Self {
        self.vertex_offset = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT")]
pub struct PhysicalDeviceImage2DViewOf3DFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image2_dview_of3_d: Bool32,
    pub sampler2_dview_of3_d: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImage2DViewOf3DFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceImage2DViewOf3DFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceImage2DViewOf3DFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImage2DViewOf3DFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceImage2DViewOf3DFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceImage2DViewOf3DFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceImage2DViewOf3DFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image2_dview_of3_d: Default::default(),
            sampler2_dview_of3_d: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImage2DViewOf3DFeaturesEXT<'a> {
    #[inline]
    pub fn image2_dview_of3_d(mut self, value: impl Into<Bool32>) -> Self {
        self.image2_dview_of3_d = value.into();
        self
    }
    #[inline]
    pub fn sampler2_dview_of3_d(mut self, value: impl Into<Bool32>) -> Self {
        self.sampler2_dview_of3_d = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTileImageFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceShaderTileImageFeaturesEXT")]
pub struct PhysicalDeviceShaderTileImageFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_tile_image_color_read_access: Bool32,
    pub shader_tile_image_depth_read_access: Bool32,
    pub shader_tile_image_stencil_read_access: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderTileImageFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderTileImageFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceShaderTileImageFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderTileImageFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderTileImageFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderTileImageFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderTileImageFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_tile_image_color_read_access: Default::default(),
            shader_tile_image_depth_read_access: Default::default(),
            shader_tile_image_stencil_read_access: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderTileImageFeaturesEXT<'a> {
    #[inline]
    pub fn shader_tile_image_color_read_access(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_tile_image_color_read_access = value.into();
        self
    }
    #[inline]
    pub fn shader_tile_image_depth_read_access(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_tile_image_depth_read_access = value.into();
        self
    }
    #[inline]
    pub fn shader_tile_image_stencil_read_access(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_tile_image_stencil_read_access = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTileImagePropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceShaderTileImagePropertiesEXT")]
pub struct PhysicalDeviceShaderTileImagePropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_tile_image_coherent_read_accelerated: Bool32,
    pub shader_tile_image_read_sample_from_pixel_rate_invocation: Bool32,
    pub shader_tile_image_read_from_helper_invocation: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderTileImagePropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderTileImagePropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceShaderTileImagePropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderTileImagePropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceShaderTileImagePropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderTileImagePropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_tile_image_coherent_read_accelerated: Default::default(),
            shader_tile_image_read_sample_from_pixel_rate_invocation: Default::default(),
            shader_tile_image_read_from_helper_invocation: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderTileImagePropertiesEXT<'a> {
    #[inline]
    pub fn shader_tile_image_coherent_read_accelerated(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_tile_image_coherent_read_accelerated = value.into();
        self
    }
    #[inline]
    pub fn shader_tile_image_read_sample_from_pixel_rate_invocation(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_tile_image_read_sample_from_pixel_rate_invocation = value.into();
        self
    }
    #[inline]
    pub fn shader_tile_image_read_from_helper_invocation(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.shader_tile_image_read_from_helper_invocation = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapBuildInfoEXT.html>"]
#[doc(alias = "VkMicromapBuildInfoEXT")]
pub struct MicromapBuildInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ty: MicromapTypeEXT,
    pub flags: BuildMicromapFlagsEXT,
    pub mode: BuildMicromapModeEXT,
    pub dst_micromap: Option<MicromapEXT>,
    pub usage_counts_count: u32,
    pub(crate) p_usage_counts: *const MicromapUsageEXT,
    pub(crate) pp_usage_counts: *const *const MicromapUsageEXT,
    pub data: DeviceOrHostAddressConstKHR,
    pub scratch_data: DeviceOrHostAddressKHR,
    pub triangle_array: DeviceOrHostAddressConstKHR,
    pub triangle_array_stride: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MicromapBuildInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MicromapBuildInfoEXT;
}
unsafe impl<'a> Send for MicromapBuildInfoEXT<'a> {}
unsafe impl<'a> Sync for MicromapBuildInfoEXT<'a> {}
impl<'a> Default for MicromapBuildInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ty: MicromapTypeEXT::OpacityMicromap,
            flags: Default::default(),
            mode: BuildMicromapModeEXT::Build,
            dst_micromap: Default::default(),
            usage_counts_count: Default::default(),
            p_usage_counts: ptr::null(),
            pp_usage_counts: ptr::null(),
            data: Default::default(),
            scratch_data: Default::default(),
            triangle_array: Default::default(),
            triangle_array_stride: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MicromapBuildInfoEXT<'a> {
    #[inline]
    pub fn ty(mut self, value: MicromapTypeEXT) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: BuildMicromapFlagsEXT) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn mode(mut self, value: BuildMicromapModeEXT) -> Self {
        self.mode = value;
        self
    }
    #[inline]
    pub fn dst_micromap(mut self, value: Option<&'a MicromapEXT>) -> Self {
        self.dst_micromap = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn usage_counts_count(mut self, value: u32) -> Self {
        self.usage_counts_count = value;
        self
    }
    #[inline]
    pub fn data(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.data = value;
        self
    }
    #[inline]
    pub fn scratch_data(mut self, value: DeviceOrHostAddressKHR) -> Self {
        self.scratch_data = value;
        self
    }
    #[inline]
    pub fn triangle_array(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.triangle_array = value;
        self
    }
    #[inline]
    pub fn triangle_array_stride(mut self, value: DeviceSize) -> Self {
        self.triangle_array_stride = value;
        self
    }
    #[inline]
    pub fn usage_counts(
        mut self,
        p_usage_counts: Option<impl AsSlice<'a, MicromapUsageEXT>>,
        pp_usage_counts: Option<impl AsSlice<'a, &'a MicromapUsageEXT>>,
    ) -> Self {
        self.p_usage_counts = p_usage_counts
            .map(|p| p.as_slice().as_ptr().cast())
            .unwrap_or(ptr::null());
        self.pp_usage_counts = pp_usage_counts
            .map(|p| p.as_slice().as_ptr().cast())
            .unwrap_or(ptr::null());
        self.usage_counts_count = p_usage_counts
            .map(|p| p.as_slice().len())
            .unwrap_or_default() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapUsageEXT.html>"]
#[doc(alias = "VkMicromapUsageEXT")]
pub struct MicromapUsageEXT {
    pub count: u32,
    pub subdivision_level: u32,
    pub format: u32,
}
unsafe impl Send for MicromapUsageEXT {}
unsafe impl Sync for MicromapUsageEXT {}
impl Default for MicromapUsageEXT {
    fn default() -> Self {
        Self {
            count: Default::default(),
            subdivision_level: Default::default(),
            format: Default::default(),
        }
    }
}
impl MicromapUsageEXT {
    #[inline]
    pub fn count(mut self, value: u32) -> Self {
        self.count = value;
        self
    }
    #[inline]
    pub fn subdivision_level(mut self, value: u32) -> Self {
        self.subdivision_level = value;
        self
    }
    #[inline]
    pub fn format(mut self, value: u32) -> Self {
        self.format = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapCreateInfoEXT.html>"]
#[doc(alias = "VkMicromapCreateInfoEXT")]
pub struct MicromapCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub create_flags: MicromapCreateFlagsEXT,
    pub buffer: Option<Buffer>,
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub ty: MicromapTypeEXT,
    pub device_address: DeviceAddress,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MicromapCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MicromapCreateInfoEXT;
}
unsafe impl<'a> Send for MicromapCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for MicromapCreateInfoEXT<'a> {}
impl<'a> Default for MicromapCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            create_flags: Default::default(),
            buffer: Default::default(),
            offset: Default::default(),
            size: Default::default(),
            ty: MicromapTypeEXT::OpacityMicromap,
            device_address: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MicromapCreateInfoEXT<'a> {
    #[inline]
    pub fn create_flags(mut self, value: MicromapCreateFlagsEXT) -> Self {
        self.create_flags = value;
        self
    }
    #[inline]
    pub fn buffer(mut self, value: &'a Buffer) -> Self {
        self.buffer = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn offset(mut self, value: DeviceSize) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn ty(mut self, value: MicromapTypeEXT) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn device_address(mut self, value: DeviceAddress) -> Self {
        self.device_address = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceOpacityMicromapFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceOpacityMicromapFeaturesEXT")]
pub struct PhysicalDeviceOpacityMicromapFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub micromap: Bool32,
    pub micromap_capture_replay: Bool32,
    pub micromap_host_commands: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceOpacityMicromapFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceOpacityMicromapFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceOpacityMicromapFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceOpacityMicromapFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceOpacityMicromapFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceOpacityMicromapFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceOpacityMicromapFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            micromap: Default::default(),
            micromap_capture_replay: Default::default(),
            micromap_host_commands: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceOpacityMicromapFeaturesEXT<'a> {
    #[inline]
    pub fn micromap(mut self, value: impl Into<Bool32>) -> Self {
        self.micromap = value.into();
        self
    }
    #[inline]
    pub fn micromap_capture_replay(mut self, value: impl Into<Bool32>) -> Self {
        self.micromap_capture_replay = value.into();
        self
    }
    #[inline]
    pub fn micromap_host_commands(mut self, value: impl Into<Bool32>) -> Self {
        self.micromap_host_commands = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceOpacityMicromapPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceOpacityMicromapPropertiesEXT")]
pub struct PhysicalDeviceOpacityMicromapPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_opacity2_state_subdivision_level: u32,
    pub max_opacity4_state_subdivision_level: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceOpacityMicromapPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceOpacityMicromapPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceOpacityMicromapPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceOpacityMicromapPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceOpacityMicromapPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceOpacityMicromapPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_opacity2_state_subdivision_level: Default::default(),
            max_opacity4_state_subdivision_level: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceOpacityMicromapPropertiesEXT<'a> {
    #[inline]
    pub fn max_opacity2_state_subdivision_level(mut self, value: u32) -> Self {
        self.max_opacity2_state_subdivision_level = value;
        self
    }
    #[inline]
    pub fn max_opacity4_state_subdivision_level(mut self, value: u32) -> Self {
        self.max_opacity4_state_subdivision_level = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapVersionInfoEXT.html>"]
#[doc(alias = "VkMicromapVersionInfoEXT")]
pub struct MicromapVersionInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) p_version_data: *const u8,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MicromapVersionInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MicromapVersionInfoEXT;
}
unsafe impl<'a> Send for MicromapVersionInfoEXT<'a> {}
unsafe impl<'a> Sync for MicromapVersionInfoEXT<'a> {}
impl<'a> Default for MicromapVersionInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_version_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MicromapVersionInfoEXT<'a> {
    #[inline]
    pub fn version_data(mut self, value: &'a [u8; (2 * UUID_SIZE) as _]) -> Self {
        self.p_version_data = value.as_ptr();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMicromapToMemoryInfoEXT.html>"]
#[doc(alias = "VkCopyMicromapToMemoryInfoEXT")]
pub struct CopyMicromapToMemoryInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src: Option<MicromapEXT>,
    pub dst: DeviceOrHostAddressKHR,
    pub mode: CopyMicromapModeEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyMicromapToMemoryInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyMicromapToMemoryInfoEXT;
}
unsafe impl<'a> Send for CopyMicromapToMemoryInfoEXT<'a> {}
unsafe impl<'a> Sync for CopyMicromapToMemoryInfoEXT<'a> {}
impl<'a> Default for CopyMicromapToMemoryInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src: Default::default(),
            dst: Default::default(),
            mode: CopyMicromapModeEXT::Clone,
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyMicromapToMemoryInfoEXT<'a> {
    #[inline]
    pub fn src(mut self, value: &'a MicromapEXT) -> Self {
        self.src = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst(mut self, value: DeviceOrHostAddressKHR) -> Self {
        self.dst = value;
        self
    }
    #[inline]
    pub fn mode(mut self, value: CopyMicromapModeEXT) -> Self {
        self.mode = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMemoryToMicromapInfoEXT.html>"]
#[doc(alias = "VkCopyMemoryToMicromapInfoEXT")]
pub struct CopyMemoryToMicromapInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src: DeviceOrHostAddressConstKHR,
    pub dst: Option<MicromapEXT>,
    pub mode: CopyMicromapModeEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyMemoryToMicromapInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyMemoryToMicromapInfoEXT;
}
unsafe impl<'a> Send for CopyMemoryToMicromapInfoEXT<'a> {}
unsafe impl<'a> Sync for CopyMemoryToMicromapInfoEXT<'a> {}
impl<'a> Default for CopyMemoryToMicromapInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src: Default::default(),
            dst: Default::default(),
            mode: CopyMicromapModeEXT::Clone,
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyMemoryToMicromapInfoEXT<'a> {
    #[inline]
    pub fn src(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.src = value;
        self
    }
    #[inline]
    pub fn dst(mut self, value: &'a MicromapEXT) -> Self {
        self.dst = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn mode(mut self, value: CopyMicromapModeEXT) -> Self {
        self.mode = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMicromapInfoEXT.html>"]
#[doc(alias = "VkCopyMicromapInfoEXT")]
pub struct CopyMicromapInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub src: Option<MicromapEXT>,
    pub dst: Option<MicromapEXT>,
    pub mode: CopyMicromapModeEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CopyMicromapInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CopyMicromapInfoEXT;
}
unsafe impl<'a> Send for CopyMicromapInfoEXT<'a> {}
unsafe impl<'a> Sync for CopyMicromapInfoEXT<'a> {}
impl<'a> Default for CopyMicromapInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            src: Default::default(),
            dst: Default::default(),
            mode: CopyMicromapModeEXT::Clone,
            phantom: PhantomData,
        }
    }
}
impl<'a> CopyMicromapInfoEXT<'a> {
    #[inline]
    pub fn src(mut self, value: &'a MicromapEXT) -> Self {
        self.src = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn dst(mut self, value: &'a MicromapEXT) -> Self {
        self.dst = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn mode(mut self, value: CopyMicromapModeEXT) -> Self {
        self.mode = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapBuildSizesInfoEXT.html>"]
#[doc(alias = "VkMicromapBuildSizesInfoEXT")]
pub struct MicromapBuildSizesInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub micromap_size: DeviceSize,
    pub build_scratch_size: DeviceSize,
    pub discardable: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MicromapBuildSizesInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MicromapBuildSizesInfoEXT;
}
unsafe impl<'a> Send for MicromapBuildSizesInfoEXT<'a> {}
unsafe impl<'a> Sync for MicromapBuildSizesInfoEXT<'a> {}
impl<'a> Default for MicromapBuildSizesInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            micromap_size: Default::default(),
            build_scratch_size: Default::default(),
            discardable: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MicromapBuildSizesInfoEXT<'a> {
    #[inline]
    pub fn micromap_size(mut self, value: DeviceSize) -> Self {
        self.micromap_size = value;
        self
    }
    #[inline]
    pub fn build_scratch_size(mut self, value: DeviceSize) -> Self {
        self.build_scratch_size = value;
        self
    }
    #[inline]
    pub fn discardable(mut self, value: impl Into<Bool32>) -> Self {
        self.discardable = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureTrianglesOpacityMicromapEXT.html>"]
#[doc(alias = "VkAccelerationStructureTrianglesOpacityMicromapEXT")]
pub struct AccelerationStructureTrianglesOpacityMicromapEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub index_type: IndexType,
    pub index_buffer: DeviceOrHostAddressConstKHR,
    pub index_stride: DeviceSize,
    pub base_triangle: u32,
    pub usage_counts_count: u32,
    pub(crate) p_usage_counts: *const MicromapUsageEXT,
    pub(crate) pp_usage_counts: *const *const MicromapUsageEXT,
    pub micromap: Option<MicromapEXT>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureTrianglesOpacityMicromapEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::AccelerationStructureTrianglesOpacityMicromapEXT;
}
unsafe impl<'a> Send for AccelerationStructureTrianglesOpacityMicromapEXT<'a> {}
unsafe impl<'a> Sync for AccelerationStructureTrianglesOpacityMicromapEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<AccelerationStructureGeometryTrianglesDataKHR<'b>>
    for AccelerationStructureTrianglesOpacityMicromapEXT<'a>
{
}
impl<'a> Default for AccelerationStructureTrianglesOpacityMicromapEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            index_type: IndexType::Uint16,
            index_buffer: Default::default(),
            index_stride: Default::default(),
            base_triangle: Default::default(),
            usage_counts_count: Default::default(),
            p_usage_counts: ptr::null(),
            pp_usage_counts: ptr::null(),
            micromap: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureTrianglesOpacityMicromapEXT<'a> {
    #[inline]
    pub fn index_type(mut self, value: IndexType) -> Self {
        self.index_type = value;
        self
    }
    #[inline]
    pub fn index_buffer(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.index_buffer = value;
        self
    }
    #[inline]
    pub fn index_stride(mut self, value: DeviceSize) -> Self {
        self.index_stride = value;
        self
    }
    #[inline]
    pub fn base_triangle(mut self, value: u32) -> Self {
        self.base_triangle = value;
        self
    }
    #[inline]
    pub fn usage_counts_count(mut self, value: u32) -> Self {
        self.usage_counts_count = value;
        self
    }
    #[inline]
    pub fn micromap(mut self, value: Option<&'a MicromapEXT>) -> Self {
        self.micromap = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn usage_counts(
        mut self,
        p_usage_counts: Option<impl AsSlice<'a, MicromapUsageEXT>>,
        pp_usage_counts: Option<impl AsSlice<'a, &'a MicromapUsageEXT>>,
    ) -> Self {
        self.p_usage_counts = p_usage_counts
            .map(|p| p.as_slice().as_ptr().cast())
            .unwrap_or(ptr::null());
        self.pp_usage_counts = pp_usage_counts
            .map(|p| p.as_slice().as_ptr().cast())
            .unwrap_or(ptr::null());
        self.usage_counts_count = p_usage_counts
            .map(|p| p.as_slice().len())
            .unwrap_or_default() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapTriangleEXT.html>"]
#[doc(alias = "VkMicromapTriangleEXT")]
pub struct MicromapTriangleEXT {
    pub data_offset: u32,
    pub subdivision_level: u16,
    pub format: u16,
}
unsafe impl Send for MicromapTriangleEXT {}
unsafe impl Sync for MicromapTriangleEXT {}
impl Default for MicromapTriangleEXT {
    fn default() -> Self {
        Self {
            data_offset: Default::default(),
            subdivision_level: Default::default(),
            format: Default::default(),
        }
    }
}
impl MicromapTriangleEXT {
    #[inline]
    pub fn data_offset(mut self, value: u32) -> Self {
        self.data_offset = value;
        self
    }
    #[inline]
    pub fn subdivision_level(mut self, value: u16) -> Self {
        self.subdivision_level = value;
        self
    }
    #[inline]
    pub fn format(mut self, value: u16) -> Self {
        self.format = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDisplacementMicromapFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceDisplacementMicromapFeaturesNV")]
pub struct PhysicalDeviceDisplacementMicromapFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub displacement_micromap: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDisplacementMicromapFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDisplacementMicromapFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceDisplacementMicromapFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDisplacementMicromapFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDisplacementMicromapFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDisplacementMicromapFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceDisplacementMicromapFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            displacement_micromap: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDisplacementMicromapFeaturesNV<'a> {
    #[inline]
    pub fn displacement_micromap(mut self, value: impl Into<Bool32>) -> Self {
        self.displacement_micromap = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDisplacementMicromapPropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceDisplacementMicromapPropertiesNV")]
pub struct PhysicalDeviceDisplacementMicromapPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_displacement_micromap_subdivision_level: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDisplacementMicromapPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDisplacementMicromapPropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceDisplacementMicromapPropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDisplacementMicromapPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceDisplacementMicromapPropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceDisplacementMicromapPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_displacement_micromap_subdivision_level: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDisplacementMicromapPropertiesNV<'a> {
    #[inline]
    pub fn max_displacement_micromap_subdivision_level(mut self, value: u32) -> Self {
        self.max_displacement_micromap_subdivision_level = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureTrianglesDisplacementMicromapNV.html>"]
#[doc(alias = "VkAccelerationStructureTrianglesDisplacementMicromapNV")]
pub struct AccelerationStructureTrianglesDisplacementMicromapNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub displacement_bias_and_scale_format: Format,
    pub displacement_vector_format: Format,
    pub displacement_bias_and_scale_buffer: DeviceOrHostAddressConstKHR,
    pub displacement_bias_and_scale_stride: DeviceSize,
    pub displacement_vector_buffer: DeviceOrHostAddressConstKHR,
    pub displacement_vector_stride: DeviceSize,
    pub displaced_micromap_primitive_flags: DeviceOrHostAddressConstKHR,
    pub displaced_micromap_primitive_flags_stride: DeviceSize,
    pub index_type: IndexType,
    pub index_buffer: DeviceOrHostAddressConstKHR,
    pub index_stride: DeviceSize,
    pub base_triangle: u32,
    pub usage_counts_count: u32,
    pub(crate) p_usage_counts: *const MicromapUsageEXT,
    pub(crate) pp_usage_counts: *const *const MicromapUsageEXT,
    pub micromap: Option<MicromapEXT>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AccelerationStructureTrianglesDisplacementMicromapNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::AccelerationStructureTrianglesDisplacementMicromapNV;
}
unsafe impl<'a> Send for AccelerationStructureTrianglesDisplacementMicromapNV<'a> {}
unsafe impl<'a> Sync for AccelerationStructureTrianglesDisplacementMicromapNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<AccelerationStructureGeometryTrianglesDataKHR<'b>>
    for AccelerationStructureTrianglesDisplacementMicromapNV<'a>
{
}
impl<'a> Default for AccelerationStructureTrianglesDisplacementMicromapNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            displacement_bias_and_scale_format: Format::Undefined,
            displacement_vector_format: Format::Undefined,
            displacement_bias_and_scale_buffer: Default::default(),
            displacement_bias_and_scale_stride: Default::default(),
            displacement_vector_buffer: Default::default(),
            displacement_vector_stride: Default::default(),
            displaced_micromap_primitive_flags: Default::default(),
            displaced_micromap_primitive_flags_stride: Default::default(),
            index_type: IndexType::Uint16,
            index_buffer: Default::default(),
            index_stride: Default::default(),
            base_triangle: Default::default(),
            usage_counts_count: Default::default(),
            p_usage_counts: ptr::null(),
            pp_usage_counts: ptr::null(),
            micromap: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AccelerationStructureTrianglesDisplacementMicromapNV<'a> {
    #[inline]
    pub fn displacement_bias_and_scale_format(mut self, value: Format) -> Self {
        self.displacement_bias_and_scale_format = value;
        self
    }
    #[inline]
    pub fn displacement_vector_format(mut self, value: Format) -> Self {
        self.displacement_vector_format = value;
        self
    }
    #[inline]
    pub fn displacement_bias_and_scale_buffer(
        mut self,
        value: DeviceOrHostAddressConstKHR,
    ) -> Self {
        self.displacement_bias_and_scale_buffer = value;
        self
    }
    #[inline]
    pub fn displacement_bias_and_scale_stride(mut self, value: DeviceSize) -> Self {
        self.displacement_bias_and_scale_stride = value;
        self
    }
    #[inline]
    pub fn displacement_vector_buffer(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.displacement_vector_buffer = value;
        self
    }
    #[inline]
    pub fn displacement_vector_stride(mut self, value: DeviceSize) -> Self {
        self.displacement_vector_stride = value;
        self
    }
    #[inline]
    pub fn displaced_micromap_primitive_flags(
        mut self,
        value: DeviceOrHostAddressConstKHR,
    ) -> Self {
        self.displaced_micromap_primitive_flags = value;
        self
    }
    #[inline]
    pub fn displaced_micromap_primitive_flags_stride(mut self, value: DeviceSize) -> Self {
        self.displaced_micromap_primitive_flags_stride = value;
        self
    }
    #[inline]
    pub fn index_type(mut self, value: IndexType) -> Self {
        self.index_type = value;
        self
    }
    #[inline]
    pub fn index_buffer(mut self, value: DeviceOrHostAddressConstKHR) -> Self {
        self.index_buffer = value;
        self
    }
    #[inline]
    pub fn index_stride(mut self, value: DeviceSize) -> Self {
        self.index_stride = value;
        self
    }
    #[inline]
    pub fn base_triangle(mut self, value: u32) -> Self {
        self.base_triangle = value;
        self
    }
    #[inline]
    pub fn usage_counts_count(mut self, value: u32) -> Self {
        self.usage_counts_count = value;
        self
    }
    #[inline]
    pub fn micromap(mut self, value: Option<&'a MicromapEXT>) -> Self {
        self.micromap = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn usage_counts(
        mut self,
        p_usage_counts: Option<impl AsSlice<'a, MicromapUsageEXT>>,
        pp_usage_counts: Option<impl AsSlice<'a, &'a MicromapUsageEXT>>,
    ) -> Self {
        self.p_usage_counts = p_usage_counts
            .map(|p| p.as_slice().as_ptr().cast())
            .unwrap_or(ptr::null());
        self.pp_usage_counts = pp_usage_counts
            .map(|p| p.as_slice().as_ptr().cast())
            .unwrap_or(ptr::null());
        self.usage_counts_count = p_usage_counts
            .map(|p| p.as_slice().len())
            .unwrap_or_default() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI.html>"]
#[doc(alias = "VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI")]
pub struct PhysicalDeviceClusterCullingShaderFeaturesHUAWEI<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub clusterculling_shader: Bool32,
    pub multiview_cluster_culling_shader: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceClusterCullingShaderFeaturesHUAWEI<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceClusterCullingShaderFeaturesHUAWEI;
}
unsafe impl<'a> Send for PhysicalDeviceClusterCullingShaderFeaturesHUAWEI<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceClusterCullingShaderFeaturesHUAWEI<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceClusterCullingShaderFeaturesHUAWEI<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceClusterCullingShaderFeaturesHUAWEI<'a>
{
}
impl<'a> Default for PhysicalDeviceClusterCullingShaderFeaturesHUAWEI<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            clusterculling_shader: Default::default(),
            multiview_cluster_culling_shader: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceClusterCullingShaderFeaturesHUAWEI<'a> {
    #[inline]
    pub fn clusterculling_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.clusterculling_shader = value.into();
        self
    }
    #[inline]
    pub fn multiview_cluster_culling_shader(mut self, value: impl Into<Bool32>) -> Self {
        self.multiview_cluster_culling_shader = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI.html>"]
#[doc(alias = "VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI")]
pub struct PhysicalDeviceClusterCullingShaderPropertiesHUAWEI<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_work_group_count: [u32; 3u16 as _],
    pub max_work_group_size: [u32; 3u16 as _],
    pub max_output_cluster_count: u32,
    pub indirect_buffer_offset_alignment: DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceClusterCullingShaderPropertiesHUAWEI<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceClusterCullingShaderPropertiesHUAWEI;
}
unsafe impl<'a> Send for PhysicalDeviceClusterCullingShaderPropertiesHUAWEI<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceClusterCullingShaderPropertiesHUAWEI<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceClusterCullingShaderPropertiesHUAWEI<'a>
{
}
impl<'a> Default for PhysicalDeviceClusterCullingShaderPropertiesHUAWEI<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_work_group_count: array::from_fn(|_| Default::default()),
            max_work_group_size: array::from_fn(|_| Default::default()),
            max_output_cluster_count: Default::default(),
            indirect_buffer_offset_alignment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceClusterCullingShaderPropertiesHUAWEI<'a> {
    #[inline]
    pub fn max_work_group_count(mut self, value: [u32; 3u16 as _]) -> Self {
        self.max_work_group_count = value;
        self
    }
    #[inline]
    pub fn max_work_group_size(mut self, value: [u32; 3u16 as _]) -> Self {
        self.max_work_group_size = value;
        self
    }
    #[inline]
    pub fn max_output_cluster_count(mut self, value: u32) -> Self {
        self.max_output_cluster_count = value;
        self
    }
    #[inline]
    pub fn indirect_buffer_offset_alignment(mut self, value: DeviceSize) -> Self {
        self.indirect_buffer_offset_alignment = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI.html>"]
#[doc(alias = "VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI")]
pub struct PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub cluster_shading_rate: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI;
}
unsafe impl<'a> Send for PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceClusterCullingShaderFeaturesHUAWEI<'b>>
    for PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI<'a>
{
}
impl<'a> Default for PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            cluster_shading_rate: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI<'a> {
    #[inline]
    pub fn cluster_shading_rate(mut self, value: impl Into<Bool32>) -> Self {
        self.cluster_shading_rate = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceBorderColorSwizzleFeaturesEXT")]
pub struct PhysicalDeviceBorderColorSwizzleFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub border_color_swizzle: Bool32,
    pub border_color_swizzle_from_image: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceBorderColorSwizzleFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceBorderColorSwizzleFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceBorderColorSwizzleFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceBorderColorSwizzleFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceBorderColorSwizzleFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceBorderColorSwizzleFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceBorderColorSwizzleFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            border_color_swizzle: Default::default(),
            border_color_swizzle_from_image: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceBorderColorSwizzleFeaturesEXT<'a> {
    #[inline]
    pub fn border_color_swizzle(mut self, value: impl Into<Bool32>) -> Self {
        self.border_color_swizzle = value.into();
        self
    }
    #[inline]
    pub fn border_color_swizzle_from_image(mut self, value: impl Into<Bool32>) -> Self {
        self.border_color_swizzle_from_image = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerBorderColorComponentMappingCreateInfoEXT.html>"]
#[doc(alias = "VkSamplerBorderColorComponentMappingCreateInfoEXT")]
pub struct SamplerBorderColorComponentMappingCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub components: ComponentMapping,
    pub srgb: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SamplerBorderColorComponentMappingCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SamplerBorderColorComponentMappingCreateInfoEXT;
}
unsafe impl<'a> Send for SamplerBorderColorComponentMappingCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for SamplerBorderColorComponentMappingCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SamplerCreateInfo<'b>>
    for SamplerBorderColorComponentMappingCreateInfoEXT<'a>
{
}
impl<'a> Default for SamplerBorderColorComponentMappingCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            components: Default::default(),
            srgb: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SamplerBorderColorComponentMappingCreateInfoEXT<'a> {
    #[inline]
    pub fn components(mut self, value: ComponentMapping) -> Self {
        self.components = value;
        self
    }
    #[inline]
    pub fn srgb(mut self, value: impl Into<Bool32>) -> Self {
        self.srgb = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT")]
pub struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pageable_device_local_memory: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pageable_device_local_memory: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'a> {
    #[inline]
    pub fn pageable_device_local_memory(mut self, value: impl Into<Bool32>) -> Self {
        self.pageable_device_local_memory = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCorePropertiesARM.html>"]
#[doc(alias = "VkPhysicalDeviceShaderCorePropertiesARM")]
pub struct PhysicalDeviceShaderCorePropertiesARM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pixel_rate: u32,
    pub texel_rate: u32,
    pub fma_rate: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderCorePropertiesARM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderCorePropertiesARM;
}
unsafe impl<'a> Send for PhysicalDeviceShaderCorePropertiesARM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderCorePropertiesARM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceShaderCorePropertiesARM<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderCorePropertiesARM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pixel_rate: Default::default(),
            texel_rate: Default::default(),
            fma_rate: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderCorePropertiesARM<'a> {
    #[inline]
    pub fn pixel_rate(mut self, value: u32) -> Self {
        self.pixel_rate = value;
        self
    }
    #[inline]
    pub fn texel_rate(mut self, value: u32) -> Self {
        self.texel_rate = value;
        self
    }
    #[inline]
    pub fn fma_rate(mut self, value: u32) -> Self {
        self.fma_rate = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR")]
pub struct PhysicalDeviceShaderSubgroupRotateFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_subgroup_rotate: Bool32,
    pub shader_subgroup_rotate_clustered: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderSubgroupRotateFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderSubgroupRotateFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceShaderSubgroupRotateFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderSubgroupRotateFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderSubgroupRotateFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderSubgroupRotateFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderSubgroupRotateFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_subgroup_rotate: Default::default(),
            shader_subgroup_rotate_clustered: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderSubgroupRotateFeaturesKHR<'a> {
    #[inline]
    pub fn shader_subgroup_rotate(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_subgroup_rotate = value.into();
        self
    }
    #[inline]
    pub fn shader_subgroup_rotate_clustered(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_subgroup_rotate_clustered = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueShaderCoreControlCreateInfoARM.html>"]
#[doc(alias = "VkDeviceQueueShaderCoreControlCreateInfoARM")]
pub struct DeviceQueueShaderCoreControlCreateInfoARM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_core_count: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceQueueShaderCoreControlCreateInfoARM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceQueueShaderCoreControlCreateInfoARM;
}
unsafe impl<'a> Send for DeviceQueueShaderCoreControlCreateInfoARM<'a> {}
unsafe impl<'a> Sync for DeviceQueueShaderCoreControlCreateInfoARM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DeviceQueueCreateInfo<'b>>
    for DeviceQueueShaderCoreControlCreateInfoARM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for DeviceQueueShaderCoreControlCreateInfoARM<'a>
{
}
impl<'a> Default for DeviceQueueShaderCoreControlCreateInfoARM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_core_count: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceQueueShaderCoreControlCreateInfoARM<'a> {
    #[inline]
    pub fn shader_core_count(mut self, value: u32) -> Self {
        self.shader_core_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSchedulingControlsFeaturesARM.html>"]
#[doc(alias = "VkPhysicalDeviceSchedulingControlsFeaturesARM")]
pub struct PhysicalDeviceSchedulingControlsFeaturesARM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub scheduling_controls: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSchedulingControlsFeaturesARM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceSchedulingControlsFeaturesARM;
}
unsafe impl<'a> Send for PhysicalDeviceSchedulingControlsFeaturesARM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSchedulingControlsFeaturesARM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceSchedulingControlsFeaturesARM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceSchedulingControlsFeaturesARM<'a>
{
}
impl<'a> Default for PhysicalDeviceSchedulingControlsFeaturesARM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            scheduling_controls: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSchedulingControlsFeaturesARM<'a> {
    #[inline]
    pub fn scheduling_controls(mut self, value: impl Into<Bool32>) -> Self {
        self.scheduling_controls = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSchedulingControlsPropertiesARM.html>"]
#[doc(alias = "VkPhysicalDeviceSchedulingControlsPropertiesARM")]
pub struct PhysicalDeviceSchedulingControlsPropertiesARM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub scheduling_controls_flags: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSchedulingControlsPropertiesARM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceSchedulingControlsPropertiesARM;
}
unsafe impl<'a> Send for PhysicalDeviceSchedulingControlsPropertiesARM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSchedulingControlsPropertiesARM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceSchedulingControlsPropertiesARM<'a>
{
}
impl<'a> Default for PhysicalDeviceSchedulingControlsPropertiesARM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            scheduling_controls_flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSchedulingControlsPropertiesARM<'a> {
    #[inline]
    pub fn scheduling_controls_flags(mut self, value: u32) -> Self {
        self.scheduling_controls_flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT")]
pub struct PhysicalDeviceImageSlicedViewOf3DFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_sliced_view_of3_d: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageSlicedViewOf3DFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceImageSlicedViewOf3DFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceImageSlicedViewOf3DFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageSlicedViewOf3DFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceImageSlicedViewOf3DFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceImageSlicedViewOf3DFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceImageSlicedViewOf3DFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_sliced_view_of3_d: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageSlicedViewOf3DFeaturesEXT<'a> {
    #[inline]
    pub fn image_sliced_view_of3_d(mut self, value: impl Into<Bool32>) -> Self {
        self.image_sliced_view_of3_d = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewSlicedCreateInfoEXT.html>"]
#[doc(alias = "VkImageViewSlicedCreateInfoEXT")]
pub struct ImageViewSlicedCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub slice_offset: u32,
    pub slice_count: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageViewSlicedCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageViewSlicedCreateInfoEXT;
}
unsafe impl<'a> Send for ImageViewSlicedCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for ImageViewSlicedCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageViewCreateInfo<'b>>
    for ImageViewSlicedCreateInfoEXT<'a>
{
}
impl<'a> Default for ImageViewSlicedCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            slice_offset: Default::default(),
            slice_count: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageViewSlicedCreateInfoEXT<'a> {
    #[inline]
    pub fn slice_offset(mut self, value: u32) -> Self {
        self.slice_offset = value;
        self
    }
    #[inline]
    pub fn slice_count(mut self, value: u32) -> Self {
        self.slice_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE.html>"]
#[doc(alias = "VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE")]
pub struct PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub descriptor_set_host_mapping: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE;
}
unsafe impl<'a> Send for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'a>
{
}
impl<'a> Default for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            descriptor_set_host_mapping: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'a> {
    #[inline]
    pub fn descriptor_set_host_mapping(mut self, value: impl Into<Bool32>) -> Self {
        self.descriptor_set_host_mapping = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetBindingReferenceVALVE.html>"]
#[doc(alias = "VkDescriptorSetBindingReferenceVALVE")]
pub struct DescriptorSetBindingReferenceVALVE<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub descriptor_set_layout: Option<DescriptorSetLayout>,
    pub binding: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorSetBindingReferenceVALVE<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DescriptorSetBindingReferenceVALVE;
}
unsafe impl<'a> Send for DescriptorSetBindingReferenceVALVE<'a> {}
unsafe impl<'a> Sync for DescriptorSetBindingReferenceVALVE<'a> {}
impl<'a> Default for DescriptorSetBindingReferenceVALVE<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            descriptor_set_layout: Default::default(),
            binding: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorSetBindingReferenceVALVE<'a> {
    #[inline]
    pub fn descriptor_set_layout(mut self, value: &'a DescriptorSetLayout) -> Self {
        self.descriptor_set_layout = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn binding(mut self, value: u32) -> Self {
        self.binding = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutHostMappingInfoVALVE.html>"]
#[doc(alias = "VkDescriptorSetLayoutHostMappingInfoVALVE")]
pub struct DescriptorSetLayoutHostMappingInfoVALVE<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub descriptor_offset: usize,
    pub descriptor_size: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DescriptorSetLayoutHostMappingInfoVALVE<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DescriptorSetLayoutHostMappingInfoVALVE;
}
unsafe impl<'a> Send for DescriptorSetLayoutHostMappingInfoVALVE<'a> {}
unsafe impl<'a> Sync for DescriptorSetLayoutHostMappingInfoVALVE<'a> {}
impl<'a> Default for DescriptorSetLayoutHostMappingInfoVALVE<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            descriptor_offset: Default::default(),
            descriptor_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DescriptorSetLayoutHostMappingInfoVALVE<'a> {
    #[inline]
    pub fn descriptor_offset(mut self, value: usize) -> Self {
        self.descriptor_offset = value;
        self
    }
    #[inline]
    pub fn descriptor_size(mut self, value: u32) -> Self {
        self.descriptor_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthClampZeroOneFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceDepthClampZeroOneFeaturesEXT")]
pub struct PhysicalDeviceDepthClampZeroOneFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub depth_clamp_zero_one: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDepthClampZeroOneFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceDepthClampZeroOneFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceDepthClampZeroOneFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDepthClampZeroOneFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDepthClampZeroOneFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDepthClampZeroOneFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceDepthClampZeroOneFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            depth_clamp_zero_one: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDepthClampZeroOneFeaturesEXT<'a> {
    #[inline]
    pub fn depth_clamp_zero_one(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_clamp_zero_one = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT")]
pub struct PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub non_seamless_cube_map: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceNonSeamlessCubeMapFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            non_seamless_cube_map: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'a> {
    #[inline]
    pub fn non_seamless_cube_map(mut self, value: impl Into<Bool32>) -> Self {
        self.non_seamless_cube_map = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRenderPassStripedFeaturesARM.html>"]
#[doc(alias = "VkPhysicalDeviceRenderPassStripedFeaturesARM")]
pub struct PhysicalDeviceRenderPassStripedFeaturesARM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub render_pass_striped: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRenderPassStripedFeaturesARM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceRenderPassStripedFeaturesARM;
}
unsafe impl<'a> Send for PhysicalDeviceRenderPassStripedFeaturesARM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRenderPassStripedFeaturesARM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRenderPassStripedFeaturesARM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRenderPassStripedFeaturesARM<'a>
{
}
impl<'a> Default for PhysicalDeviceRenderPassStripedFeaturesARM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            render_pass_striped: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRenderPassStripedFeaturesARM<'a> {
    #[inline]
    pub fn render_pass_striped(mut self, value: impl Into<Bool32>) -> Self {
        self.render_pass_striped = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRenderPassStripedPropertiesARM.html>"]
#[doc(alias = "VkPhysicalDeviceRenderPassStripedPropertiesARM")]
pub struct PhysicalDeviceRenderPassStripedPropertiesARM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub render_pass_stripe_granularity: Extent2D,
    pub max_render_pass_stripes: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRenderPassStripedPropertiesARM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceRenderPassStripedPropertiesARM;
}
unsafe impl<'a> Send for PhysicalDeviceRenderPassStripedPropertiesARM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRenderPassStripedPropertiesARM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceRenderPassStripedPropertiesARM<'a>
{
}
impl<'a> Default for PhysicalDeviceRenderPassStripedPropertiesARM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            render_pass_stripe_granularity: Default::default(),
            max_render_pass_stripes: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRenderPassStripedPropertiesARM<'a> {
    #[inline]
    pub fn render_pass_stripe_granularity(mut self, value: Extent2D) -> Self {
        self.render_pass_stripe_granularity = value;
        self
    }
    #[inline]
    pub fn max_render_pass_stripes(mut self, value: u32) -> Self {
        self.max_render_pass_stripes = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassStripeBeginInfoARM.html>"]
#[doc(alias = "VkRenderPassStripeBeginInfoARM")]
pub struct RenderPassStripeBeginInfoARM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) stripe_info_count: u32,
    pub(crate) p_stripe_infos: *const RenderPassStripeInfoARM<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassStripeBeginInfoARM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassStripeBeginInfoARM;
}
unsafe impl<'a> Send for RenderPassStripeBeginInfoARM<'a> {}
unsafe impl<'a> Sync for RenderPassStripeBeginInfoARM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderingInfo<'b>> for RenderPassStripeBeginInfoARM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderPassBeginInfo<'b>>
    for RenderPassStripeBeginInfoARM<'a>
{
}
impl<'a> Default for RenderPassStripeBeginInfoARM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stripe_info_count: Default::default(),
            p_stripe_infos: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassStripeBeginInfoARM<'a> {
    #[inline]
    pub fn stripe_infos(
        mut self,
        p_stripe_infos: impl AsSlice<'a, RenderPassStripeInfoARM<'a>>,
    ) -> Self {
        self.p_stripe_infos = p_stripe_infos.as_slice().as_ptr().cast();
        self.stripe_info_count = p_stripe_infos.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassStripeInfoARM.html>"]
#[doc(alias = "VkRenderPassStripeInfoARM")]
pub struct RenderPassStripeInfoARM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub stripe_area: Rect2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassStripeInfoARM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassStripeInfoARM;
}
unsafe impl<'a> Send for RenderPassStripeInfoARM<'a> {}
unsafe impl<'a> Sync for RenderPassStripeInfoARM<'a> {}
impl<'a> Default for RenderPassStripeInfoARM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stripe_area: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassStripeInfoARM<'a> {
    #[inline]
    pub fn stripe_area(mut self, value: Rect2D) -> Self {
        self.stripe_area = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassStripeSubmitInfoARM.html>"]
#[doc(alias = "VkRenderPassStripeSubmitInfoARM")]
pub struct RenderPassStripeSubmitInfoARM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) stripe_semaphore_info_count: u32,
    pub(crate) p_stripe_semaphore_infos: *const SemaphoreSubmitInfo<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassStripeSubmitInfoARM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassStripeSubmitInfoARM;
}
unsafe impl<'a> Send for RenderPassStripeSubmitInfoARM<'a> {}
unsafe impl<'a> Sync for RenderPassStripeSubmitInfoARM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<CommandBufferSubmitInfo<'b>>
    for RenderPassStripeSubmitInfoARM<'a>
{
}
impl<'a> Default for RenderPassStripeSubmitInfoARM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stripe_semaphore_info_count: Default::default(),
            p_stripe_semaphore_infos: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassStripeSubmitInfoARM<'a> {
    #[inline]
    pub fn stripe_semaphore_infos(
        mut self,
        p_stripe_semaphore_infos: impl AsSlice<'a, SemaphoreSubmitInfo<'a>>,
    ) -> Self {
        self.p_stripe_semaphore_infos = p_stripe_semaphore_infos.as_slice().as_ptr().cast();
        self.stripe_semaphore_info_count = p_stripe_semaphore_infos.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM")]
pub struct PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fragment_density_map_offset: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fragment_density_map_offset: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'a> {
    #[inline]
    pub fn fragment_density_map_offset(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_density_map_offset = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM.html>"]
#[doc(alias = "VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM")]
pub struct PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub fragment_density_offset_granularity: Extent2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM;
}
unsafe impl<'a> Send for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM<'a>
{
}
impl<'a> Default for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fragment_density_offset_granularity: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM<'a> {
    #[inline]
    pub fn fragment_density_offset_granularity(mut self, value: Extent2D) -> Self {
        self.fragment_density_offset_granularity = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassFragmentDensityMapOffsetEndInfoQCOM.html>"]
#[doc(alias = "VkSubpassFragmentDensityMapOffsetEndInfoQCOM")]
pub struct SubpassFragmentDensityMapOffsetEndInfoQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) fragment_density_offset_count: u32,
    pub(crate) p_fragment_density_offsets: *const Offset2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SubpassFragmentDensityMapOffsetEndInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SubpassFragmentDensityMapOffsetEndInfoQCOM;
}
unsafe impl<'a> Send for SubpassFragmentDensityMapOffsetEndInfoQCOM<'a> {}
unsafe impl<'a> Sync for SubpassFragmentDensityMapOffsetEndInfoQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubpassEndInfo<'b>>
    for SubpassFragmentDensityMapOffsetEndInfoQCOM<'a>
{
}
impl<'a> Default for SubpassFragmentDensityMapOffsetEndInfoQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            fragment_density_offset_count: Default::default(),
            p_fragment_density_offsets: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubpassFragmentDensityMapOffsetEndInfoQCOM<'a> {
    #[inline]
    pub fn fragment_density_offsets(
        mut self,
        p_fragment_density_offsets: impl AsSlice<'a, Offset2D>,
    ) -> Self {
        self.p_fragment_density_offsets = p_fragment_density_offsets.as_slice().as_ptr().cast();
        self.fragment_density_offset_count = p_fragment_density_offsets.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMemoryIndirectCommandNV.html>"]
#[doc(alias = "VkCopyMemoryIndirectCommandNV")]
pub struct CopyMemoryIndirectCommandNV {
    pub src_address: DeviceAddress,
    pub dst_address: DeviceAddress,
    pub size: DeviceSize,
}
unsafe impl Send for CopyMemoryIndirectCommandNV {}
unsafe impl Sync for CopyMemoryIndirectCommandNV {}
impl Default for CopyMemoryIndirectCommandNV {
    fn default() -> Self {
        Self {
            src_address: Default::default(),
            dst_address: Default::default(),
            size: Default::default(),
        }
    }
}
impl CopyMemoryIndirectCommandNV {
    #[inline]
    pub fn src_address(mut self, value: DeviceAddress) -> Self {
        self.src_address = value;
        self
    }
    #[inline]
    pub fn dst_address(mut self, value: DeviceAddress) -> Self {
        self.dst_address = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMemoryToImageIndirectCommandNV.html>"]
#[doc(alias = "VkCopyMemoryToImageIndirectCommandNV")]
pub struct CopyMemoryToImageIndirectCommandNV {
    pub src_address: DeviceAddress,
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    pub image_offset: Offset3D,
    pub image_extent: Extent3D,
}
unsafe impl Send for CopyMemoryToImageIndirectCommandNV {}
unsafe impl Sync for CopyMemoryToImageIndirectCommandNV {}
impl Default for CopyMemoryToImageIndirectCommandNV {
    fn default() -> Self {
        Self {
            src_address: Default::default(),
            buffer_row_length: Default::default(),
            buffer_image_height: Default::default(),
            image_subresource: Default::default(),
            image_offset: Default::default(),
            image_extent: Default::default(),
        }
    }
}
impl CopyMemoryToImageIndirectCommandNV {
    #[inline]
    pub fn src_address(mut self, value: DeviceAddress) -> Self {
        self.src_address = value;
        self
    }
    #[inline]
    pub fn buffer_row_length(mut self, value: u32) -> Self {
        self.buffer_row_length = value;
        self
    }
    #[inline]
    pub fn buffer_image_height(mut self, value: u32) -> Self {
        self.buffer_image_height = value;
        self
    }
    #[inline]
    pub fn image_subresource(mut self, value: ImageSubresourceLayers) -> Self {
        self.image_subresource = value;
        self
    }
    #[inline]
    pub fn image_offset(mut self, value: Offset3D) -> Self {
        self.image_offset = value;
        self
    }
    #[inline]
    pub fn image_extent(mut self, value: Extent3D) -> Self {
        self.image_extent = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCopyMemoryIndirectFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceCopyMemoryIndirectFeaturesNV")]
pub struct PhysicalDeviceCopyMemoryIndirectFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub indirect_copy: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCopyMemoryIndirectFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceCopyMemoryIndirectFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceCopyMemoryIndirectFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCopyMemoryIndirectFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceCopyMemoryIndirectFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceCopyMemoryIndirectFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceCopyMemoryIndirectFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            indirect_copy: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCopyMemoryIndirectFeaturesNV<'a> {
    #[inline]
    pub fn indirect_copy(mut self, value: impl Into<Bool32>) -> Self {
        self.indirect_copy = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCopyMemoryIndirectPropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceCopyMemoryIndirectPropertiesNV")]
pub struct PhysicalDeviceCopyMemoryIndirectPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub supported_queues: QueueFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCopyMemoryIndirectPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceCopyMemoryIndirectPropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceCopyMemoryIndirectPropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCopyMemoryIndirectPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceCopyMemoryIndirectPropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceCopyMemoryIndirectPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            supported_queues: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCopyMemoryIndirectPropertiesNV<'a> {
    #[inline]
    pub fn supported_queues(mut self, value: QueueFlags) -> Self {
        self.supported_queues = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDecompressMemoryRegionNV.html>"]
#[doc(alias = "VkDecompressMemoryRegionNV")]
pub struct DecompressMemoryRegionNV {
    pub src_address: DeviceAddress,
    pub dst_address: DeviceAddress,
    pub compressed_size: DeviceSize,
    pub decompressed_size: DeviceSize,
    pub decompression_method: u32,
}
unsafe impl Send for DecompressMemoryRegionNV {}
unsafe impl Sync for DecompressMemoryRegionNV {}
impl Default for DecompressMemoryRegionNV {
    fn default() -> Self {
        Self {
            src_address: Default::default(),
            dst_address: Default::default(),
            compressed_size: Default::default(),
            decompressed_size: Default::default(),
            decompression_method: Default::default(),
        }
    }
}
impl DecompressMemoryRegionNV {
    #[inline]
    pub fn src_address(mut self, value: DeviceAddress) -> Self {
        self.src_address = value;
        self
    }
    #[inline]
    pub fn dst_address(mut self, value: DeviceAddress) -> Self {
        self.dst_address = value;
        self
    }
    #[inline]
    pub fn compressed_size(mut self, value: DeviceSize) -> Self {
        self.compressed_size = value;
        self
    }
    #[inline]
    pub fn decompressed_size(mut self, value: DeviceSize) -> Self {
        self.decompressed_size = value;
        self
    }
    #[inline]
    pub fn decompression_method(mut self, value: u32) -> Self {
        self.decompression_method = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryDecompressionFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceMemoryDecompressionFeaturesNV")]
pub struct PhysicalDeviceMemoryDecompressionFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub memory_decompression: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMemoryDecompressionFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceMemoryDecompressionFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceMemoryDecompressionFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMemoryDecompressionFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMemoryDecompressionFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMemoryDecompressionFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceMemoryDecompressionFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            memory_decompression: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMemoryDecompressionFeaturesNV<'a> {
    #[inline]
    pub fn memory_decompression(mut self, value: impl Into<Bool32>) -> Self {
        self.memory_decompression = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryDecompressionPropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceMemoryDecompressionPropertiesNV")]
pub struct PhysicalDeviceMemoryDecompressionPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub decompression_methods: u32,
    pub max_decompression_indirect_count: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMemoryDecompressionPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceMemoryDecompressionPropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceMemoryDecompressionPropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMemoryDecompressionPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceMemoryDecompressionPropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceMemoryDecompressionPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            decompression_methods: Default::default(),
            max_decompression_indirect_count: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMemoryDecompressionPropertiesNV<'a> {
    #[inline]
    pub fn decompression_methods(mut self, value: u32) -> Self {
        self.decompression_methods = value;
        self
    }
    #[inline]
    pub fn max_decompression_indirect_count(mut self, value: u64) -> Self {
        self.max_decompression_indirect_count = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV")]
pub struct PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_generated_compute: Bool32,
    pub device_generated_compute_pipelines: Bool32,
    pub device_generated_compute_capture_replay: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_generated_compute: Default::default(),
            device_generated_compute_pipelines: Default::default(),
            device_generated_compute_capture_replay: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV<'a> {
    #[inline]
    pub fn device_generated_compute(mut self, value: impl Into<Bool32>) -> Self {
        self.device_generated_compute = value.into();
        self
    }
    #[inline]
    pub fn device_generated_compute_pipelines(mut self, value: impl Into<Bool32>) -> Self {
        self.device_generated_compute_pipelines = value.into();
        self
    }
    #[inline]
    pub fn device_generated_compute_capture_replay(mut self, value: impl Into<Bool32>) -> Self {
        self.device_generated_compute_capture_replay = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComputePipelineIndirectBufferInfoNV.html>"]
#[doc(alias = "VkComputePipelineIndirectBufferInfoNV")]
pub struct ComputePipelineIndirectBufferInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub device_address: DeviceAddress,
    pub size: DeviceSize,
    pub pipeline_device_address_capture_replay: DeviceAddress,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ComputePipelineIndirectBufferInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ComputePipelineIndirectBufferInfoNV;
}
unsafe impl<'a> Send for ComputePipelineIndirectBufferInfoNV<'a> {}
unsafe impl<'a> Sync for ComputePipelineIndirectBufferInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ComputePipelineCreateInfo<'b>>
    for ComputePipelineIndirectBufferInfoNV<'a>
{
}
impl<'a> Default for ComputePipelineIndirectBufferInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            device_address: Default::default(),
            size: Default::default(),
            pipeline_device_address_capture_replay: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ComputePipelineIndirectBufferInfoNV<'a> {
    #[inline]
    pub fn device_address(mut self, value: DeviceAddress) -> Self {
        self.device_address = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: DeviceSize) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn pipeline_device_address_capture_replay(mut self, value: DeviceAddress) -> Self {
        self.pipeline_device_address_capture_replay = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineIndirectDeviceAddressInfoNV.html>"]
#[doc(alias = "VkPipelineIndirectDeviceAddressInfoNV")]
pub struct PipelineIndirectDeviceAddressInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline: Option<Pipeline>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineIndirectDeviceAddressInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineIndirectDeviceAddressInfoNV;
}
unsafe impl<'a> Send for PipelineIndirectDeviceAddressInfoNV<'a> {}
unsafe impl<'a> Sync for PipelineIndirectDeviceAddressInfoNV<'a> {}
impl<'a> Default for PipelineIndirectDeviceAddressInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline_bind_point: PipelineBindPoint::Graphics,
            pipeline: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineIndirectDeviceAddressInfoNV<'a> {
    #[inline]
    pub fn pipeline_bind_point(mut self, value: PipelineBindPoint) -> Self {
        self.pipeline_bind_point = value;
        self
    }
    #[inline]
    pub fn pipeline(mut self, value: &'a Pipeline) -> Self {
        self.pipeline = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindPipelineIndirectCommandNV.html>"]
#[doc(alias = "VkBindPipelineIndirectCommandNV")]
pub struct BindPipelineIndirectCommandNV {
    pub pipeline_address: DeviceAddress,
}
unsafe impl Send for BindPipelineIndirectCommandNV {}
unsafe impl Sync for BindPipelineIndirectCommandNV {}
impl Default for BindPipelineIndirectCommandNV {
    fn default() -> Self {
        Self {
            pipeline_address: Default::default(),
        }
    }
}
impl BindPipelineIndirectCommandNV {
    #[inline]
    pub fn pipeline_address(mut self, value: DeviceAddress) -> Self {
        self.pipeline_address = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLinearColorAttachmentFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceLinearColorAttachmentFeaturesNV")]
pub struct PhysicalDeviceLinearColorAttachmentFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub linear_color_attachment: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceLinearColorAttachmentFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceLinearColorAttachmentFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceLinearColorAttachmentFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceLinearColorAttachmentFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceLinearColorAttachmentFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceLinearColorAttachmentFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceLinearColorAttachmentFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            linear_color_attachment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceLinearColorAttachmentFeaturesNV<'a> {
    #[inline]
    pub fn linear_color_attachment(mut self, value: impl Into<Bool32>) -> Self {
        self.linear_color_attachment = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR")]
pub struct PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_maximal_reconvergence: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_maximal_reconvergence: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR<'a> {
    #[inline]
    pub fn shader_maximal_reconvergence(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_maximal_reconvergence = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT")]
pub struct PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_compression_control_swapchain: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure
    for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'a>
{
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_compression_control_swapchain: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'a> {
    #[inline]
    pub fn image_compression_control_swapchain(mut self, value: impl Into<Bool32>) -> Self {
        self.image_compression_control_swapchain = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewSampleWeightCreateInfoQCOM.html>"]
#[doc(alias = "VkImageViewSampleWeightCreateInfoQCOM")]
pub struct ImageViewSampleWeightCreateInfoQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub filter_center: Offset2D,
    pub filter_size: Extent2D,
    pub num_phases: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageViewSampleWeightCreateInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageViewSampleWeightCreateInfoQCOM;
}
unsafe impl<'a> Send for ImageViewSampleWeightCreateInfoQCOM<'a> {}
unsafe impl<'a> Sync for ImageViewSampleWeightCreateInfoQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageViewCreateInfo<'b>>
    for ImageViewSampleWeightCreateInfoQCOM<'a>
{
}
impl<'a> Default for ImageViewSampleWeightCreateInfoQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            filter_center: Default::default(),
            filter_size: Default::default(),
            num_phases: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageViewSampleWeightCreateInfoQCOM<'a> {
    #[inline]
    pub fn filter_center(mut self, value: Offset2D) -> Self {
        self.filter_center = value;
        self
    }
    #[inline]
    pub fn filter_size(mut self, value: Extent2D) -> Self {
        self.filter_size = value;
        self
    }
    #[inline]
    pub fn num_phases(mut self, value: u32) -> Self {
        self.num_phases = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageProcessingFeaturesQCOM.html>"]
#[doc(alias = "VkPhysicalDeviceImageProcessingFeaturesQCOM")]
pub struct PhysicalDeviceImageProcessingFeaturesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub texture_sample_weighted: Bool32,
    pub texture_box_filter: Bool32,
    pub texture_block_match: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageProcessingFeaturesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceImageProcessingFeaturesQCOM;
}
unsafe impl<'a> Send for PhysicalDeviceImageProcessingFeaturesQCOM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageProcessingFeaturesQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceImageProcessingFeaturesQCOM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceImageProcessingFeaturesQCOM<'a>
{
}
impl<'a> Default for PhysicalDeviceImageProcessingFeaturesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            texture_sample_weighted: Default::default(),
            texture_box_filter: Default::default(),
            texture_block_match: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageProcessingFeaturesQCOM<'a> {
    #[inline]
    pub fn texture_sample_weighted(mut self, value: impl Into<Bool32>) -> Self {
        self.texture_sample_weighted = value.into();
        self
    }
    #[inline]
    pub fn texture_box_filter(mut self, value: impl Into<Bool32>) -> Self {
        self.texture_box_filter = value.into();
        self
    }
    #[inline]
    pub fn texture_block_match(mut self, value: impl Into<Bool32>) -> Self {
        self.texture_block_match = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageProcessingPropertiesQCOM.html>"]
#[doc(alias = "VkPhysicalDeviceImageProcessingPropertiesQCOM")]
pub struct PhysicalDeviceImageProcessingPropertiesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_weight_filter_phases: u32,
    pub max_weight_filter_dimension: Extent2D,
    pub max_block_match_region: Extent2D,
    pub max_box_filter_block_size: Extent2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageProcessingPropertiesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceImageProcessingPropertiesQCOM;
}
unsafe impl<'a> Send for PhysicalDeviceImageProcessingPropertiesQCOM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageProcessingPropertiesQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceImageProcessingPropertiesQCOM<'a>
{
}
impl<'a> Default for PhysicalDeviceImageProcessingPropertiesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_weight_filter_phases: Default::default(),
            max_weight_filter_dimension: Default::default(),
            max_block_match_region: Default::default(),
            max_box_filter_block_size: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageProcessingPropertiesQCOM<'a> {
    #[inline]
    pub fn max_weight_filter_phases(mut self, value: u32) -> Self {
        self.max_weight_filter_phases = value;
        self
    }
    #[inline]
    pub fn max_weight_filter_dimension(mut self, value: Extent2D) -> Self {
        self.max_weight_filter_dimension = value;
        self
    }
    #[inline]
    pub fn max_block_match_region(mut self, value: Extent2D) -> Self {
        self.max_block_match_region = value;
        self
    }
    #[inline]
    pub fn max_box_filter_block_size(mut self, value: Extent2D) -> Self {
        self.max_box_filter_block_size = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceNestedCommandBufferFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceNestedCommandBufferFeaturesEXT")]
pub struct PhysicalDeviceNestedCommandBufferFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub nested_command_buffer: Bool32,
    pub nested_command_buffer_rendering: Bool32,
    pub nested_command_buffer_simultaneous_use: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceNestedCommandBufferFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceNestedCommandBufferFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceNestedCommandBufferFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceNestedCommandBufferFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceNestedCommandBufferFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceNestedCommandBufferFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceNestedCommandBufferFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            nested_command_buffer: Default::default(),
            nested_command_buffer_rendering: Default::default(),
            nested_command_buffer_simultaneous_use: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceNestedCommandBufferFeaturesEXT<'a> {
    #[inline]
    pub fn nested_command_buffer(mut self, value: impl Into<Bool32>) -> Self {
        self.nested_command_buffer = value.into();
        self
    }
    #[inline]
    pub fn nested_command_buffer_rendering(mut self, value: impl Into<Bool32>) -> Self {
        self.nested_command_buffer_rendering = value.into();
        self
    }
    #[inline]
    pub fn nested_command_buffer_simultaneous_use(mut self, value: impl Into<Bool32>) -> Self {
        self.nested_command_buffer_simultaneous_use = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceNestedCommandBufferPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceNestedCommandBufferPropertiesEXT")]
pub struct PhysicalDeviceNestedCommandBufferPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_command_buffer_nesting_level: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceNestedCommandBufferPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceNestedCommandBufferPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceNestedCommandBufferPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceNestedCommandBufferPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceNestedCommandBufferPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceNestedCommandBufferPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_command_buffer_nesting_level: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceNestedCommandBufferPropertiesEXT<'a> {
    #[inline]
    pub fn max_command_buffer_nesting_level(mut self, value: u32) -> Self {
        self.max_command_buffer_nesting_level = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryAcquireUnmodifiedEXT.html>"]
#[doc(alias = "VkExternalMemoryAcquireUnmodifiedEXT")]
pub struct ExternalMemoryAcquireUnmodifiedEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub acquire_unmodified_memory: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExternalMemoryAcquireUnmodifiedEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExternalMemoryAcquireUnmodifiedEXT;
}
unsafe impl<'a> Send for ExternalMemoryAcquireUnmodifiedEXT<'a> {}
unsafe impl<'a> Sync for ExternalMemoryAcquireUnmodifiedEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BufferMemoryBarrier<'b>>
    for ExternalMemoryAcquireUnmodifiedEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<BufferMemoryBarrier2<'b>>
    for ExternalMemoryAcquireUnmodifiedEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<ImageMemoryBarrier<'b>>
    for ExternalMemoryAcquireUnmodifiedEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<ImageMemoryBarrier2<'b>>
    for ExternalMemoryAcquireUnmodifiedEXT<'a>
{
}
impl<'a> Default for ExternalMemoryAcquireUnmodifiedEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            acquire_unmodified_memory: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExternalMemoryAcquireUnmodifiedEXT<'a> {
    #[inline]
    pub fn acquire_unmodified_memory(mut self, value: impl Into<Bool32>) -> Self {
        self.acquire_unmodified_memory = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceExtendedDynamicState3FeaturesEXT")]
pub struct PhysicalDeviceExtendedDynamicState3FeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub extended_dynamic_state3_tessellation_domain_origin: Bool32,
    pub extended_dynamic_state3_depth_clamp_enable: Bool32,
    pub extended_dynamic_state3_polygon_mode: Bool32,
    pub extended_dynamic_state3_rasterization_samples: Bool32,
    pub extended_dynamic_state3_sample_mask: Bool32,
    pub extended_dynamic_state3_alpha_to_coverage_enable: Bool32,
    pub extended_dynamic_state3_alpha_to_one_enable: Bool32,
    pub extended_dynamic_state3_logic_op_enable: Bool32,
    pub extended_dynamic_state3_color_blend_enable: Bool32,
    pub extended_dynamic_state3_color_blend_equation: Bool32,
    pub extended_dynamic_state3_color_write_mask: Bool32,
    pub extended_dynamic_state3_rasterization_stream: Bool32,
    pub extended_dynamic_state3_conservative_rasterization_mode: Bool32,
    pub extended_dynamic_state3_extra_primitive_overestimation_size: Bool32,
    pub extended_dynamic_state3_depth_clip_enable: Bool32,
    pub extended_dynamic_state3_sample_locations_enable: Bool32,
    pub extended_dynamic_state3_color_blend_advanced: Bool32,
    pub extended_dynamic_state3_provoking_vertex_mode: Bool32,
    pub extended_dynamic_state3_line_rasterization_mode: Bool32,
    pub extended_dynamic_state3_line_stipple_enable: Bool32,
    pub extended_dynamic_state3_depth_clip_negative_one_to_one: Bool32,
    pub extended_dynamic_state3_viewport_wscaling_enable: Bool32,
    pub extended_dynamic_state3_viewport_swizzle: Bool32,
    pub extended_dynamic_state3_coverage_to_color_enable: Bool32,
    pub extended_dynamic_state3_coverage_to_color_location: Bool32,
    pub extended_dynamic_state3_coverage_modulation_mode: Bool32,
    pub extended_dynamic_state3_coverage_modulation_table_enable: Bool32,
    pub extended_dynamic_state3_coverage_modulation_table: Bool32,
    pub extended_dynamic_state3_coverage_reduction_mode: Bool32,
    pub extended_dynamic_state3_representative_fragment_test_enable: Bool32,
    pub extended_dynamic_state3_shading_rate_image_enable: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExtendedDynamicState3FeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceExtendedDynamicState3FeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceExtendedDynamicState3FeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExtendedDynamicState3FeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceExtendedDynamicState3FeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceExtendedDynamicState3FeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceExtendedDynamicState3FeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            extended_dynamic_state3_tessellation_domain_origin: Default::default(),
            extended_dynamic_state3_depth_clamp_enable: Default::default(),
            extended_dynamic_state3_polygon_mode: Default::default(),
            extended_dynamic_state3_rasterization_samples: Default::default(),
            extended_dynamic_state3_sample_mask: Default::default(),
            extended_dynamic_state3_alpha_to_coverage_enable: Default::default(),
            extended_dynamic_state3_alpha_to_one_enable: Default::default(),
            extended_dynamic_state3_logic_op_enable: Default::default(),
            extended_dynamic_state3_color_blend_enable: Default::default(),
            extended_dynamic_state3_color_blend_equation: Default::default(),
            extended_dynamic_state3_color_write_mask: Default::default(),
            extended_dynamic_state3_rasterization_stream: Default::default(),
            extended_dynamic_state3_conservative_rasterization_mode: Default::default(),
            extended_dynamic_state3_extra_primitive_overestimation_size: Default::default(),
            extended_dynamic_state3_depth_clip_enable: Default::default(),
            extended_dynamic_state3_sample_locations_enable: Default::default(),
            extended_dynamic_state3_color_blend_advanced: Default::default(),
            extended_dynamic_state3_provoking_vertex_mode: Default::default(),
            extended_dynamic_state3_line_rasterization_mode: Default::default(),
            extended_dynamic_state3_line_stipple_enable: Default::default(),
            extended_dynamic_state3_depth_clip_negative_one_to_one: Default::default(),
            extended_dynamic_state3_viewport_wscaling_enable: Default::default(),
            extended_dynamic_state3_viewport_swizzle: Default::default(),
            extended_dynamic_state3_coverage_to_color_enable: Default::default(),
            extended_dynamic_state3_coverage_to_color_location: Default::default(),
            extended_dynamic_state3_coverage_modulation_mode: Default::default(),
            extended_dynamic_state3_coverage_modulation_table_enable: Default::default(),
            extended_dynamic_state3_coverage_modulation_table: Default::default(),
            extended_dynamic_state3_coverage_reduction_mode: Default::default(),
            extended_dynamic_state3_representative_fragment_test_enable: Default::default(),
            extended_dynamic_state3_shading_rate_image_enable: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExtendedDynamicState3FeaturesEXT<'a> {
    #[inline]
    pub fn extended_dynamic_state3_tessellation_domain_origin(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_tessellation_domain_origin = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_depth_clamp_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state3_depth_clamp_enable = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_polygon_mode(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state3_polygon_mode = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_rasterization_samples(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_rasterization_samples = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_sample_mask(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state3_sample_mask = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_alpha_to_coverage_enable(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_alpha_to_coverage_enable = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_alpha_to_one_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state3_alpha_to_one_enable = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_logic_op_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state3_logic_op_enable = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_color_blend_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state3_color_blend_enable = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_color_blend_equation(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_color_blend_equation = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_color_write_mask(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state3_color_write_mask = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_rasterization_stream(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_rasterization_stream = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_conservative_rasterization_mode(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_conservative_rasterization_mode = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_extra_primitive_overestimation_size(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_extra_primitive_overestimation_size = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_depth_clip_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state3_depth_clip_enable = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_sample_locations_enable(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_sample_locations_enable = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_color_blend_advanced(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_color_blend_advanced = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_provoking_vertex_mode(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_provoking_vertex_mode = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_line_rasterization_mode(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_line_rasterization_mode = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_line_stipple_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state3_line_stipple_enable = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_depth_clip_negative_one_to_one(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_depth_clip_negative_one_to_one = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_viewport_wscaling_enable(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_viewport_wscaling_enable = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_viewport_swizzle(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_dynamic_state3_viewport_swizzle = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_coverage_to_color_enable(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_coverage_to_color_enable = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_coverage_to_color_location(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_coverage_to_color_location = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_coverage_modulation_mode(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_coverage_modulation_mode = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_coverage_modulation_table_enable(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_coverage_modulation_table_enable = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_coverage_modulation_table(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_coverage_modulation_table = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_coverage_reduction_mode(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_coverage_reduction_mode = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_representative_fragment_test_enable(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_representative_fragment_test_enable = value.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_shading_rate_image_enable(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.extended_dynamic_state3_shading_rate_image_enable = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3PropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceExtendedDynamicState3PropertiesEXT")]
pub struct PhysicalDeviceExtendedDynamicState3PropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub dynamic_primitive_topology_unrestricted: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExtendedDynamicState3PropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceExtendedDynamicState3PropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceExtendedDynamicState3PropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExtendedDynamicState3PropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceExtendedDynamicState3PropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceExtendedDynamicState3PropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            dynamic_primitive_topology_unrestricted: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExtendedDynamicState3PropertiesEXT<'a> {
    #[inline]
    pub fn dynamic_primitive_topology_unrestricted(mut self, value: impl Into<Bool32>) -> Self {
        self.dynamic_primitive_topology_unrestricted = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkColorBlendEquationEXT.html>"]
#[doc(alias = "VkColorBlendEquationEXT")]
pub struct ColorBlendEquationEXT {
    pub src_color_blend_factor: BlendFactor,
    pub dst_color_blend_factor: BlendFactor,
    pub color_blend_op: BlendOp,
    pub src_alpha_blend_factor: BlendFactor,
    pub dst_alpha_blend_factor: BlendFactor,
    pub alpha_blend_op: BlendOp,
}
unsafe impl Send for ColorBlendEquationEXT {}
unsafe impl Sync for ColorBlendEquationEXT {}
impl Default for ColorBlendEquationEXT {
    fn default() -> Self {
        Self {
            src_color_blend_factor: BlendFactor::Zero,
            dst_color_blend_factor: BlendFactor::Zero,
            color_blend_op: BlendOp::Add,
            src_alpha_blend_factor: BlendFactor::Zero,
            dst_alpha_blend_factor: BlendFactor::Zero,
            alpha_blend_op: BlendOp::Add,
        }
    }
}
impl ColorBlendEquationEXT {
    #[inline]
    pub fn src_color_blend_factor(mut self, value: BlendFactor) -> Self {
        self.src_color_blend_factor = value;
        self
    }
    #[inline]
    pub fn dst_color_blend_factor(mut self, value: BlendFactor) -> Self {
        self.dst_color_blend_factor = value;
        self
    }
    #[inline]
    pub fn color_blend_op(mut self, value: BlendOp) -> Self {
        self.color_blend_op = value;
        self
    }
    #[inline]
    pub fn src_alpha_blend_factor(mut self, value: BlendFactor) -> Self {
        self.src_alpha_blend_factor = value;
        self
    }
    #[inline]
    pub fn dst_alpha_blend_factor(mut self, value: BlendFactor) -> Self {
        self.dst_alpha_blend_factor = value;
        self
    }
    #[inline]
    pub fn alpha_blend_op(mut self, value: BlendOp) -> Self {
        self.alpha_blend_op = value;
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkColorBlendAdvancedEXT.html>"]
#[doc(alias = "VkColorBlendAdvancedEXT")]
pub struct ColorBlendAdvancedEXT {
    pub advanced_blend_op: BlendOp,
    pub src_premultiplied: Bool32,
    pub dst_premultiplied: Bool32,
    pub blend_overlap: BlendOverlapEXT,
    pub clamp_results: Bool32,
}
unsafe impl Send for ColorBlendAdvancedEXT {}
unsafe impl Sync for ColorBlendAdvancedEXT {}
impl Default for ColorBlendAdvancedEXT {
    fn default() -> Self {
        Self {
            advanced_blend_op: BlendOp::Add,
            src_premultiplied: Default::default(),
            dst_premultiplied: Default::default(),
            blend_overlap: BlendOverlapEXT::Uncorrelated,
            clamp_results: Default::default(),
        }
    }
}
impl ColorBlendAdvancedEXT {
    #[inline]
    pub fn advanced_blend_op(mut self, value: BlendOp) -> Self {
        self.advanced_blend_op = value;
        self
    }
    #[inline]
    pub fn src_premultiplied(mut self, value: impl Into<Bool32>) -> Self {
        self.src_premultiplied = value.into();
        self
    }
    #[inline]
    pub fn dst_premultiplied(mut self, value: impl Into<Bool32>) -> Self {
        self.dst_premultiplied = value.into();
        self
    }
    #[inline]
    pub fn blend_overlap(mut self, value: BlendOverlapEXT) -> Self {
        self.blend_overlap = value;
        self
    }
    #[inline]
    pub fn clamp_results(mut self, value: impl Into<Bool32>) -> Self {
        self.clamp_results = value.into();
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT")]
pub struct PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub subpass_merge_feedback: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceSubpassMergeFeedbackFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            subpass_merge_feedback: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'a> {
    #[inline]
    pub fn subpass_merge_feedback(mut self, value: impl Into<Bool32>) -> Self {
        self.subpass_merge_feedback = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreationControlEXT.html>"]
#[doc(alias = "VkRenderPassCreationControlEXT")]
pub struct RenderPassCreationControlEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub disallow_merging: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassCreationControlEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassCreationControlEXT;
}
unsafe impl<'a> Send for RenderPassCreationControlEXT<'a> {}
unsafe impl<'a> Sync for RenderPassCreationControlEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderPassCreateInfo2<'b>>
    for RenderPassCreationControlEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<SubpassDescription2<'b>>
    for RenderPassCreationControlEXT<'a>
{
}
impl<'a> Default for RenderPassCreationControlEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            disallow_merging: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassCreationControlEXT<'a> {
    #[inline]
    pub fn disallow_merging(mut self, value: impl Into<Bool32>) -> Self {
        self.disallow_merging = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreationFeedbackInfoEXT.html>"]
#[doc(alias = "VkRenderPassCreationFeedbackInfoEXT")]
pub struct RenderPassCreationFeedbackInfoEXT {
    pub post_merge_subpass_count: u32,
}
unsafe impl Send for RenderPassCreationFeedbackInfoEXT {}
unsafe impl Sync for RenderPassCreationFeedbackInfoEXT {}
impl Default for RenderPassCreationFeedbackInfoEXT {
    fn default() -> Self {
        Self {
            post_merge_subpass_count: Default::default(),
        }
    }
}
impl RenderPassCreationFeedbackInfoEXT {
    #[inline]
    pub fn post_merge_subpass_count(mut self, value: u32) -> Self {
        self.post_merge_subpass_count = value;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreationFeedbackCreateInfoEXT.html>"]
#[doc(alias = "VkRenderPassCreationFeedbackCreateInfoEXT")]
pub struct RenderPassCreationFeedbackCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_render_pass_feedback: *const RenderPassCreationFeedbackInfoEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassCreationFeedbackCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassCreationFeedbackCreateInfoEXT;
}
unsafe impl<'a> Send for RenderPassCreationFeedbackCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for RenderPassCreationFeedbackCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderPassCreateInfo2<'b>>
    for RenderPassCreationFeedbackCreateInfoEXT<'a>
{
}
impl<'a> Default for RenderPassCreationFeedbackCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_render_pass_feedback: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassCreationFeedbackCreateInfoEXT<'a> {
    #[inline]
    pub fn render_pass_feedback(mut self, value: &'a RenderPassCreationFeedbackInfoEXT) -> Self {
        self.p_render_pass_feedback = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassSubpassFeedbackInfoEXT.html>"]
#[doc(alias = "VkRenderPassSubpassFeedbackInfoEXT")]
pub struct RenderPassSubpassFeedbackInfoEXT {
    pub subpass_merge_status: SubpassMergeStatusEXT,
    pub(crate) description: [c_char; MAX_DESCRIPTION_SIZE as _],
    pub post_merge_index: u32,
}
unsafe impl Send for RenderPassSubpassFeedbackInfoEXT {}
unsafe impl Sync for RenderPassSubpassFeedbackInfoEXT {}
impl Default for RenderPassSubpassFeedbackInfoEXT {
    fn default() -> Self {
        Self {
            subpass_merge_status: SubpassMergeStatusEXT::Merged,
            description: array::from_fn(|_| Default::default()),
            post_merge_index: Default::default(),
        }
    }
}
impl RenderPassSubpassFeedbackInfoEXT {
    #[inline]
    pub fn subpass_merge_status(mut self, value: SubpassMergeStatusEXT) -> Self {
        self.subpass_merge_status = value;
        self
    }
    #[inline]
    pub fn post_merge_index(mut self, value: u32) -> Self {
        self.post_merge_index = value;
        self
    }
    pub fn get_description(&self) -> &CStr {
        CStr::from_bytes_until_nul(
            unsafe { mem::transmute::<_, &[u8; MAX_DESCRIPTION_SIZE as _]>(&self.description) }
                .as_slice(),
        )
        .unwrap()
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassSubpassFeedbackCreateInfoEXT.html>"]
#[doc(alias = "VkRenderPassSubpassFeedbackCreateInfoEXT")]
pub struct RenderPassSubpassFeedbackCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_subpass_feedback: *const RenderPassSubpassFeedbackInfoEXT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderPassSubpassFeedbackCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderPassSubpassFeedbackCreateInfoEXT;
}
unsafe impl<'a> Send for RenderPassSubpassFeedbackCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for RenderPassSubpassFeedbackCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubpassDescription2<'b>>
    for RenderPassSubpassFeedbackCreateInfoEXT<'a>
{
}
impl<'a> Default for RenderPassSubpassFeedbackCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_subpass_feedback: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderPassSubpassFeedbackCreateInfoEXT<'a> {
    #[inline]
    pub fn subpass_feedback(mut self, value: &'a RenderPassSubpassFeedbackInfoEXT) -> Self {
        self.p_subpass_feedback = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDirectDriverLoadingInfoLUNARG.html>"]
#[doc(alias = "VkDirectDriverLoadingInfoLUNARG")]
pub struct DirectDriverLoadingInfoLUNARG<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    pub pfn_get_instance_proc_addr: FuncPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DirectDriverLoadingInfoLUNARG<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DirectDriverLoadingInfoLUNARG;
}
unsafe impl<'a> Send for DirectDriverLoadingInfoLUNARG<'a> {}
unsafe impl<'a> Sync for DirectDriverLoadingInfoLUNARG<'a> {}
impl<'a> Default for DirectDriverLoadingInfoLUNARG<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            pfn_get_instance_proc_addr: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DirectDriverLoadingInfoLUNARG<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn pfn_get_instance_proc_addr(mut self, value: FuncPtr) -> Self {
        self.pfn_get_instance_proc_addr = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDirectDriverLoadingListLUNARG.html>"]
#[doc(alias = "VkDirectDriverLoadingListLUNARG")]
pub struct DirectDriverLoadingListLUNARG<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub mode: DirectDriverLoadingModeLUNARG,
    pub(crate) driver_count: u32,
    pub(crate) p_drivers: *const DirectDriverLoadingInfoLUNARG<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DirectDriverLoadingListLUNARG<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DirectDriverLoadingListLUNARG;
}
unsafe impl<'a> Send for DirectDriverLoadingListLUNARG<'a> {}
unsafe impl<'a> Sync for DirectDriverLoadingListLUNARG<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<InstanceCreateInfo<'b>>
    for DirectDriverLoadingListLUNARG<'a>
{
}
impl<'a> Default for DirectDriverLoadingListLUNARG<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            mode: DirectDriverLoadingModeLUNARG::Exclusive,
            driver_count: Default::default(),
            p_drivers: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DirectDriverLoadingListLUNARG<'a> {
    #[inline]
    pub fn mode(mut self, value: DirectDriverLoadingModeLUNARG) -> Self {
        self.mode = value;
        self
    }
    #[inline]
    pub fn drivers(
        mut self,
        p_drivers: impl AsSlice<'a, DirectDriverLoadingInfoLUNARG<'a>>,
    ) -> Self {
        self.p_drivers = p_drivers.as_slice().as_ptr().cast();
        self.driver_count = p_drivers.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT")]
pub struct PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_module_identifier: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderModuleIdentifierFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_module_identifier: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'a> {
    #[inline]
    pub fn shader_module_identifier(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_module_identifier = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT")]
pub struct PhysicalDeviceShaderModuleIdentifierPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_module_identifier_algorithm_uuid: [u8; UUID_SIZE as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderModuleIdentifierPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderModuleIdentifierPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceShaderModuleIdentifierPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderModuleIdentifierPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceShaderModuleIdentifierPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderModuleIdentifierPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_module_identifier_algorithm_uuid: array::from_fn(|_| Default::default()),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderModuleIdentifierPropertiesEXT<'a> {
    #[inline]
    pub fn shader_module_identifier_algorithm_uuid(mut self, value: [u8; UUID_SIZE as _]) -> Self {
        self.shader_module_identifier_algorithm_uuid = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageModuleIdentifierCreateInfoEXT.html>"]
#[doc(alias = "VkPipelineShaderStageModuleIdentifierCreateInfoEXT")]
pub struct PipelineShaderStageModuleIdentifierCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) identifier_size: u32,
    pub(crate) p_identifier: *const u8,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineShaderStageModuleIdentifierCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineShaderStageModuleIdentifierCreateInfoEXT;
}
unsafe impl<'a> Send for PipelineShaderStageModuleIdentifierCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for PipelineShaderStageModuleIdentifierCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineShaderStageCreateInfo<'b>>
    for PipelineShaderStageModuleIdentifierCreateInfoEXT<'a>
{
}
impl<'a> Default for PipelineShaderStageModuleIdentifierCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            identifier_size: Default::default(),
            p_identifier: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineShaderStageModuleIdentifierCreateInfoEXT<'a> {
    #[inline]
    pub fn identifier(mut self, p_identifier: impl AsSlice<'a, u8>) -> Self {
        self.p_identifier = p_identifier.as_slice().as_ptr().cast();
        self.identifier_size = p_identifier.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleIdentifierEXT.html>"]
#[doc(alias = "VkShaderModuleIdentifierEXT")]
pub struct ShaderModuleIdentifierEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) identifier_size: u32,
    pub(crate) identifier: [u8; MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ShaderModuleIdentifierEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ShaderModuleIdentifierEXT;
}
unsafe impl<'a> Send for ShaderModuleIdentifierEXT<'a> {}
unsafe impl<'a> Sync for ShaderModuleIdentifierEXT<'a> {}
impl<'a> Default for ShaderModuleIdentifierEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            identifier_size: Default::default(),
            identifier: array::from_fn(|_| Default::default()),
            phantom: PhantomData,
        }
    }
}
impl<'a> ShaderModuleIdentifierEXT<'a> {
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT")]
pub struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub rasterization_order_color_attachment_access: Bool32,
    pub rasterization_order_depth_attachment_access: Bool32,
    pub rasterization_order_stencil_attachment_access: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure
    for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT<'a>
{
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            rasterization_order_color_attachment_access: Default::default(),
            rasterization_order_depth_attachment_access: Default::default(),
            rasterization_order_stencil_attachment_access: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT<'a> {
    #[inline]
    pub fn rasterization_order_color_attachment_access(mut self, value: impl Into<Bool32>) -> Self {
        self.rasterization_order_color_attachment_access = value.into();
        self
    }
    #[inline]
    pub fn rasterization_order_depth_attachment_access(mut self, value: impl Into<Bool32>) -> Self {
        self.rasterization_order_depth_attachment_access = value.into();
        self
    }
    #[inline]
    pub fn rasterization_order_stencil_attachment_access(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.rasterization_order_stencil_attachment_access = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM<'a> =
    PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceOpticalFlowFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceOpticalFlowFeaturesNV")]
pub struct PhysicalDeviceOpticalFlowFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub optical_flow: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceOpticalFlowFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceOpticalFlowFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceOpticalFlowFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceOpticalFlowFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceOpticalFlowFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceOpticalFlowFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceOpticalFlowFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            optical_flow: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceOpticalFlowFeaturesNV<'a> {
    #[inline]
    pub fn optical_flow(mut self, value: impl Into<Bool32>) -> Self {
        self.optical_flow = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceOpticalFlowPropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceOpticalFlowPropertiesNV")]
pub struct PhysicalDeviceOpticalFlowPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub supported_output_grid_sizes: OpticalFlowGridSizeFlagsNV,
    pub supported_hint_grid_sizes: OpticalFlowGridSizeFlagsNV,
    pub hint_supported: Bool32,
    pub cost_supported: Bool32,
    pub bidirectional_flow_supported: Bool32,
    pub global_flow_supported: Bool32,
    pub min_width: u32,
    pub min_height: u32,
    pub max_width: u32,
    pub max_height: u32,
    pub max_num_regions_of_interest: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceOpticalFlowPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceOpticalFlowPropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceOpticalFlowPropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceOpticalFlowPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceOpticalFlowPropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceOpticalFlowPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            supported_output_grid_sizes: Default::default(),
            supported_hint_grid_sizes: Default::default(),
            hint_supported: Default::default(),
            cost_supported: Default::default(),
            bidirectional_flow_supported: Default::default(),
            global_flow_supported: Default::default(),
            min_width: Default::default(),
            min_height: Default::default(),
            max_width: Default::default(),
            max_height: Default::default(),
            max_num_regions_of_interest: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceOpticalFlowPropertiesNV<'a> {
    #[inline]
    pub fn supported_output_grid_sizes(mut self, value: OpticalFlowGridSizeFlagsNV) -> Self {
        self.supported_output_grid_sizes = value;
        self
    }
    #[inline]
    pub fn supported_hint_grid_sizes(mut self, value: OpticalFlowGridSizeFlagsNV) -> Self {
        self.supported_hint_grid_sizes = value;
        self
    }
    #[inline]
    pub fn hint_supported(mut self, value: impl Into<Bool32>) -> Self {
        self.hint_supported = value.into();
        self
    }
    #[inline]
    pub fn cost_supported(mut self, value: impl Into<Bool32>) -> Self {
        self.cost_supported = value.into();
        self
    }
    #[inline]
    pub fn bidirectional_flow_supported(mut self, value: impl Into<Bool32>) -> Self {
        self.bidirectional_flow_supported = value.into();
        self
    }
    #[inline]
    pub fn global_flow_supported(mut self, value: impl Into<Bool32>) -> Self {
        self.global_flow_supported = value.into();
        self
    }
    #[inline]
    pub fn min_width(mut self, value: u32) -> Self {
        self.min_width = value;
        self
    }
    #[inline]
    pub fn min_height(mut self, value: u32) -> Self {
        self.min_height = value;
        self
    }
    #[inline]
    pub fn max_width(mut self, value: u32) -> Self {
        self.max_width = value;
        self
    }
    #[inline]
    pub fn max_height(mut self, value: u32) -> Self {
        self.max_height = value;
        self
    }
    #[inline]
    pub fn max_num_regions_of_interest(mut self, value: u32) -> Self {
        self.max_num_regions_of_interest = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpticalFlowImageFormatInfoNV.html>"]
#[doc(alias = "VkOpticalFlowImageFormatInfoNV")]
pub struct OpticalFlowImageFormatInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub usage: OpticalFlowUsageFlagsNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for OpticalFlowImageFormatInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::OpticalFlowImageFormatInfoNV;
}
unsafe impl<'a> Send for OpticalFlowImageFormatInfoNV<'a> {}
unsafe impl<'a> Sync for OpticalFlowImageFormatInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceImageFormatInfo2<'b>>
    for OpticalFlowImageFormatInfoNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>> for OpticalFlowImageFormatInfoNV<'a> {}
impl<'a> Default for OpticalFlowImageFormatInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            usage: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> OpticalFlowImageFormatInfoNV<'a> {
    #[inline]
    pub fn usage(mut self, value: OpticalFlowUsageFlagsNV) -> Self {
        self.usage = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpticalFlowImageFormatPropertiesNV.html>"]
#[doc(alias = "VkOpticalFlowImageFormatPropertiesNV")]
pub struct OpticalFlowImageFormatPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub format: Format,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for OpticalFlowImageFormatPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::OpticalFlowImageFormatPropertiesNV;
}
unsafe impl<'a> Send for OpticalFlowImageFormatPropertiesNV<'a> {}
unsafe impl<'a> Sync for OpticalFlowImageFormatPropertiesNV<'a> {}
impl<'a> Default for OpticalFlowImageFormatPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            format: Format::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> OpticalFlowImageFormatPropertiesNV<'a> {
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpticalFlowSessionCreateInfoNV.html>"]
#[doc(alias = "VkOpticalFlowSessionCreateInfoNV")]
pub struct OpticalFlowSessionCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub width: u32,
    pub height: u32,
    pub image_format: Format,
    pub flow_vector_format: Format,
    pub cost_format: Format,
    pub output_grid_size: OpticalFlowGridSizeFlagsNV,
    pub hint_grid_size: OpticalFlowGridSizeFlagsNV,
    pub performance_level: OpticalFlowPerformanceLevelNV,
    pub flags: OpticalFlowSessionCreateFlagsNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for OpticalFlowSessionCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::OpticalFlowSessionCreateInfoNV;
}
unsafe impl<'a> Send for OpticalFlowSessionCreateInfoNV<'a> {}
unsafe impl<'a> Sync for OpticalFlowSessionCreateInfoNV<'a> {}
impl<'a> Default for OpticalFlowSessionCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            width: Default::default(),
            height: Default::default(),
            image_format: Format::Undefined,
            flow_vector_format: Format::Undefined,
            cost_format: Format::Undefined,
            output_grid_size: Default::default(),
            hint_grid_size: Default::default(),
            performance_level: OpticalFlowPerformanceLevelNV::Unknown,
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> OpticalFlowSessionCreateInfoNV<'a> {
    #[inline]
    pub fn width(mut self, value: u32) -> Self {
        self.width = value;
        self
    }
    #[inline]
    pub fn height(mut self, value: u32) -> Self {
        self.height = value;
        self
    }
    #[inline]
    pub fn image_format(mut self, value: Format) -> Self {
        self.image_format = value;
        self
    }
    #[inline]
    pub fn flow_vector_format(mut self, value: Format) -> Self {
        self.flow_vector_format = value;
        self
    }
    #[inline]
    pub fn cost_format(mut self, value: Format) -> Self {
        self.cost_format = value;
        self
    }
    #[inline]
    pub fn output_grid_size(mut self, value: OpticalFlowGridSizeFlagsNV) -> Self {
        self.output_grid_size = value;
        self
    }
    #[inline]
    pub fn hint_grid_size(mut self, value: OpticalFlowGridSizeFlagsNV) -> Self {
        self.hint_grid_size = value;
        self
    }
    #[inline]
    pub fn performance_level(mut self, value: OpticalFlowPerformanceLevelNV) -> Self {
        self.performance_level = value;
        self
    }
    #[inline]
    pub fn flags(mut self, value: OpticalFlowSessionCreateFlagsNV) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpticalFlowSessionCreatePrivateDataInfoNV.html>"]
#[doc(alias = "VkOpticalFlowSessionCreatePrivateDataInfoNV")]
pub struct OpticalFlowSessionCreatePrivateDataInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub id: u32,
    pub size: u32,
    pub p_private_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for OpticalFlowSessionCreatePrivateDataInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::OpticalFlowSessionCreatePrivateDataInfoNV;
}
unsafe impl<'a> Send for OpticalFlowSessionCreatePrivateDataInfoNV<'a> {}
unsafe impl<'a> Sync for OpticalFlowSessionCreatePrivateDataInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<OpticalFlowSessionCreateInfoNV<'b>>
    for OpticalFlowSessionCreatePrivateDataInfoNV<'a>
{
}
impl<'a> Default for OpticalFlowSessionCreatePrivateDataInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            id: Default::default(),
            size: Default::default(),
            p_private_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> OpticalFlowSessionCreatePrivateDataInfoNV<'a> {
    #[inline]
    pub fn id(mut self, value: u32) -> Self {
        self.id = value;
        self
    }
    #[inline]
    pub fn size(mut self, value: u32) -> Self {
        self.size = value;
        self
    }
    #[inline]
    pub fn private_data(mut self, value: VoidPtr) -> Self {
        self.p_private_data = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpticalFlowExecuteInfoNV.html>"]
#[doc(alias = "VkOpticalFlowExecuteInfoNV")]
pub struct OpticalFlowExecuteInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: OpticalFlowExecuteFlagsNV,
    pub(crate) region_count: u32,
    pub(crate) p_regions: *const Rect2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for OpticalFlowExecuteInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::OpticalFlowExecuteInfoNV;
}
unsafe impl<'a> Send for OpticalFlowExecuteInfoNV<'a> {}
unsafe impl<'a> Sync for OpticalFlowExecuteInfoNV<'a> {}
impl<'a> Default for OpticalFlowExecuteInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            region_count: Default::default(),
            p_regions: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> OpticalFlowExecuteInfoNV<'a> {
    #[inline]
    pub fn flags(mut self, value: OpticalFlowExecuteFlagsNV) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn regions(mut self, p_regions: impl AsSlice<'a, Rect2D>) -> Self {
        self.p_regions = p_regions.as_slice().as_ptr().cast();
        self.region_count = p_regions.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLegacyDitheringFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceLegacyDitheringFeaturesEXT")]
pub struct PhysicalDeviceLegacyDitheringFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub legacy_dithering: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceLegacyDitheringFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceLegacyDitheringFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceLegacyDitheringFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceLegacyDitheringFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceLegacyDitheringFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceLegacyDitheringFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceLegacyDitheringFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            legacy_dithering: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceLegacyDitheringFeaturesEXT<'a> {
    #[inline]
    pub fn legacy_dithering(mut self, value: impl Into<Bool32>) -> Self {
        self.legacy_dithering = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineProtectedAccessFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDevicePipelineProtectedAccessFeaturesEXT")]
pub struct PhysicalDevicePipelineProtectedAccessFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline_protected_access: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePipelineProtectedAccessFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePipelineProtectedAccessFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDevicePipelineProtectedAccessFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePipelineProtectedAccessFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePipelineProtectedAccessFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePipelineProtectedAccessFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDevicePipelineProtectedAccessFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline_protected_access: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePipelineProtectedAccessFeaturesEXT<'a> {
    #[inline]
    pub fn pipeline_protected_access(mut self, value: impl Into<Bool32>) -> Self {
        self.pipeline_protected_access = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalFormatResolveFeaturesANDROID.html>"]
#[doc(alias = "VkPhysicalDeviceExternalFormatResolveFeaturesANDROID")]
pub struct PhysicalDeviceExternalFormatResolveFeaturesANDROID<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub external_format_resolve: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExternalFormatResolveFeaturesANDROID<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceExternalFormatResolveFeaturesANDROID;
}
unsafe impl<'a> Send for PhysicalDeviceExternalFormatResolveFeaturesANDROID<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExternalFormatResolveFeaturesANDROID<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceExternalFormatResolveFeaturesANDROID<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceExternalFormatResolveFeaturesANDROID<'a>
{
}
impl<'a> Default for PhysicalDeviceExternalFormatResolveFeaturesANDROID<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            external_format_resolve: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExternalFormatResolveFeaturesANDROID<'a> {
    #[inline]
    pub fn external_format_resolve(mut self, value: impl Into<Bool32>) -> Self {
        self.external_format_resolve = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalFormatResolvePropertiesANDROID.html>"]
#[doc(alias = "VkPhysicalDeviceExternalFormatResolvePropertiesANDROID")]
pub struct PhysicalDeviceExternalFormatResolvePropertiesANDROID<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub null_color_attachment_with_external_format_resolve: Bool32,
    pub external_format_resolve_chroma_offset_x: ChromaLocation,
    pub external_format_resolve_chroma_offset_y: ChromaLocation,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExternalFormatResolvePropertiesANDROID<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceExternalFormatResolvePropertiesANDROID;
}
unsafe impl<'a> Send for PhysicalDeviceExternalFormatResolvePropertiesANDROID<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExternalFormatResolvePropertiesANDROID<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceExternalFormatResolvePropertiesANDROID<'a>
{
}
impl<'a> Default for PhysicalDeviceExternalFormatResolvePropertiesANDROID<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            null_color_attachment_with_external_format_resolve: Default::default(),
            external_format_resolve_chroma_offset_x: ChromaLocation::CositedEven,
            external_format_resolve_chroma_offset_y: ChromaLocation::CositedEven,
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExternalFormatResolvePropertiesANDROID<'a> {
    #[inline]
    pub fn null_color_attachment_with_external_format_resolve(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.null_color_attachment_with_external_format_resolve = value.into();
        self
    }
    #[inline]
    pub fn external_format_resolve_chroma_offset_x(mut self, value: ChromaLocation) -> Self {
        self.external_format_resolve_chroma_offset_x = value;
        self
    }
    #[inline]
    pub fn external_format_resolve_chroma_offset_y(mut self, value: ChromaLocation) -> Self {
        self.external_format_resolve_chroma_offset_y = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferFormatResolvePropertiesANDROID.html>"]
#[doc(alias = "VkAndroidHardwareBufferFormatResolvePropertiesANDROID")]
pub struct AndroidHardwareBufferFormatResolvePropertiesANDROID<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub color_attachment_format: Format,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AndroidHardwareBufferFormatResolvePropertiesANDROID<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::AndroidHardwareBufferFormatResolvePropertiesANDROID;
}
unsafe impl<'a> Send for AndroidHardwareBufferFormatResolvePropertiesANDROID<'a> {}
unsafe impl<'a> Sync for AndroidHardwareBufferFormatResolvePropertiesANDROID<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<AndroidHardwareBufferPropertiesANDROID<'b>>
    for AndroidHardwareBufferFormatResolvePropertiesANDROID<'a>
{
}
impl<'a> Default for AndroidHardwareBufferFormatResolvePropertiesANDROID<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            color_attachment_format: Format::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> AndroidHardwareBufferFormatResolvePropertiesANDROID<'a> {
    #[inline]
    pub fn color_attachment_format(mut self, value: Format) -> Self {
        self.color_attachment_format = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance5FeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceMaintenance5FeaturesKHR")]
pub struct PhysicalDeviceMaintenance5FeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub maintenance5: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMaintenance5FeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMaintenance5FeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceMaintenance5FeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMaintenance5FeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMaintenance5FeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMaintenance5FeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceMaintenance5FeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            maintenance5: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMaintenance5FeaturesKHR<'a> {
    #[inline]
    pub fn maintenance5(mut self, value: impl Into<Bool32>) -> Self {
        self.maintenance5 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance5PropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceMaintenance5PropertiesKHR")]
pub struct PhysicalDeviceMaintenance5PropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub early_fragment_multisample_coverage_after_sample_counting: Bool32,
    pub early_fragment_sample_mask_test_before_sample_counting: Bool32,
    pub depth_stencil_swizzle_one_support: Bool32,
    pub polygon_mode_point_size: Bool32,
    pub non_strict_single_pixel_wide_lines_use_parallelogram: Bool32,
    pub non_strict_wide_lines_use_parallelogram: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMaintenance5PropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMaintenance5PropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceMaintenance5PropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMaintenance5PropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceMaintenance5PropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceMaintenance5PropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            early_fragment_multisample_coverage_after_sample_counting: Default::default(),
            early_fragment_sample_mask_test_before_sample_counting: Default::default(),
            depth_stencil_swizzle_one_support: Default::default(),
            polygon_mode_point_size: Default::default(),
            non_strict_single_pixel_wide_lines_use_parallelogram: Default::default(),
            non_strict_wide_lines_use_parallelogram: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMaintenance5PropertiesKHR<'a> {
    #[inline]
    pub fn early_fragment_multisample_coverage_after_sample_counting(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.early_fragment_multisample_coverage_after_sample_counting = value.into();
        self
    }
    #[inline]
    pub fn early_fragment_sample_mask_test_before_sample_counting(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.early_fragment_sample_mask_test_before_sample_counting = value.into();
        self
    }
    #[inline]
    pub fn depth_stencil_swizzle_one_support(mut self, value: impl Into<Bool32>) -> Self {
        self.depth_stencil_swizzle_one_support = value.into();
        self
    }
    #[inline]
    pub fn polygon_mode_point_size(mut self, value: impl Into<Bool32>) -> Self {
        self.polygon_mode_point_size = value.into();
        self
    }
    #[inline]
    pub fn non_strict_single_pixel_wide_lines_use_parallelogram(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.non_strict_single_pixel_wide_lines_use_parallelogram = value.into();
        self
    }
    #[inline]
    pub fn non_strict_wide_lines_use_parallelogram(mut self, value: impl Into<Bool32>) -> Self {
        self.non_strict_wide_lines_use_parallelogram = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingAreaInfoKHR.html>"]
#[doc(alias = "VkRenderingAreaInfoKHR")]
pub struct RenderingAreaInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub view_mask: u32,
    pub(crate) color_attachment_count: u32,
    pub(crate) p_color_attachment_formats: *const Format,
    pub depth_attachment_format: Format,
    pub stencil_attachment_format: Format,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for RenderingAreaInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::RenderingAreaInfoKHR;
}
unsafe impl<'a> Send for RenderingAreaInfoKHR<'a> {}
unsafe impl<'a> Sync for RenderingAreaInfoKHR<'a> {}
impl<'a> Default for RenderingAreaInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            view_mask: Default::default(),
            color_attachment_count: Default::default(),
            p_color_attachment_formats: ptr::null(),
            depth_attachment_format: Format::Undefined,
            stencil_attachment_format: Format::Undefined,
            phantom: PhantomData,
        }
    }
}
impl<'a> RenderingAreaInfoKHR<'a> {
    #[inline]
    pub fn view_mask(mut self, value: u32) -> Self {
        self.view_mask = value;
        self
    }
    #[inline]
    pub fn depth_attachment_format(mut self, value: Format) -> Self {
        self.depth_attachment_format = value;
        self
    }
    #[inline]
    pub fn stencil_attachment_format(mut self, value: Format) -> Self {
        self.stencil_attachment_format = value;
        self
    }
    #[inline]
    pub fn color_attachment_formats(
        mut self,
        p_color_attachment_formats: impl AsSlice<'a, Format>,
    ) -> Self {
        self.p_color_attachment_formats = p_color_attachment_formats.as_slice().as_ptr().cast();
        self.color_attachment_count = p_color_attachment_formats.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceImageSubresourceInfoKHR.html>"]
#[doc(alias = "VkDeviceImageSubresourceInfoKHR")]
pub struct DeviceImageSubresourceInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_create_info: *const ImageCreateInfo<'a>,
    pub p_subresource: *const ImageSubresource2KHR<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for DeviceImageSubresourceInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::DeviceImageSubresourceInfoKHR;
}
unsafe impl<'a> Send for DeviceImageSubresourceInfoKHR<'a> {}
unsafe impl<'a> Sync for DeviceImageSubresourceInfoKHR<'a> {}
impl<'a> Default for DeviceImageSubresourceInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_create_info: ptr::null(),
            p_subresource: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> DeviceImageSubresourceInfoKHR<'a> {
    #[inline]
    pub fn create_info(mut self, value: &'a ImageCreateInfo<'a>) -> Self {
        self.p_create_info = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn subresource(mut self, value: &'a ImageSubresource2KHR<'a>) -> Self {
        self.p_subresource = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresource2KHR.html>"]
#[doc(alias = "VkImageSubresource2KHR")]
pub struct ImageSubresource2KHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_subresource: ImageSubresource,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageSubresource2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageSubresource2KHR;
}
unsafe impl<'a> Send for ImageSubresource2KHR<'a> {}
unsafe impl<'a> Sync for ImageSubresource2KHR<'a> {}
impl<'a> Default for ImageSubresource2KHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_subresource: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageSubresource2KHR<'a> {
    #[inline]
    pub fn image_subresource(mut self, value: ImageSubresource) -> Self {
        self.image_subresource = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type ImageSubresource2EXT<'a> = ImageSubresource2KHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubresourceLayout2KHR.html>"]
#[doc(alias = "VkSubresourceLayout2KHR")]
pub struct SubresourceLayout2KHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub subresource_layout: SubresourceLayout,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SubresourceLayout2KHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SubresourceLayout2KHR;
}
unsafe impl<'a> Send for SubresourceLayout2KHR<'a> {}
unsafe impl<'a> Sync for SubresourceLayout2KHR<'a> {}
impl<'a> Default for SubresourceLayout2KHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            subresource_layout: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SubresourceLayout2KHR<'a> {
    #[inline]
    pub fn subresource_layout(mut self, value: SubresourceLayout) -> Self {
        self.subresource_layout = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type SubresourceLayout2EXT<'a> = SubresourceLayout2KHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlags2CreateInfoKHR.html>"]
#[doc(alias = "VkPipelineCreateFlags2CreateInfoKHR")]
pub struct PipelineCreateFlags2CreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineCreateFlags2CreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PipelineCreateFlags2CreateInfoKHR;
}
unsafe impl<'a> Send for PipelineCreateFlags2CreateInfoKHR<'a> {}
unsafe impl<'a> Sync for PipelineCreateFlags2CreateInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ComputePipelineCreateInfo<'b>>
    for PipelineCreateFlags2CreateInfoKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<GraphicsPipelineCreateInfo<'b>>
    for PipelineCreateFlags2CreateInfoKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<RayTracingPipelineCreateInfoNV<'b>>
    for PipelineCreateFlags2CreateInfoKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<RayTracingPipelineCreateInfoKHR<'b>>
    for PipelineCreateFlags2CreateInfoKHR<'a>
{
}
impl<'a> Default for PipelineCreateFlags2CreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineCreateFlags2CreateInfoKHR<'a> {
    #[inline]
    pub fn flags(mut self, value: u32) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferUsageFlags2CreateInfoKHR.html>"]
#[doc(alias = "VkBufferUsageFlags2CreateInfoKHR")]
pub struct BufferUsageFlags2CreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub usage: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BufferUsageFlags2CreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BufferUsageFlags2CreateInfoKHR;
}
unsafe impl<'a> Send for BufferUsageFlags2CreateInfoKHR<'a> {}
unsafe impl<'a> Sync for BufferUsageFlags2CreateInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BufferViewCreateInfo<'b>>
    for BufferUsageFlags2CreateInfoKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<BufferCreateInfo<'b>>
    for BufferUsageFlags2CreateInfoKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceExternalBufferInfo<'b>>
    for BufferUsageFlags2CreateInfoKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DescriptorBufferBindingInfoEXT<'b>>
    for BufferUsageFlags2CreateInfoKHR<'a>
{
}
impl<'a> Default for BufferUsageFlags2CreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            usage: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BufferUsageFlags2CreateInfoKHR<'a> {
    #[inline]
    pub fn usage(mut self, value: u32) -> Self {
        self.usage = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR")]
pub struct PhysicalDeviceRayTracingPositionFetchFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ray_tracing_position_fetch: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRayTracingPositionFetchFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceRayTracingPositionFetchFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceRayTracingPositionFetchFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRayTracingPositionFetchFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRayTracingPositionFetchFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRayTracingPositionFetchFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceRayTracingPositionFetchFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ray_tracing_position_fetch: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRayTracingPositionFetchFeaturesKHR<'a> {
    #[inline]
    pub fn ray_tracing_position_fetch(mut self, value: impl Into<Bool32>) -> Self {
        self.ray_tracing_position_fetch = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderObjectFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceShaderObjectFeaturesEXT")]
pub struct PhysicalDeviceShaderObjectFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_object: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderObjectFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderObjectFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceShaderObjectFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderObjectFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderObjectFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderObjectFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderObjectFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_object: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderObjectFeaturesEXT<'a> {
    #[inline]
    pub fn shader_object(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_object = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderObjectPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceShaderObjectPropertiesEXT")]
pub struct PhysicalDeviceShaderObjectPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_binary_uuid: [u8; UUID_SIZE as _],
    pub shader_binary_version: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderObjectPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceShaderObjectPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceShaderObjectPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderObjectPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceShaderObjectPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderObjectPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_binary_uuid: array::from_fn(|_| Default::default()),
            shader_binary_version: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderObjectPropertiesEXT<'a> {
    #[inline]
    pub fn shader_binary_uuid(mut self, value: [u8; UUID_SIZE as _]) -> Self {
        self.shader_binary_uuid = value;
        self
    }
    #[inline]
    pub fn shader_binary_version(mut self, value: u32) -> Self {
        self.shader_binary_version = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderCreateInfoEXT.html>"]
#[doc(alias = "VkShaderCreateInfoEXT")]
pub struct ShaderCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub flags: ShaderCreateFlagsEXT,
    pub stage: ShaderStageFlags,
    pub next_stage: ShaderStageFlags,
    pub code_type: ShaderCodeTypeEXT,
    pub(crate) code_size: usize,
    pub(crate) p_code: VoidPtr,
    pub p_name: *const c_char,
    pub set_layout_count: u32,
    pub(crate) p_set_layouts: *const DescriptorSetLayout,
    pub push_constant_range_count: u32,
    pub(crate) p_push_constant_ranges: *const PushConstantRange,
    pub p_specialization_info: *const SpecializationInfo<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ShaderCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ShaderCreateInfoEXT;
}
unsafe impl<'a> Send for ShaderCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for ShaderCreateInfoEXT<'a> {}
impl<'a> Default for ShaderCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            flags: Default::default(),
            stage: Default::default(),
            next_stage: Default::default(),
            code_type: ShaderCodeTypeEXT::Binary,
            code_size: Default::default(),
            p_code: ptr::null(),
            p_name: ptr::null(),
            set_layout_count: Default::default(),
            p_set_layouts: ptr::null(),
            push_constant_range_count: Default::default(),
            p_push_constant_ranges: ptr::null(),
            p_specialization_info: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ShaderCreateInfoEXT<'a> {
    #[inline]
    pub fn flags(mut self, value: ShaderCreateFlagsEXT) -> Self {
        self.flags = value;
        self
    }
    #[inline]
    pub fn stage(mut self, value: ShaderStageFlags) -> Self {
        self.stage = value;
        self
    }
    #[inline]
    pub fn next_stage(mut self, value: ShaderStageFlags) -> Self {
        self.next_stage = value;
        self
    }
    #[inline]
    pub fn code_type(mut self, value: ShaderCodeTypeEXT) -> Self {
        self.code_type = value;
        self
    }
    #[inline]
    pub fn name(mut self, value: Option<&'a CStr>) -> Self {
        self.p_name = value.map(|v| v.as_ptr()).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn set_layout_count(mut self, value: u32) -> Self {
        self.set_layout_count = value;
        self
    }
    #[inline]
    pub fn push_constant_range_count(mut self, value: u32) -> Self {
        self.push_constant_range_count = value;
        self
    }
    #[inline]
    pub fn specialization_info(mut self, value: Option<&'a SpecializationInfo<'a>>) -> Self {
        self.p_specialization_info = value.map(|v| ptr::from_ref(v)).unwrap_or(ptr::null());
        self
    }
    #[inline]
    pub fn code(mut self, p_code: impl AsSlice<'a, u8>) -> Self {
        self.p_code = p_code.as_slice().as_ptr().cast();
        self.code_size = p_code.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn set_layouts<V0: Alias<raw::DescriptorSetLayout> + 'a>(
        mut self,
        p_set_layouts: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_set_layouts = p_set_layouts.as_slice().as_ptr().cast();
        self.set_layout_count = p_set_layouts.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_constant_ranges(
        mut self,
        p_push_constant_ranges: impl AsSlice<'a, PushConstantRange>,
    ) -> Self {
        self.p_push_constant_ranges = p_push_constant_ranges.as_slice().as_ptr().cast();
        self.push_constant_range_count = p_push_constant_ranges.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTilePropertiesFeaturesQCOM.html>"]
#[doc(alias = "VkPhysicalDeviceTilePropertiesFeaturesQCOM")]
pub struct PhysicalDeviceTilePropertiesFeaturesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub tile_properties: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceTilePropertiesFeaturesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceTilePropertiesFeaturesQCOM;
}
unsafe impl<'a> Send for PhysicalDeviceTilePropertiesFeaturesQCOM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceTilePropertiesFeaturesQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceTilePropertiesFeaturesQCOM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceTilePropertiesFeaturesQCOM<'a>
{
}
impl<'a> Default for PhysicalDeviceTilePropertiesFeaturesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            tile_properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceTilePropertiesFeaturesQCOM<'a> {
    #[inline]
    pub fn tile_properties(mut self, value: impl Into<Bool32>) -> Self {
        self.tile_properties = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTilePropertiesQCOM.html>"]
#[doc(alias = "VkTilePropertiesQCOM")]
pub struct TilePropertiesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub tile_size: Extent3D,
    pub apron_size: Extent2D,
    pub origin: Offset2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for TilePropertiesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::TilePropertiesQCOM;
}
unsafe impl<'a> Send for TilePropertiesQCOM<'a> {}
unsafe impl<'a> Sync for TilePropertiesQCOM<'a> {}
impl<'a> Default for TilePropertiesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            tile_size: Default::default(),
            apron_size: Default::default(),
            origin: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> TilePropertiesQCOM<'a> {
    #[inline]
    pub fn tile_size(mut self, value: Extent3D) -> Self {
        self.tile_size = value;
        self
    }
    #[inline]
    pub fn apron_size(mut self, value: Extent2D) -> Self {
        self.apron_size = value;
        self
    }
    #[inline]
    pub fn origin(mut self, value: Offset2D) -> Self {
        self.origin = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAmigoProfilingFeaturesSEC.html>"]
#[doc(alias = "VkPhysicalDeviceAmigoProfilingFeaturesSEC")]
pub struct PhysicalDeviceAmigoProfilingFeaturesSEC<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub amigo_profiling: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceAmigoProfilingFeaturesSEC<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceAmigoProfilingFeaturesSEC;
}
unsafe impl<'a> Send for PhysicalDeviceAmigoProfilingFeaturesSEC<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceAmigoProfilingFeaturesSEC<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceAmigoProfilingFeaturesSEC<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceAmigoProfilingFeaturesSEC<'a>
{
}
impl<'a> Default for PhysicalDeviceAmigoProfilingFeaturesSEC<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            amigo_profiling: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceAmigoProfilingFeaturesSEC<'a> {
    #[inline]
    pub fn amigo_profiling(mut self, value: impl Into<Bool32>) -> Self {
        self.amigo_profiling = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAmigoProfilingSubmitInfoSEC.html>"]
#[doc(alias = "VkAmigoProfilingSubmitInfoSEC")]
pub struct AmigoProfilingSubmitInfoSEC<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub first_draw_timestamp: u64,
    pub swap_buffer_timestamp: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for AmigoProfilingSubmitInfoSEC<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::AmigoProfilingSubmitInfoSEC;
}
unsafe impl<'a> Send for AmigoProfilingSubmitInfoSEC<'a> {}
unsafe impl<'a> Sync for AmigoProfilingSubmitInfoSEC<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo<'b>> for AmigoProfilingSubmitInfoSEC<'a> {}
impl<'a> Default for AmigoProfilingSubmitInfoSEC<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            first_draw_timestamp: Default::default(),
            swap_buffer_timestamp: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> AmigoProfilingSubmitInfoSEC<'a> {
    #[inline]
    pub fn first_draw_timestamp(mut self, value: u64) -> Self {
        self.first_draw_timestamp = value;
        self
    }
    #[inline]
    pub fn swap_buffer_timestamp(mut self, value: u64) -> Self {
        self.swap_buffer_timestamp = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM.html>"]
#[doc(alias = "VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM")]
pub struct PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub multiview_per_view_viewports: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM;
}
unsafe impl<'a> Send for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM<'a>
{
}
impl<'a> Default for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            multiview_per_view_viewports: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM<'a> {
    #[inline]
    pub fn multiview_per_view_viewports(mut self, value: impl Into<Bool32>) -> Self {
        self.multiview_per_view_viewports = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV")]
pub struct PhysicalDeviceRayTracingInvocationReorderPropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ray_tracing_invocation_reorder_reordering_hint: RayTracingInvocationReorderModeNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRayTracingInvocationReorderPropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceRayTracingInvocationReorderPropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceRayTracingInvocationReorderPropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRayTracingInvocationReorderPropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceRayTracingInvocationReorderPropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceRayTracingInvocationReorderPropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ray_tracing_invocation_reorder_reordering_hint: RayTracingInvocationReorderModeNV::None,
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRayTracingInvocationReorderPropertiesNV<'a> {
    #[inline]
    pub fn ray_tracing_invocation_reorder_reordering_hint(
        mut self,
        value: RayTracingInvocationReorderModeNV,
    ) -> Self {
        self.ray_tracing_invocation_reorder_reordering_hint = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV")]
pub struct PhysicalDeviceRayTracingInvocationReorderFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ray_tracing_invocation_reorder: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRayTracingInvocationReorderFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceRayTracingInvocationReorderFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceRayTracingInvocationReorderFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRayTracingInvocationReorderFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRayTracingInvocationReorderFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRayTracingInvocationReorderFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceRayTracingInvocationReorderFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ray_tracing_invocation_reorder: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRayTracingInvocationReorderFeaturesNV<'a> {
    #[inline]
    pub fn ray_tracing_invocation_reorder(mut self, value: impl Into<Bool32>) -> Self {
        self.ray_tracing_invocation_reorder = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV")]
pub struct PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub extended_sparse_address_space: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            extended_sparse_address_space: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV<'a> {
    #[inline]
    pub fn extended_sparse_address_space(mut self, value: impl Into<Bool32>) -> Self {
        self.extended_sparse_address_space = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV.html>"]
#[doc(alias = "VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV")]
pub struct PhysicalDeviceExtendedSparseAddressSpacePropertiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub extended_sparse_address_space_size: DeviceSize,
    pub extended_sparse_image_usage_flags: ImageUsageFlags,
    pub extended_sparse_buffer_usage_flags: BufferUsageFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExtendedSparseAddressSpacePropertiesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceExtendedSparseAddressSpacePropertiesNV;
}
unsafe impl<'a> Send for PhysicalDeviceExtendedSparseAddressSpacePropertiesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExtendedSparseAddressSpacePropertiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceExtendedSparseAddressSpacePropertiesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceExtendedSparseAddressSpacePropertiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            extended_sparse_address_space_size: Default::default(),
            extended_sparse_image_usage_flags: Default::default(),
            extended_sparse_buffer_usage_flags: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExtendedSparseAddressSpacePropertiesNV<'a> {
    #[inline]
    pub fn extended_sparse_address_space_size(mut self, value: DeviceSize) -> Self {
        self.extended_sparse_address_space_size = value;
        self
    }
    #[inline]
    pub fn extended_sparse_image_usage_flags(mut self, value: ImageUsageFlags) -> Self {
        self.extended_sparse_image_usage_flags = value;
        self
    }
    #[inline]
    pub fn extended_sparse_buffer_usage_flags(mut self, value: BufferUsageFlags) -> Self {
        self.extended_sparse_buffer_usage_flags = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT")]
pub struct PhysicalDeviceMutableDescriptorTypeFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub mutable_descriptor_type: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMutableDescriptorTypeFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceMutableDescriptorTypeFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceMutableDescriptorTypeFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMutableDescriptorTypeFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMutableDescriptorTypeFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMutableDescriptorTypeFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceMutableDescriptorTypeFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            mutable_descriptor_type: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMutableDescriptorTypeFeaturesEXT<'a> {
    #[inline]
    pub fn mutable_descriptor_type(mut self, value: impl Into<Bool32>) -> Self {
        self.mutable_descriptor_type = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceMutableDescriptorTypeFeaturesVALVE<'a> =
    PhysicalDeviceMutableDescriptorTypeFeaturesEXT<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMutableDescriptorTypeListEXT.html>"]
#[doc(alias = "VkMutableDescriptorTypeListEXT")]
pub struct MutableDescriptorTypeListEXT<'a> {
    pub(crate) descriptor_type_count: u32,
    pub(crate) p_descriptor_types: *const DescriptorType,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for MutableDescriptorTypeListEXT<'a> {}
unsafe impl<'a> Sync for MutableDescriptorTypeListEXT<'a> {}
impl<'a> Default for MutableDescriptorTypeListEXT<'a> {
    fn default() -> Self {
        Self {
            descriptor_type_count: Default::default(),
            p_descriptor_types: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MutableDescriptorTypeListEXT<'a> {
    #[inline]
    pub fn descriptor_types(
        mut self,
        p_descriptor_types: impl AsSlice<'a, DescriptorType>,
    ) -> Self {
        self.p_descriptor_types = p_descriptor_types.as_slice().as_ptr().cast();
        self.descriptor_type_count = p_descriptor_types.as_slice().len() as _;
        self
    }
}
pub type MutableDescriptorTypeListVALVE<'a> = MutableDescriptorTypeListEXT<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMutableDescriptorTypeCreateInfoEXT.html>"]
#[doc(alias = "VkMutableDescriptorTypeCreateInfoEXT")]
pub struct MutableDescriptorTypeCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) mutable_descriptor_type_list_count: u32,
    pub(crate) p_mutable_descriptor_type_lists: *const MutableDescriptorTypeListEXT<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MutableDescriptorTypeCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::MutableDescriptorTypeCreateInfoEXT;
}
unsafe impl<'a> Send for MutableDescriptorTypeCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for MutableDescriptorTypeCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<DescriptorSetLayoutCreateInfo<'b>>
    for MutableDescriptorTypeCreateInfoEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DescriptorPoolCreateInfo<'b>>
    for MutableDescriptorTypeCreateInfoEXT<'a>
{
}
impl<'a> Default for MutableDescriptorTypeCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            mutable_descriptor_type_list_count: Default::default(),
            p_mutable_descriptor_type_lists: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MutableDescriptorTypeCreateInfoEXT<'a> {
    #[inline]
    pub fn mutable_descriptor_type_lists(
        mut self,
        p_mutable_descriptor_type_lists: impl AsSlice<'a, MutableDescriptorTypeListEXT<'a>>,
    ) -> Self {
        self.p_mutable_descriptor_type_lists =
            p_mutable_descriptor_type_lists.as_slice().as_ptr().cast();
        self.mutable_descriptor_type_list_count =
            p_mutable_descriptor_type_lists.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type MutableDescriptorTypeCreateInfoVALVE<'a> = MutableDescriptorTypeCreateInfoEXT<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT")]
pub struct PhysicalDeviceLegacyVertexAttributesFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub legacy_vertex_attributes: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceLegacyVertexAttributesFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceLegacyVertexAttributesFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceLegacyVertexAttributesFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceLegacyVertexAttributesFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceLegacyVertexAttributesFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceLegacyVertexAttributesFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceLegacyVertexAttributesFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            legacy_vertex_attributes: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceLegacyVertexAttributesFeaturesEXT<'a> {
    #[inline]
    pub fn legacy_vertex_attributes(mut self, value: impl Into<Bool32>) -> Self {
        self.legacy_vertex_attributes = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT")]
pub struct PhysicalDeviceLegacyVertexAttributesPropertiesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub native_unaligned_performance: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceLegacyVertexAttributesPropertiesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceLegacyVertexAttributesPropertiesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceLegacyVertexAttributesPropertiesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceLegacyVertexAttributesPropertiesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceLegacyVertexAttributesPropertiesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceLegacyVertexAttributesPropertiesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            native_unaligned_performance: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceLegacyVertexAttributesPropertiesEXT<'a> {
    #[inline]
    pub fn native_unaligned_performance(mut self, value: impl Into<Bool32>) -> Self {
        self.native_unaligned_performance = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLayerSettingsCreateInfoEXT.html>"]
#[doc(alias = "VkLayerSettingsCreateInfoEXT")]
pub struct LayerSettingsCreateInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) setting_count: u32,
    pub(crate) p_settings: *const LayerSettingEXT<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for LayerSettingsCreateInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::LayerSettingsCreateInfoEXT;
}
unsafe impl<'a> Send for LayerSettingsCreateInfoEXT<'a> {}
unsafe impl<'a> Sync for LayerSettingsCreateInfoEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<InstanceCreateInfo<'b>> for LayerSettingsCreateInfoEXT<'a> {}
impl<'a> Default for LayerSettingsCreateInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            setting_count: Default::default(),
            p_settings: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> LayerSettingsCreateInfoEXT<'a> {
    #[inline]
    pub fn settings(mut self, p_settings: impl AsSlice<'a, LayerSettingEXT<'a>>) -> Self {
        self.p_settings = p_settings.as_slice().as_ptr().cast();
        self.setting_count = p_settings.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLayerSettingEXT.html>"]
#[doc(alias = "VkLayerSettingEXT")]
pub struct LayerSettingEXT<'a> {
    pub p_layer_name: *const c_char,
    pub p_setting_name: *const c_char,
    pub ty: LayerSettingTypeEXT,
    pub(crate) value_count: u32,
    pub(crate) p_values: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> Send for LayerSettingEXT<'a> {}
unsafe impl<'a> Sync for LayerSettingEXT<'a> {}
impl<'a> Default for LayerSettingEXT<'a> {
    fn default() -> Self {
        Self {
            p_layer_name: ptr::null(),
            p_setting_name: ptr::null(),
            ty: LayerSettingTypeEXT::Bool32,
            value_count: Default::default(),
            p_values: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> LayerSettingEXT<'a> {
    #[inline]
    pub fn layer_name(mut self, value: &'a CStr) -> Self {
        self.p_layer_name = value.as_ptr();
        self
    }
    #[inline]
    pub fn setting_name(mut self, value: &'a CStr) -> Self {
        self.p_setting_name = value.as_ptr();
        self
    }
    #[inline]
    pub fn ty(mut self, value: LayerSettingTypeEXT) -> Self {
        self.ty = value;
        self
    }
    #[inline]
    pub fn values(mut self, p_values: impl AsSlice<'a, u8>) -> Self {
        self.p_values = p_values.as_slice().as_ptr().cast();
        self.value_count = p_values.as_slice().len() as _;
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM.html>"]
#[doc(alias = "VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM")]
pub struct PhysicalDeviceShaderCoreBuiltinsFeaturesARM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_core_builtins: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderCoreBuiltinsFeaturesARM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderCoreBuiltinsFeaturesARM;
}
unsafe impl<'a> Send for PhysicalDeviceShaderCoreBuiltinsFeaturesARM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderCoreBuiltinsFeaturesARM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderCoreBuiltinsFeaturesARM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderCoreBuiltinsFeaturesARM<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderCoreBuiltinsFeaturesARM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_core_builtins: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderCoreBuiltinsFeaturesARM<'a> {
    #[inline]
    pub fn shader_core_builtins(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_core_builtins = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM.html>"]
#[doc(alias = "VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM")]
pub struct PhysicalDeviceShaderCoreBuiltinsPropertiesARM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_core_mask: u64,
    pub shader_core_count: u32,
    pub shader_warps_per_core: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderCoreBuiltinsPropertiesARM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderCoreBuiltinsPropertiesARM;
}
unsafe impl<'a> Send for PhysicalDeviceShaderCoreBuiltinsPropertiesARM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderCoreBuiltinsPropertiesARM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceShaderCoreBuiltinsPropertiesARM<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderCoreBuiltinsPropertiesARM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_core_mask: Default::default(),
            shader_core_count: Default::default(),
            shader_warps_per_core: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderCoreBuiltinsPropertiesARM<'a> {
    #[inline]
    pub fn shader_core_mask(mut self, value: u64) -> Self {
        self.shader_core_mask = value;
        self
    }
    #[inline]
    pub fn shader_core_count(mut self, value: u32) -> Self {
        self.shader_core_count = value;
        self
    }
    #[inline]
    pub fn shader_warps_per_core(mut self, value: u32) -> Self {
        self.shader_warps_per_core = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT")]
pub struct PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub pipeline_library_group_handles: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            pipeline_library_group_handles: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT<'a> {
    #[inline]
    pub fn pipeline_library_group_handles(mut self, value: impl Into<Bool32>) -> Self {
        self.pipeline_library_group_handles = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT")]
pub struct PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub dynamic_rendering_unused_attachments: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure
    for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT<'a>
{
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            dynamic_rendering_unused_attachments: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT<'a> {
    #[inline]
    pub fn dynamic_rendering_unused_attachments(mut self, value: impl Into<Bool32>) -> Self {
        self.dynamic_rendering_unused_attachments = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLatencySleepModeInfoNV.html>"]
#[doc(alias = "VkLatencySleepModeInfoNV")]
pub struct LatencySleepModeInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub low_latency_mode: Bool32,
    pub low_latency_boost: Bool32,
    pub minimum_interval_us: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for LatencySleepModeInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::LatencySleepModeInfoNV;
}
unsafe impl<'a> Send for LatencySleepModeInfoNV<'a> {}
unsafe impl<'a> Sync for LatencySleepModeInfoNV<'a> {}
impl<'a> Default for LatencySleepModeInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            low_latency_mode: Default::default(),
            low_latency_boost: Default::default(),
            minimum_interval_us: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> LatencySleepModeInfoNV<'a> {
    #[inline]
    pub fn low_latency_mode(mut self, value: impl Into<Bool32>) -> Self {
        self.low_latency_mode = value.into();
        self
    }
    #[inline]
    pub fn low_latency_boost(mut self, value: impl Into<Bool32>) -> Self {
        self.low_latency_boost = value.into();
        self
    }
    #[inline]
    pub fn minimum_interval_us(mut self, value: u32) -> Self {
        self.minimum_interval_us = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLatencySleepInfoNV.html>"]
#[doc(alias = "VkLatencySleepInfoNV")]
pub struct LatencySleepInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub signal_semaphore: Option<Semaphore>,
    pub value: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for LatencySleepInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::LatencySleepInfoNV;
}
unsafe impl<'a> Send for LatencySleepInfoNV<'a> {}
unsafe impl<'a> Sync for LatencySleepInfoNV<'a> {}
impl<'a> Default for LatencySleepInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            signal_semaphore: Default::default(),
            value: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> LatencySleepInfoNV<'a> {
    #[inline]
    pub fn signal_semaphore(mut self, value: &'a Semaphore) -> Self {
        self.signal_semaphore = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn value(mut self, value: u64) -> Self {
        self.value = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSetLatencyMarkerInfoNV.html>"]
#[doc(alias = "VkSetLatencyMarkerInfoNV")]
pub struct SetLatencyMarkerInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub present_id: u64,
    pub marker: LatencyMarkerNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SetLatencyMarkerInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SetLatencyMarkerInfoNV;
}
unsafe impl<'a> Send for SetLatencyMarkerInfoNV<'a> {}
unsafe impl<'a> Sync for SetLatencyMarkerInfoNV<'a> {}
impl<'a> Default for SetLatencyMarkerInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_id: Default::default(),
            marker: LatencyMarkerNV::SimulationStart,
            phantom: PhantomData,
        }
    }
}
impl<'a> SetLatencyMarkerInfoNV<'a> {
    #[inline]
    pub fn present_id(mut self, value: u64) -> Self {
        self.present_id = value;
        self
    }
    #[inline]
    pub fn marker(mut self, value: LatencyMarkerNV) -> Self {
        self.marker = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGetLatencyMarkerInfoNV.html>"]
#[doc(alias = "VkGetLatencyMarkerInfoNV")]
pub struct GetLatencyMarkerInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub timing_count: u32,
    pub(crate) p_timings: *const LatencyTimingsFrameReportNV<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for GetLatencyMarkerInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::GetLatencyMarkerInfoNV;
}
unsafe impl<'a> Send for GetLatencyMarkerInfoNV<'a> {}
unsafe impl<'a> Sync for GetLatencyMarkerInfoNV<'a> {}
impl<'a> Default for GetLatencyMarkerInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            timing_count: Default::default(),
            p_timings: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> GetLatencyMarkerInfoNV<'a> {
    #[inline]
    pub fn timing_count(mut self, value: u32) -> Self {
        self.timing_count = value;
        self
    }
    #[inline]
    pub fn timings(mut self, p_timings: impl AsSlice<'a, LatencyTimingsFrameReportNV<'a>>) -> Self {
        self.p_timings = p_timings.as_slice().as_ptr().cast();
        self.timing_count = p_timings.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLatencyTimingsFrameReportNV.html>"]
#[doc(alias = "VkLatencyTimingsFrameReportNV")]
pub struct LatencyTimingsFrameReportNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub present_id: u64,
    pub input_sample_time_us: u64,
    pub sim_start_time_us: u64,
    pub sim_end_time_us: u64,
    pub render_submit_start_time_us: u64,
    pub render_submit_end_time_us: u64,
    pub present_start_time_us: u64,
    pub present_end_time_us: u64,
    pub driver_start_time_us: u64,
    pub driver_end_time_us: u64,
    pub os_render_queue_start_time_us: u64,
    pub os_render_queue_end_time_us: u64,
    pub gpu_render_start_time_us: u64,
    pub gpu_render_end_time_us: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for LatencyTimingsFrameReportNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::LatencyTimingsFrameReportNV;
}
unsafe impl<'a> Send for LatencyTimingsFrameReportNV<'a> {}
unsafe impl<'a> Sync for LatencyTimingsFrameReportNV<'a> {}
impl<'a> Default for LatencyTimingsFrameReportNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_id: Default::default(),
            input_sample_time_us: Default::default(),
            sim_start_time_us: Default::default(),
            sim_end_time_us: Default::default(),
            render_submit_start_time_us: Default::default(),
            render_submit_end_time_us: Default::default(),
            present_start_time_us: Default::default(),
            present_end_time_us: Default::default(),
            driver_start_time_us: Default::default(),
            driver_end_time_us: Default::default(),
            os_render_queue_start_time_us: Default::default(),
            os_render_queue_end_time_us: Default::default(),
            gpu_render_start_time_us: Default::default(),
            gpu_render_end_time_us: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> LatencyTimingsFrameReportNV<'a> {
    #[inline]
    pub fn present_id(mut self, value: u64) -> Self {
        self.present_id = value;
        self
    }
    #[inline]
    pub fn input_sample_time_us(mut self, value: u64) -> Self {
        self.input_sample_time_us = value;
        self
    }
    #[inline]
    pub fn sim_start_time_us(mut self, value: u64) -> Self {
        self.sim_start_time_us = value;
        self
    }
    #[inline]
    pub fn sim_end_time_us(mut self, value: u64) -> Self {
        self.sim_end_time_us = value;
        self
    }
    #[inline]
    pub fn render_submit_start_time_us(mut self, value: u64) -> Self {
        self.render_submit_start_time_us = value;
        self
    }
    #[inline]
    pub fn render_submit_end_time_us(mut self, value: u64) -> Self {
        self.render_submit_end_time_us = value;
        self
    }
    #[inline]
    pub fn present_start_time_us(mut self, value: u64) -> Self {
        self.present_start_time_us = value;
        self
    }
    #[inline]
    pub fn present_end_time_us(mut self, value: u64) -> Self {
        self.present_end_time_us = value;
        self
    }
    #[inline]
    pub fn driver_start_time_us(mut self, value: u64) -> Self {
        self.driver_start_time_us = value;
        self
    }
    #[inline]
    pub fn driver_end_time_us(mut self, value: u64) -> Self {
        self.driver_end_time_us = value;
        self
    }
    #[inline]
    pub fn os_render_queue_start_time_us(mut self, value: u64) -> Self {
        self.os_render_queue_start_time_us = value;
        self
    }
    #[inline]
    pub fn os_render_queue_end_time_us(mut self, value: u64) -> Self {
        self.os_render_queue_end_time_us = value;
        self
    }
    #[inline]
    pub fn gpu_render_start_time_us(mut self, value: u64) -> Self {
        self.gpu_render_start_time_us = value;
        self
    }
    #[inline]
    pub fn gpu_render_end_time_us(mut self, value: u64) -> Self {
        self.gpu_render_end_time_us = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLatencySubmissionPresentIdNV.html>"]
#[doc(alias = "VkLatencySubmissionPresentIdNV")]
pub struct LatencySubmissionPresentIdNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub present_id: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for LatencySubmissionPresentIdNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::LatencySubmissionPresentIdNV;
}
unsafe impl<'a> Send for LatencySubmissionPresentIdNV<'a> {}
unsafe impl<'a> Sync for LatencySubmissionPresentIdNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo<'b>> for LatencySubmissionPresentIdNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SubmitInfo2<'b>> for LatencySubmissionPresentIdNV<'a> {}
impl<'a> Default for LatencySubmissionPresentIdNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_id: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> LatencySubmissionPresentIdNV<'a> {
    #[inline]
    pub fn present_id(mut self, value: u64) -> Self {
        self.present_id = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainLatencyCreateInfoNV.html>"]
#[doc(alias = "VkSwapchainLatencyCreateInfoNV")]
pub struct SwapchainLatencyCreateInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub latency_mode_enable: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SwapchainLatencyCreateInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SwapchainLatencyCreateInfoNV;
}
unsafe impl<'a> Send for SwapchainLatencyCreateInfoNV<'a> {}
unsafe impl<'a> Sync for SwapchainLatencyCreateInfoNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SwapchainCreateInfoKHR<'b>>
    for SwapchainLatencyCreateInfoNV<'a>
{
}
impl<'a> Default for SwapchainLatencyCreateInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            latency_mode_enable: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SwapchainLatencyCreateInfoNV<'a> {
    #[inline]
    pub fn latency_mode_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.latency_mode_enable = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOutOfBandQueueTypeInfoNV.html>"]
#[doc(alias = "VkOutOfBandQueueTypeInfoNV")]
pub struct OutOfBandQueueTypeInfoNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub queue_type: OutOfBandQueueTypeNV,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for OutOfBandQueueTypeInfoNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::OutOfBandQueueTypeInfoNV;
}
unsafe impl<'a> Send for OutOfBandQueueTypeInfoNV<'a> {}
unsafe impl<'a> Sync for OutOfBandQueueTypeInfoNV<'a> {}
impl<'a> Default for OutOfBandQueueTypeInfoNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            queue_type: OutOfBandQueueTypeNV::Render,
            phantom: PhantomData,
        }
    }
}
impl<'a> OutOfBandQueueTypeInfoNV<'a> {
    #[inline]
    pub fn queue_type(mut self, value: OutOfBandQueueTypeNV) -> Self {
        self.queue_type = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLatencySurfaceCapabilitiesNV.html>"]
#[doc(alias = "VkLatencySurfaceCapabilitiesNV")]
pub struct LatencySurfaceCapabilitiesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub present_mode_count: u32,
    pub(crate) p_present_modes: *const PresentModeKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for LatencySurfaceCapabilitiesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::LatencySurfaceCapabilitiesNV;
}
unsafe impl<'a> Send for LatencySurfaceCapabilitiesNV<'a> {}
unsafe impl<'a> Sync for LatencySurfaceCapabilitiesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SurfaceCapabilities2KHR<'b>>
    for LatencySurfaceCapabilitiesNV<'a>
{
}
impl<'a> Default for LatencySurfaceCapabilitiesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            present_mode_count: Default::default(),
            p_present_modes: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> LatencySurfaceCapabilitiesNV<'a> {
    #[inline]
    pub fn present_mode_count(mut self, value: u32) -> Self {
        self.present_mode_count = value;
        self
    }
    #[inline]
    pub fn present_modes(mut self, p_present_modes: impl AsSlice<'a, PresentModeKHR>) -> Self {
        self.p_present_modes = p_present_modes.as_slice().as_ptr().cast();
        self.present_mode_count = p_present_modes.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCooperativeMatrixPropertiesKHR.html>"]
#[doc(alias = "VkCooperativeMatrixPropertiesKHR")]
pub struct CooperativeMatrixPropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub msize: u32,
    pub nsize: u32,
    pub ksize: u32,
    pub atype: ComponentTypeKHR,
    pub btype: ComponentTypeKHR,
    pub ctype: ComponentTypeKHR,
    pub result_type: ComponentTypeKHR,
    pub saturating_accumulation: Bool32,
    pub scope: ScopeKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CooperativeMatrixPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CooperativeMatrixPropertiesKHR;
}
unsafe impl<'a> Send for CooperativeMatrixPropertiesKHR<'a> {}
unsafe impl<'a> Sync for CooperativeMatrixPropertiesKHR<'a> {}
impl<'a> Default for CooperativeMatrixPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            msize: Default::default(),
            nsize: Default::default(),
            ksize: Default::default(),
            atype: ComponentTypeKHR::Float16,
            btype: ComponentTypeKHR::Float16,
            ctype: ComponentTypeKHR::Float16,
            result_type: ComponentTypeKHR::Float16,
            saturating_accumulation: Default::default(),
            scope: ScopeKHR::Device,
            phantom: PhantomData,
        }
    }
}
impl<'a> CooperativeMatrixPropertiesKHR<'a> {
    #[inline]
    pub fn msize(mut self, value: u32) -> Self {
        self.msize = value;
        self
    }
    #[inline]
    pub fn nsize(mut self, value: u32) -> Self {
        self.nsize = value;
        self
    }
    #[inline]
    pub fn ksize(mut self, value: u32) -> Self {
        self.ksize = value;
        self
    }
    #[inline]
    pub fn atype(mut self, value: ComponentTypeKHR) -> Self {
        self.atype = value;
        self
    }
    #[inline]
    pub fn btype(mut self, value: ComponentTypeKHR) -> Self {
        self.btype = value;
        self
    }
    #[inline]
    pub fn ctype(mut self, value: ComponentTypeKHR) -> Self {
        self.ctype = value;
        self
    }
    #[inline]
    pub fn result_type(mut self, value: ComponentTypeKHR) -> Self {
        self.result_type = value;
        self
    }
    #[inline]
    pub fn saturating_accumulation(mut self, value: impl Into<Bool32>) -> Self {
        self.saturating_accumulation = value.into();
        self
    }
    #[inline]
    pub fn scope(mut self, value: ScopeKHR) -> Self {
        self.scope = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCooperativeMatrixFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceCooperativeMatrixFeaturesKHR")]
pub struct PhysicalDeviceCooperativeMatrixFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub cooperative_matrix: Bool32,
    pub cooperative_matrix_robust_buffer_access: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCooperativeMatrixFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceCooperativeMatrixFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceCooperativeMatrixFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCooperativeMatrixFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceCooperativeMatrixFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceCooperativeMatrixFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceCooperativeMatrixFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            cooperative_matrix: Default::default(),
            cooperative_matrix_robust_buffer_access: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCooperativeMatrixFeaturesKHR<'a> {
    #[inline]
    pub fn cooperative_matrix(mut self, value: impl Into<Bool32>) -> Self {
        self.cooperative_matrix = value.into();
        self
    }
    #[inline]
    pub fn cooperative_matrix_robust_buffer_access(mut self, value: impl Into<Bool32>) -> Self {
        self.cooperative_matrix_robust_buffer_access = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCooperativeMatrixPropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceCooperativeMatrixPropertiesKHR")]
pub struct PhysicalDeviceCooperativeMatrixPropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub cooperative_matrix_supported_stages: ShaderStageFlags,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCooperativeMatrixPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceCooperativeMatrixPropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceCooperativeMatrixPropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCooperativeMatrixPropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceCooperativeMatrixPropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceCooperativeMatrixPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            cooperative_matrix_supported_stages: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCooperativeMatrixPropertiesKHR<'a> {
    #[inline]
    pub fn cooperative_matrix_supported_stages(mut self, value: ShaderStageFlags) -> Self {
        self.cooperative_matrix_supported_stages = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM.html>"]
#[doc(alias = "VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM")]
pub struct PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub multiview_per_view_render_areas: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM;
}
unsafe impl<'a> Send for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM<'a>
{
}
impl<'a> Default for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            multiview_per_view_render_areas: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM<'a> {
    #[inline]
    pub fn multiview_per_view_render_areas(mut self, value: impl Into<Bool32>) -> Self {
        self.multiview_per_view_render_areas = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM.html>"]
#[doc(alias = "VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM")]
pub struct MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) per_view_render_area_count: u32,
    pub(crate) p_per_view_render_areas: *const Rect2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM;
}
unsafe impl<'a> Send for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM<'a> {}
unsafe impl<'a> Sync for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<RenderPassBeginInfo<'b>>
    for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<RenderingInfo<'b>>
    for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM<'a>
{
}
impl<'a> Default for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            per_view_render_area_count: Default::default(),
            p_per_view_render_areas: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM<'a> {
    #[inline]
    pub fn per_view_render_areas(
        mut self,
        p_per_view_render_areas: impl AsSlice<'a, Rect2D>,
    ) -> Self {
        self.p_per_view_render_areas = p_per_view_render_areas.as_slice().as_ptr().cast();
        self.per_view_render_area_count = p_per_view_render_areas.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePerStageDescriptorSetFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDevicePerStageDescriptorSetFeaturesNV")]
pub struct PhysicalDevicePerStageDescriptorSetFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub per_stage_descriptor_set: Bool32,
    pub dynamic_pipeline_layout: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDevicePerStageDescriptorSetFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDevicePerStageDescriptorSetFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDevicePerStageDescriptorSetFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDevicePerStageDescriptorSetFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDevicePerStageDescriptorSetFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDevicePerStageDescriptorSetFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDevicePerStageDescriptorSetFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            per_stage_descriptor_set: Default::default(),
            dynamic_pipeline_layout: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDevicePerStageDescriptorSetFeaturesNV<'a> {
    #[inline]
    pub fn per_stage_descriptor_set(mut self, value: impl Into<Bool32>) -> Self {
        self.per_stage_descriptor_set = value.into();
        self
    }
    #[inline]
    pub fn dynamic_pipeline_layout(mut self, value: impl Into<Bool32>) -> Self {
        self.dynamic_pipeline_layout = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageProcessing2FeaturesQCOM.html>"]
#[doc(alias = "VkPhysicalDeviceImageProcessing2FeaturesQCOM")]
pub struct PhysicalDeviceImageProcessing2FeaturesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub texture_block_match2: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageProcessing2FeaturesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceImageProcessing2FeaturesQCOM;
}
unsafe impl<'a> Send for PhysicalDeviceImageProcessing2FeaturesQCOM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageProcessing2FeaturesQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceImageProcessing2FeaturesQCOM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceImageProcessing2FeaturesQCOM<'a>
{
}
impl<'a> Default for PhysicalDeviceImageProcessing2FeaturesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            texture_block_match2: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageProcessing2FeaturesQCOM<'a> {
    #[inline]
    pub fn texture_block_match2(mut self, value: impl Into<Bool32>) -> Self {
        self.texture_block_match2 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageProcessing2PropertiesQCOM.html>"]
#[doc(alias = "VkPhysicalDeviceImageProcessing2PropertiesQCOM")]
pub struct PhysicalDeviceImageProcessing2PropertiesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_block_match_window: Extent2D,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageProcessing2PropertiesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceImageProcessing2PropertiesQCOM;
}
unsafe impl<'a> Send for PhysicalDeviceImageProcessing2PropertiesQCOM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageProcessing2PropertiesQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceImageProcessing2PropertiesQCOM<'a>
{
}
impl<'a> Default for PhysicalDeviceImageProcessing2PropertiesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_block_match_window: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageProcessing2PropertiesQCOM<'a> {
    #[inline]
    pub fn max_block_match_window(mut self, value: Extent2D) -> Self {
        self.max_block_match_window = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerBlockMatchWindowCreateInfoQCOM.html>"]
#[doc(alias = "VkSamplerBlockMatchWindowCreateInfoQCOM")]
pub struct SamplerBlockMatchWindowCreateInfoQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub window_extent: Extent2D,
    pub window_compare_mode: BlockMatchWindowCompareModeQCOM,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SamplerBlockMatchWindowCreateInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SamplerBlockMatchWindowCreateInfoQCOM;
}
unsafe impl<'a> Send for SamplerBlockMatchWindowCreateInfoQCOM<'a> {}
unsafe impl<'a> Sync for SamplerBlockMatchWindowCreateInfoQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SamplerCreateInfo<'b>>
    for SamplerBlockMatchWindowCreateInfoQCOM<'a>
{
}
impl<'a> Default for SamplerBlockMatchWindowCreateInfoQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            window_extent: Default::default(),
            window_compare_mode: BlockMatchWindowCompareModeQCOM::Min,
            phantom: PhantomData,
        }
    }
}
impl<'a> SamplerBlockMatchWindowCreateInfoQCOM<'a> {
    #[inline]
    pub fn window_extent(mut self, value: Extent2D) -> Self {
        self.window_extent = value;
        self
    }
    #[inline]
    pub fn window_compare_mode(mut self, value: BlockMatchWindowCompareModeQCOM) -> Self {
        self.window_compare_mode = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCubicWeightsFeaturesQCOM.html>"]
#[doc(alias = "VkPhysicalDeviceCubicWeightsFeaturesQCOM")]
pub struct PhysicalDeviceCubicWeightsFeaturesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub selectable_cubic_weights: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCubicWeightsFeaturesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceCubicWeightsFeaturesQCOM;
}
unsafe impl<'a> Send for PhysicalDeviceCubicWeightsFeaturesQCOM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCubicWeightsFeaturesQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceCubicWeightsFeaturesQCOM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceCubicWeightsFeaturesQCOM<'a>
{
}
impl<'a> Default for PhysicalDeviceCubicWeightsFeaturesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            selectable_cubic_weights: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCubicWeightsFeaturesQCOM<'a> {
    #[inline]
    pub fn selectable_cubic_weights(mut self, value: impl Into<Bool32>) -> Self {
        self.selectable_cubic_weights = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCubicWeightsCreateInfoQCOM.html>"]
#[doc(alias = "VkSamplerCubicWeightsCreateInfoQCOM")]
pub struct SamplerCubicWeightsCreateInfoQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub cubic_weights: CubicFilterWeightsQCOM,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SamplerCubicWeightsCreateInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SamplerCubicWeightsCreateInfoQCOM;
}
unsafe impl<'a> Send for SamplerCubicWeightsCreateInfoQCOM<'a> {}
unsafe impl<'a> Sync for SamplerCubicWeightsCreateInfoQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SamplerCreateInfo<'b>>
    for SamplerCubicWeightsCreateInfoQCOM<'a>
{
}
impl<'a> Default for SamplerCubicWeightsCreateInfoQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            cubic_weights: CubicFilterWeightsQCOM::CatmullRom,
            phantom: PhantomData,
        }
    }
}
impl<'a> SamplerCubicWeightsCreateInfoQCOM<'a> {
    #[inline]
    pub fn cubic_weights(mut self, value: CubicFilterWeightsQCOM) -> Self {
        self.cubic_weights = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlitImageCubicWeightsInfoQCOM.html>"]
#[doc(alias = "VkBlitImageCubicWeightsInfoQCOM")]
pub struct BlitImageCubicWeightsInfoQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub cubic_weights: CubicFilterWeightsQCOM,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BlitImageCubicWeightsInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BlitImageCubicWeightsInfoQCOM;
}
unsafe impl<'a> Send for BlitImageCubicWeightsInfoQCOM<'a> {}
unsafe impl<'a> Sync for BlitImageCubicWeightsInfoQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BlitImageInfo2<'b>> for BlitImageCubicWeightsInfoQCOM<'a> {}
impl<'a> Default for BlitImageCubicWeightsInfoQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            cubic_weights: CubicFilterWeightsQCOM::CatmullRom,
            phantom: PhantomData,
        }
    }
}
impl<'a> BlitImageCubicWeightsInfoQCOM<'a> {
    #[inline]
    pub fn cubic_weights(mut self, value: CubicFilterWeightsQCOM) -> Self {
        self.cubic_weights = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceYcbcrDegammaFeaturesQCOM.html>"]
#[doc(alias = "VkPhysicalDeviceYcbcrDegammaFeaturesQCOM")]
pub struct PhysicalDeviceYcbcrDegammaFeaturesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ycbcr_degamma: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceYcbcrDegammaFeaturesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceYcbcrDegammaFeaturesQCOM;
}
unsafe impl<'a> Send for PhysicalDeviceYcbcrDegammaFeaturesQCOM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceYcbcrDegammaFeaturesQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceYcbcrDegammaFeaturesQCOM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceYcbcrDegammaFeaturesQCOM<'a>
{
}
impl<'a> Default for PhysicalDeviceYcbcrDegammaFeaturesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ycbcr_degamma: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceYcbcrDegammaFeaturesQCOM<'a> {
    #[inline]
    pub fn ycbcr_degamma(mut self, value: impl Into<Bool32>) -> Self {
        self.ycbcr_degamma = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM.html>"]
#[doc(alias = "VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM")]
pub struct SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub enable_ydegamma: Bool32,
    pub enable_cb_cr_degamma: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM;
}
unsafe impl<'a> Send for SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM<'a> {}
unsafe impl<'a> Sync for SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SamplerYcbcrConversionCreateInfo<'b>>
    for SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM<'a>
{
}
impl<'a> Default for SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            enable_ydegamma: Default::default(),
            enable_cb_cr_degamma: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM<'a> {
    #[inline]
    pub fn enable_ydegamma(mut self, value: impl Into<Bool32>) -> Self {
        self.enable_ydegamma = value.into();
        self
    }
    #[inline]
    pub fn enable_cb_cr_degamma(mut self, value: impl Into<Bool32>) -> Self {
        self.enable_cb_cr_degamma = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCubicClampFeaturesQCOM.html>"]
#[doc(alias = "VkPhysicalDeviceCubicClampFeaturesQCOM")]
pub struct PhysicalDeviceCubicClampFeaturesQCOM<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub cubic_range_clamp: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceCubicClampFeaturesQCOM<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceCubicClampFeaturesQCOM;
}
unsafe impl<'a> Send for PhysicalDeviceCubicClampFeaturesQCOM<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceCubicClampFeaturesQCOM<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceCubicClampFeaturesQCOM<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceCubicClampFeaturesQCOM<'a>
{
}
impl<'a> Default for PhysicalDeviceCubicClampFeaturesQCOM<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            cubic_range_clamp: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceCubicClampFeaturesQCOM<'a> {
    #[inline]
    pub fn cubic_range_clamp(mut self, value: impl Into<Bool32>) -> Self {
        self.cubic_range_clamp = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT")]
pub struct PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub attachment_feedback_loop_dynamic_state: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure
    for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT<'a>
{
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            attachment_feedback_loop_dynamic_state: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT<'a> {
    #[inline]
    pub fn attachment_feedback_loop_dynamic_state(mut self, value: impl Into<Bool32>) -> Self {
        self.attachment_feedback_loop_dynamic_state = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR")]
pub struct PhysicalDeviceVertexAttributeDivisorPropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub max_vertex_attrib_divisor: u32,
    pub supports_non_zero_first_instance: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceVertexAttributeDivisorPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceVertexAttributeDivisorPropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceVertexAttributeDivisorPropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceVertexAttributeDivisorPropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceVertexAttributeDivisorPropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceVertexAttributeDivisorPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            max_vertex_attrib_divisor: Default::default(),
            supports_non_zero_first_instance: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceVertexAttributeDivisorPropertiesKHR<'a> {
    #[inline]
    pub fn max_vertex_attrib_divisor(mut self, value: u32) -> Self {
        self.max_vertex_attrib_divisor = value;
        self
    }
    #[inline]
    pub fn supports_non_zero_first_instance(mut self, value: impl Into<Bool32>) -> Self {
        self.supports_non_zero_first_instance = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDivisorDescriptionKHR.html>"]
#[doc(alias = "VkVertexInputBindingDivisorDescriptionKHR")]
pub struct VertexInputBindingDivisorDescriptionKHR {
    pub binding: u32,
    pub divisor: u32,
}
unsafe impl Send for VertexInputBindingDivisorDescriptionKHR {}
unsafe impl Sync for VertexInputBindingDivisorDescriptionKHR {}
impl Default for VertexInputBindingDivisorDescriptionKHR {
    fn default() -> Self {
        Self {
            binding: Default::default(),
            divisor: Default::default(),
        }
    }
}
impl VertexInputBindingDivisorDescriptionKHR {
    #[inline]
    pub fn binding(mut self, value: u32) -> Self {
        self.binding = value;
        self
    }
    #[inline]
    pub fn divisor(mut self, value: u32) -> Self {
        self.divisor = value;
        self
    }
}
pub type VertexInputBindingDivisorDescriptionEXT = VertexInputBindingDivisorDescriptionKHR;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputDivisorStateCreateInfoKHR.html>"]
#[doc(alias = "VkPipelineVertexInputDivisorStateCreateInfoKHR")]
pub struct PipelineVertexInputDivisorStateCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub(crate) vertex_binding_divisor_count: u32,
    pub(crate) p_vertex_binding_divisors: *const VertexInputBindingDivisorDescriptionKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineVertexInputDivisorStateCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineVertexInputDivisorStateCreateInfoKHR;
}
unsafe impl<'a> Send for PipelineVertexInputDivisorStateCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for PipelineVertexInputDivisorStateCreateInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineVertexInputStateCreateInfo<'b>>
    for PipelineVertexInputDivisorStateCreateInfoKHR<'a>
{
}
impl<'a> Default for PipelineVertexInputDivisorStateCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            vertex_binding_divisor_count: Default::default(),
            p_vertex_binding_divisors: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineVertexInputDivisorStateCreateInfoKHR<'a> {
    #[inline]
    pub fn vertex_binding_divisors(
        mut self,
        p_vertex_binding_divisors: impl AsSlice<'a, VertexInputBindingDivisorDescriptionKHR>,
    ) -> Self {
        self.p_vertex_binding_divisors = p_vertex_binding_divisors.as_slice().as_ptr().cast();
        self.vertex_binding_divisor_count = p_vertex_binding_divisors.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PipelineVertexInputDivisorStateCreateInfoEXT<'a> =
    PipelineVertexInputDivisorStateCreateInfoKHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR")]
pub struct PhysicalDeviceVertexAttributeDivisorFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub vertex_attribute_instance_rate_divisor: Bool32,
    pub vertex_attribute_instance_rate_zero_divisor: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceVertexAttributeDivisorFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceVertexAttributeDivisorFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceVertexAttributeDivisorFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceVertexAttributeDivisorFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceVertexAttributeDivisorFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceVertexAttributeDivisorFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceVertexAttributeDivisorFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            vertex_attribute_instance_rate_divisor: Default::default(),
            vertex_attribute_instance_rate_zero_divisor: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceVertexAttributeDivisorFeaturesKHR<'a> {
    #[inline]
    pub fn vertex_attribute_instance_rate_divisor(mut self, value: impl Into<Bool32>) -> Self {
        self.vertex_attribute_instance_rate_divisor = value.into();
        self
    }
    #[inline]
    pub fn vertex_attribute_instance_rate_zero_divisor(mut self, value: impl Into<Bool32>) -> Self {
        self.vertex_attribute_instance_rate_zero_divisor = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceVertexAttributeDivisorFeaturesEXT<'a> =
    PhysicalDeviceVertexAttributeDivisorFeaturesKHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderFloatControls2FeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceShaderFloatControls2FeaturesKHR")]
pub struct PhysicalDeviceShaderFloatControls2FeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_float_controls2: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderFloatControls2FeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderFloatControls2FeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceShaderFloatControls2FeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderFloatControls2FeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderFloatControls2FeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderFloatControls2FeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderFloatControls2FeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_float_controls2: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderFloatControls2FeaturesKHR<'a> {
    #[inline]
    pub fn shader_float_controls2(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_float_controls2 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkScreenBufferPropertiesQNX.html>"]
#[doc(alias = "VkScreenBufferPropertiesQNX")]
pub struct ScreenBufferPropertiesQNX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub allocation_size: DeviceSize,
    pub memory_type_bits: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ScreenBufferPropertiesQNX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ScreenBufferPropertiesQNX;
}
unsafe impl<'a> Send for ScreenBufferPropertiesQNX<'a> {}
unsafe impl<'a> Sync for ScreenBufferPropertiesQNX<'a> {}
impl<'a> Default for ScreenBufferPropertiesQNX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            allocation_size: Default::default(),
            memory_type_bits: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ScreenBufferPropertiesQNX<'a> {
    #[inline]
    pub fn allocation_size(mut self, value: DeviceSize) -> Self {
        self.allocation_size = value;
        self
    }
    #[inline]
    pub fn memory_type_bits(mut self, value: u32) -> Self {
        self.memory_type_bits = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkScreenBufferFormatPropertiesQNX.html>"]
#[doc(alias = "VkScreenBufferFormatPropertiesQNX")]
pub struct ScreenBufferFormatPropertiesQNX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub format: Format,
    pub external_format: u64,
    pub screen_usage: u64,
    pub format_features: FormatFeatureFlags,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_xchroma_offset: ChromaLocation,
    pub suggested_ychroma_offset: ChromaLocation,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ScreenBufferFormatPropertiesQNX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ScreenBufferFormatPropertiesQNX;
}
unsafe impl<'a> Send for ScreenBufferFormatPropertiesQNX<'a> {}
unsafe impl<'a> Sync for ScreenBufferFormatPropertiesQNX<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ScreenBufferPropertiesQNX<'b>>
    for ScreenBufferFormatPropertiesQNX<'a>
{
}
impl<'a> Default for ScreenBufferFormatPropertiesQNX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            format: Format::Undefined,
            external_format: Default::default(),
            screen_usage: Default::default(),
            format_features: Default::default(),
            sampler_ycbcr_conversion_components: Default::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::RgbIdentity,
            suggested_ycbcr_range: SamplerYcbcrRange::ItuFull,
            suggested_xchroma_offset: ChromaLocation::CositedEven,
            suggested_ychroma_offset: ChromaLocation::CositedEven,
            phantom: PhantomData,
        }
    }
}
impl<'a> ScreenBufferFormatPropertiesQNX<'a> {
    #[inline]
    pub fn format(mut self, value: Format) -> Self {
        self.format = value;
        self
    }
    #[inline]
    pub fn external_format(mut self, value: u64) -> Self {
        self.external_format = value;
        self
    }
    #[inline]
    pub fn screen_usage(mut self, value: u64) -> Self {
        self.screen_usage = value;
        self
    }
    #[inline]
    pub fn format_features(mut self, value: FormatFeatureFlags) -> Self {
        self.format_features = value;
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion_components(mut self, value: ComponentMapping) -> Self {
        self.sampler_ycbcr_conversion_components = value;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_model(mut self, value: SamplerYcbcrModelConversion) -> Self {
        self.suggested_ycbcr_model = value;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_range(mut self, value: SamplerYcbcrRange) -> Self {
        self.suggested_ycbcr_range = value;
        self
    }
    #[inline]
    pub fn suggested_xchroma_offset(mut self, value: ChromaLocation) -> Self {
        self.suggested_xchroma_offset = value;
        self
    }
    #[inline]
    pub fn suggested_ychroma_offset(mut self, value: ChromaLocation) -> Self {
        self.suggested_ychroma_offset = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportScreenBufferInfoQNX.html>"]
#[doc(alias = "VkImportScreenBufferInfoQNX")]
pub struct ImportScreenBufferInfoQNX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub buffer: *const VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImportScreenBufferInfoQNX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImportScreenBufferInfoQNX;
}
unsafe impl<'a> Send for ImportScreenBufferInfoQNX<'a> {}
unsafe impl<'a> Sync for ImportScreenBufferInfoQNX<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<MemoryAllocateInfo<'b>> for ImportScreenBufferInfoQNX<'a> {}
impl<'a> Default for ImportScreenBufferInfoQNX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            buffer: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImportScreenBufferInfoQNX<'a> {
    #[inline]
    pub fn buffer(mut self, value: &'a VoidPtr) -> Self {
        self.buffer = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFormatQNX.html>"]
#[doc(alias = "VkExternalFormatQNX")]
pub struct ExternalFormatQNX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub external_format: u64,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ExternalFormatQNX<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ExternalFormatQNX;
}
unsafe impl<'a> Send for ExternalFormatQNX<'a> {}
unsafe impl<'a> Sync for ExternalFormatQNX<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>> for ExternalFormatQNX<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<SamplerYcbcrConversionCreateInfo<'b>>
    for ExternalFormatQNX<'a>
{
}
impl<'a> Default for ExternalFormatQNX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            external_format: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ExternalFormatQNX<'a> {
    #[inline]
    pub fn external_format(mut self, value: u64) -> Self {
        self.external_format = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX.html>"]
#[doc(alias = "VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX")]
pub struct PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub screen_buffer_import: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX;
}
unsafe impl<'a> Send for PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX<'a>
{
}
impl<'a> Default for PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            screen_buffer_import: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX<'a> {
    #[inline]
    pub fn screen_buffer_import(mut self, value: impl Into<Bool32>) -> Self {
        self.screen_buffer_import = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLayeredDriverPropertiesMSFT.html>"]
#[doc(alias = "VkPhysicalDeviceLayeredDriverPropertiesMSFT")]
pub struct PhysicalDeviceLayeredDriverPropertiesMSFT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub underlying_api: LayeredDriverUnderlyingApiMSFT,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceLayeredDriverPropertiesMSFT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceLayeredDriverPropertiesMSFT;
}
unsafe impl<'a> Send for PhysicalDeviceLayeredDriverPropertiesMSFT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceLayeredDriverPropertiesMSFT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceLayeredDriverPropertiesMSFT<'a>
{
}
impl<'a> Default for PhysicalDeviceLayeredDriverPropertiesMSFT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            underlying_api: LayeredDriverUnderlyingApiMSFT::None,
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceLayeredDriverPropertiesMSFT<'a> {
    #[inline]
    pub fn underlying_api(mut self, value: LayeredDriverUnderlyingApiMSFT) -> Self {
        self.underlying_api = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceIndexTypeUint8FeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceIndexTypeUint8FeaturesKHR")]
pub struct PhysicalDeviceIndexTypeUint8FeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub index_type_uint8: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceIndexTypeUint8FeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceIndexTypeUint8FeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceIndexTypeUint8FeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceIndexTypeUint8FeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceIndexTypeUint8FeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceIndexTypeUint8FeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceIndexTypeUint8FeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            index_type_uint8: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceIndexTypeUint8FeaturesKHR<'a> {
    #[inline]
    pub fn index_type_uint8(mut self, value: impl Into<Bool32>) -> Self {
        self.index_type_uint8 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceIndexTypeUint8FeaturesEXT<'a> = PhysicalDeviceIndexTypeUint8FeaturesKHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceLineRasterizationFeaturesKHR")]
pub struct PhysicalDeviceLineRasterizationFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub rectangular_lines: Bool32,
    pub bresenham_lines: Bool32,
    pub smooth_lines: Bool32,
    pub stippled_rectangular_lines: Bool32,
    pub stippled_bresenham_lines: Bool32,
    pub stippled_smooth_lines: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceLineRasterizationFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceLineRasterizationFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceLineRasterizationFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceLineRasterizationFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceLineRasterizationFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceLineRasterizationFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceLineRasterizationFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            rectangular_lines: Default::default(),
            bresenham_lines: Default::default(),
            smooth_lines: Default::default(),
            stippled_rectangular_lines: Default::default(),
            stippled_bresenham_lines: Default::default(),
            stippled_smooth_lines: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceLineRasterizationFeaturesKHR<'a> {
    #[inline]
    pub fn rectangular_lines(mut self, value: impl Into<Bool32>) -> Self {
        self.rectangular_lines = value.into();
        self
    }
    #[inline]
    pub fn bresenham_lines(mut self, value: impl Into<Bool32>) -> Self {
        self.bresenham_lines = value.into();
        self
    }
    #[inline]
    pub fn smooth_lines(mut self, value: impl Into<Bool32>) -> Self {
        self.smooth_lines = value.into();
        self
    }
    #[inline]
    pub fn stippled_rectangular_lines(mut self, value: impl Into<Bool32>) -> Self {
        self.stippled_rectangular_lines = value.into();
        self
    }
    #[inline]
    pub fn stippled_bresenham_lines(mut self, value: impl Into<Bool32>) -> Self {
        self.stippled_bresenham_lines = value.into();
        self
    }
    #[inline]
    pub fn stippled_smooth_lines(mut self, value: impl Into<Bool32>) -> Self {
        self.stippled_smooth_lines = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceLineRasterizationFeaturesEXT<'a> =
    PhysicalDeviceLineRasterizationFeaturesKHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLineRasterizationPropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceLineRasterizationPropertiesKHR")]
pub struct PhysicalDeviceLineRasterizationPropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub line_sub_pixel_precision_bits: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceLineRasterizationPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceLineRasterizationPropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceLineRasterizationPropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceLineRasterizationPropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceLineRasterizationPropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceLineRasterizationPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            line_sub_pixel_precision_bits: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceLineRasterizationPropertiesKHR<'a> {
    #[inline]
    pub fn line_sub_pixel_precision_bits(mut self, value: u32) -> Self {
        self.line_sub_pixel_precision_bits = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PhysicalDeviceLineRasterizationPropertiesEXT<'a> =
    PhysicalDeviceLineRasterizationPropertiesKHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationLineStateCreateInfoKHR.html>"]
#[doc(alias = "VkPipelineRasterizationLineStateCreateInfoKHR")]
pub struct PipelineRasterizationLineStateCreateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub line_rasterization_mode: LineRasterizationModeKHR,
    pub stippled_line_enable: Bool32,
    pub line_stipple_factor: u32,
    pub line_stipple_pattern: u16,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PipelineRasterizationLineStateCreateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PipelineRasterizationLineStateCreateInfoKHR;
}
unsafe impl<'a> Send for PipelineRasterizationLineStateCreateInfoKHR<'a> {}
unsafe impl<'a> Sync for PipelineRasterizationLineStateCreateInfoKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PipelineRasterizationStateCreateInfo<'b>>
    for PipelineRasterizationLineStateCreateInfoKHR<'a>
{
}
impl<'a> Default for PipelineRasterizationLineStateCreateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            line_rasterization_mode: LineRasterizationModeKHR::Default,
            stippled_line_enable: Default::default(),
            line_stipple_factor: Default::default(),
            line_stipple_pattern: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PipelineRasterizationLineStateCreateInfoKHR<'a> {
    #[inline]
    pub fn line_rasterization_mode(mut self, value: LineRasterizationModeKHR) -> Self {
        self.line_rasterization_mode = value;
        self
    }
    #[inline]
    pub fn stippled_line_enable(mut self, value: impl Into<Bool32>) -> Self {
        self.stippled_line_enable = value.into();
        self
    }
    #[inline]
    pub fn line_stipple_factor(mut self, value: u32) -> Self {
        self.line_stipple_factor = value;
        self
    }
    #[inline]
    pub fn line_stipple_pattern(mut self, value: u16) -> Self {
        self.line_stipple_pattern = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type PipelineRasterizationLineStateCreateInfoEXT<'a> =
    PipelineRasterizationLineStateCreateInfoKHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCalibratedTimestampInfoKHR.html>"]
#[doc(alias = "VkCalibratedTimestampInfoKHR")]
pub struct CalibratedTimestampInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub time_domain: TimeDomainKHR,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for CalibratedTimestampInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::CalibratedTimestampInfoKHR;
}
unsafe impl<'a> Send for CalibratedTimestampInfoKHR<'a> {}
unsafe impl<'a> Sync for CalibratedTimestampInfoKHR<'a> {}
impl<'a> Default for CalibratedTimestampInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            time_domain: TimeDomainKHR::Device,
            phantom: PhantomData,
        }
    }
}
impl<'a> CalibratedTimestampInfoKHR<'a> {
    #[inline]
    pub fn time_domain(mut self, value: TimeDomainKHR) -> Self {
        self.time_domain = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
pub type CalibratedTimestampInfoEXT<'a> = CalibratedTimestampInfoKHR<'a>;
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderExpectAssumeFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceShaderExpectAssumeFeaturesKHR")]
pub struct PhysicalDeviceShaderExpectAssumeFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_expect_assume: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderExpectAssumeFeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderExpectAssumeFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceShaderExpectAssumeFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderExpectAssumeFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderExpectAssumeFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderExpectAssumeFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderExpectAssumeFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_expect_assume: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderExpectAssumeFeaturesKHR<'a> {
    #[inline]
    pub fn shader_expect_assume(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_expect_assume = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance6FeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceMaintenance6FeaturesKHR")]
pub struct PhysicalDeviceMaintenance6FeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub maintenance6: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMaintenance6FeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMaintenance6FeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceMaintenance6FeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMaintenance6FeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMaintenance6FeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMaintenance6FeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceMaintenance6FeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            maintenance6: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMaintenance6FeaturesKHR<'a> {
    #[inline]
    pub fn maintenance6(mut self, value: impl Into<Bool32>) -> Self {
        self.maintenance6 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance6PropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceMaintenance6PropertiesKHR")]
pub struct PhysicalDeviceMaintenance6PropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub block_texel_view_compatible_multiple_layers: Bool32,
    pub max_combined_image_sampler_descriptor_count: u32,
    pub fragment_shading_rate_clamp_combiner_inputs: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMaintenance6PropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMaintenance6PropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceMaintenance6PropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMaintenance6PropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceMaintenance6PropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceMaintenance6PropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            block_texel_view_compatible_multiple_layers: Default::default(),
            max_combined_image_sampler_descriptor_count: Default::default(),
            fragment_shading_rate_clamp_combiner_inputs: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMaintenance6PropertiesKHR<'a> {
    #[inline]
    pub fn block_texel_view_compatible_multiple_layers(mut self, value: impl Into<Bool32>) -> Self {
        self.block_texel_view_compatible_multiple_layers = value.into();
        self
    }
    #[inline]
    pub fn max_combined_image_sampler_descriptor_count(mut self, value: u32) -> Self {
        self.max_combined_image_sampler_descriptor_count = value;
        self
    }
    #[inline]
    pub fn fragment_shading_rate_clamp_combiner_inputs(mut self, value: impl Into<Bool32>) -> Self {
        self.fragment_shading_rate_clamp_combiner_inputs = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindMemoryStatusKHR.html>"]
#[doc(alias = "VkBindMemoryStatusKHR")]
pub struct BindMemoryStatusKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub p_result: *const Status,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BindMemoryStatusKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BindMemoryStatusKHR;
}
unsafe impl<'a> Send for BindMemoryStatusKHR<'a> {}
unsafe impl<'a> Sync for BindMemoryStatusKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BindBufferMemoryInfo<'b>> for BindMemoryStatusKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<BindImageMemoryInfo<'b>> for BindMemoryStatusKHR<'a> {}
impl<'a> Default for BindMemoryStatusKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            p_result: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BindMemoryStatusKHR<'a> {
    #[inline]
    pub fn result(mut self, value: &'a Status) -> Self {
        self.p_result = ptr::from_ref(value);
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindDescriptorSetsInfoKHR.html>"]
#[doc(alias = "VkBindDescriptorSetsInfoKHR")]
pub struct BindDescriptorSetsInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub stage_flags: ShaderStageFlags,
    pub layout: Option<PipelineLayout>,
    pub first_set: u32,
    pub(crate) descriptor_set_count: u32,
    pub(crate) p_descriptor_sets: *const DescriptorSet,
    pub dynamic_offset_count: u32,
    pub(crate) p_dynamic_offsets: *const u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BindDescriptorSetsInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::BindDescriptorSetsInfoKHR;
}
unsafe impl<'a> Send for BindDescriptorSetsInfoKHR<'a> {}
unsafe impl<'a> Sync for BindDescriptorSetsInfoKHR<'a> {}
impl<'a> Default for BindDescriptorSetsInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stage_flags: Default::default(),
            layout: Default::default(),
            first_set: Default::default(),
            descriptor_set_count: Default::default(),
            p_descriptor_sets: ptr::null(),
            dynamic_offset_count: Default::default(),
            p_dynamic_offsets: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BindDescriptorSetsInfoKHR<'a> {
    #[inline]
    pub fn stage_flags(mut self, value: ShaderStageFlags) -> Self {
        self.stage_flags = value;
        self
    }
    #[inline]
    pub fn layout(mut self, value: Option<&'a PipelineLayout>) -> Self {
        self.layout = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn first_set(mut self, value: u32) -> Self {
        self.first_set = value;
        self
    }
    #[inline]
    pub fn dynamic_offset_count(mut self, value: u32) -> Self {
        self.dynamic_offset_count = value;
        self
    }
    #[inline]
    pub fn descriptor_sets<V0: Alias<raw::DescriptorSet> + 'a>(
        mut self,
        p_descriptor_sets: impl AsSlice<'a, V0>,
    ) -> Self {
        self.p_descriptor_sets = p_descriptor_sets.as_slice().as_ptr().cast();
        self.descriptor_set_count = p_descriptor_sets.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn dynamic_offsets(mut self, p_dynamic_offsets: impl AsSlice<'a, u32>) -> Self {
        self.p_dynamic_offsets = p_dynamic_offsets.as_slice().as_ptr().cast();
        self.dynamic_offset_count = p_dynamic_offsets.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPushConstantsInfoKHR.html>"]
#[doc(alias = "VkPushConstantsInfoKHR")]
pub struct PushConstantsInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub layout: Option<PipelineLayout>,
    pub stage_flags: ShaderStageFlags,
    pub offset: u32,
    pub(crate) size: u32,
    pub(crate) p_values: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PushConstantsInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PushConstantsInfoKHR;
}
unsafe impl<'a> Send for PushConstantsInfoKHR<'a> {}
unsafe impl<'a> Sync for PushConstantsInfoKHR<'a> {}
impl<'a> Default for PushConstantsInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            layout: Default::default(),
            stage_flags: Default::default(),
            offset: Default::default(),
            size: Default::default(),
            p_values: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PushConstantsInfoKHR<'a> {
    #[inline]
    pub fn layout(mut self, value: Option<&'a PipelineLayout>) -> Self {
        self.layout = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn stage_flags(mut self, value: ShaderStageFlags) -> Self {
        self.stage_flags = value;
        self
    }
    #[inline]
    pub fn offset(mut self, value: u32) -> Self {
        self.offset = value;
        self
    }
    #[inline]
    pub fn values(mut self, p_values: impl AsSlice<'a, u8>) -> Self {
        self.p_values = p_values.as_slice().as_ptr().cast();
        self.size = p_values.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPushDescriptorSetInfoKHR.html>"]
#[doc(alias = "VkPushDescriptorSetInfoKHR")]
pub struct PushDescriptorSetInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub stage_flags: ShaderStageFlags,
    pub layout: Option<PipelineLayout>,
    pub set: u32,
    pub(crate) descriptor_write_count: u32,
    pub(crate) p_descriptor_writes: *const WriteDescriptorSet<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PushDescriptorSetInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PushDescriptorSetInfoKHR;
}
unsafe impl<'a> Send for PushDescriptorSetInfoKHR<'a> {}
unsafe impl<'a> Sync for PushDescriptorSetInfoKHR<'a> {}
impl<'a> Default for PushDescriptorSetInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stage_flags: Default::default(),
            layout: Default::default(),
            set: Default::default(),
            descriptor_write_count: Default::default(),
            p_descriptor_writes: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PushDescriptorSetInfoKHR<'a> {
    #[inline]
    pub fn stage_flags(mut self, value: ShaderStageFlags) -> Self {
        self.stage_flags = value;
        self
    }
    #[inline]
    pub fn layout(mut self, value: Option<&'a PipelineLayout>) -> Self {
        self.layout = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn set(mut self, value: u32) -> Self {
        self.set = value;
        self
    }
    #[inline]
    pub fn descriptor_writes(
        mut self,
        p_descriptor_writes: impl AsSlice<'a, WriteDescriptorSet<'a>>,
    ) -> Self {
        self.p_descriptor_writes = p_descriptor_writes.as_slice().as_ptr().cast();
        self.descriptor_write_count = p_descriptor_writes.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPushDescriptorSetWithTemplateInfoKHR.html>"]
#[doc(alias = "VkPushDescriptorSetWithTemplateInfoKHR")]
pub struct PushDescriptorSetWithTemplateInfoKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub descriptor_update_template: Option<DescriptorUpdateTemplate>,
    pub layout: Option<PipelineLayout>,
    pub set: u32,
    pub p_data: VoidPtr,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PushDescriptorSetWithTemplateInfoKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PushDescriptorSetWithTemplateInfoKHR;
}
unsafe impl<'a> Send for PushDescriptorSetWithTemplateInfoKHR<'a> {}
unsafe impl<'a> Sync for PushDescriptorSetWithTemplateInfoKHR<'a> {}
impl<'a> Default for PushDescriptorSetWithTemplateInfoKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            descriptor_update_template: Default::default(),
            layout: Default::default(),
            set: Default::default(),
            p_data: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PushDescriptorSetWithTemplateInfoKHR<'a> {
    #[inline]
    pub fn descriptor_update_template(mut self, value: &'a DescriptorUpdateTemplate) -> Self {
        self.descriptor_update_template = Some(unsafe { value.clone() });
        self
    }
    #[inline]
    pub fn layout(mut self, value: Option<&'a PipelineLayout>) -> Self {
        self.layout = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn set(mut self, value: u32) -> Self {
        self.set = value;
        self
    }
    #[inline]
    pub fn data(mut self, value: VoidPtr) -> Self {
        self.p_data = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSetDescriptorBufferOffsetsInfoEXT.html>"]
#[doc(alias = "VkSetDescriptorBufferOffsetsInfoEXT")]
pub struct SetDescriptorBufferOffsetsInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub stage_flags: ShaderStageFlags,
    pub layout: Option<PipelineLayout>,
    pub first_set: u32,
    pub(crate) set_count: u32,
    pub(crate) p_buffer_indices: *const u32,
    pub(crate) p_offsets: *const DeviceSize,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for SetDescriptorBufferOffsetsInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::SetDescriptorBufferOffsetsInfoEXT;
}
unsafe impl<'a> Send for SetDescriptorBufferOffsetsInfoEXT<'a> {}
unsafe impl<'a> Sync for SetDescriptorBufferOffsetsInfoEXT<'a> {}
impl<'a> Default for SetDescriptorBufferOffsetsInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stage_flags: Default::default(),
            layout: Default::default(),
            first_set: Default::default(),
            set_count: Default::default(),
            p_buffer_indices: ptr::null(),
            p_offsets: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> SetDescriptorBufferOffsetsInfoEXT<'a> {
    #[inline]
    pub fn stage_flags(mut self, value: ShaderStageFlags) -> Self {
        self.stage_flags = value;
        self
    }
    #[inline]
    pub fn layout(mut self, value: Option<&'a PipelineLayout>) -> Self {
        self.layout = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn first_set(mut self, value: u32) -> Self {
        self.first_set = value;
        self
    }
    #[inline]
    pub fn set(
        mut self,
        p_buffer_indices: impl AsSlice<'a, u32>,
        p_offsets: impl AsSlice<'a, DeviceSize>,
    ) -> Self {
        self.p_buffer_indices = p_buffer_indices.as_slice().as_ptr().cast();
        self.p_offsets = p_offsets.as_slice().as_ptr().cast();
        self.set_count = p_buffer_indices.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindDescriptorBufferEmbeddedSamplersInfoEXT.html>"]
#[doc(alias = "VkBindDescriptorBufferEmbeddedSamplersInfoEXT")]
pub struct BindDescriptorBufferEmbeddedSamplersInfoEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub stage_flags: ShaderStageFlags,
    pub layout: Option<PipelineLayout>,
    pub set: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for BindDescriptorBufferEmbeddedSamplersInfoEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::BindDescriptorBufferEmbeddedSamplersInfoEXT;
}
unsafe impl<'a> Send for BindDescriptorBufferEmbeddedSamplersInfoEXT<'a> {}
unsafe impl<'a> Sync for BindDescriptorBufferEmbeddedSamplersInfoEXT<'a> {}
impl<'a> Default for BindDescriptorBufferEmbeddedSamplersInfoEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            stage_flags: Default::default(),
            layout: Default::default(),
            set: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> BindDescriptorBufferEmbeddedSamplersInfoEXT<'a> {
    #[inline]
    pub fn stage_flags(mut self, value: ShaderStageFlags) -> Self {
        self.stage_flags = value;
        self
    }
    #[inline]
    pub fn layout(mut self, value: Option<&'a PipelineLayout>) -> Self {
        self.layout = value.map(|v| unsafe { v.clone() });
        self
    }
    #[inline]
    pub fn set(mut self, value: u32) -> Self {
        self.set = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV")]
pub struct PhysicalDeviceDescriptorPoolOverallocationFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub descriptor_pool_overallocation: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceDescriptorPoolOverallocationFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceDescriptorPoolOverallocationFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceDescriptorPoolOverallocationFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceDescriptorPoolOverallocationFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceDescriptorPoolOverallocationFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceDescriptorPoolOverallocationFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceDescriptorPoolOverallocationFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            descriptor_pool_overallocation: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceDescriptorPoolOverallocationFeaturesNV<'a> {
    #[inline]
    pub fn descriptor_pool_overallocation(mut self, value: impl Into<Bool32>) -> Self {
        self.descriptor_pool_overallocation = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRawAccessChainsFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceRawAccessChainsFeaturesNV")]
pub struct PhysicalDeviceRawAccessChainsFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_raw_access_chains: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRawAccessChainsFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceRawAccessChainsFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceRawAccessChainsFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRawAccessChainsFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRawAccessChainsFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRawAccessChainsFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceRawAccessChainsFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_raw_access_chains: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRawAccessChainsFeaturesNV<'a> {
    #[inline]
    pub fn shader_raw_access_chains(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_raw_access_chains = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR")]
pub struct PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_relaxed_extended_instruction: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure
    for PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR<'a>
{
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_relaxed_extended_instruction: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR<'a> {
    #[inline]
    pub fn shader_relaxed_extended_instruction(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_relaxed_extended_instruction = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance7FeaturesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceMaintenance7FeaturesKHR")]
pub struct PhysicalDeviceMaintenance7FeaturesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub maintenance7: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMaintenance7FeaturesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMaintenance7FeaturesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceMaintenance7FeaturesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMaintenance7FeaturesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceMaintenance7FeaturesKHR<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceMaintenance7FeaturesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceMaintenance7FeaturesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            maintenance7: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMaintenance7FeaturesKHR<'a> {
    #[inline]
    pub fn maintenance7(mut self, value: impl Into<Bool32>) -> Self {
        self.maintenance7 = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance7PropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceMaintenance7PropertiesKHR")]
pub struct PhysicalDeviceMaintenance7PropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub robust_fragment_shading_rate_attachment_access: Bool32,
    pub separate_depth_stencil_attachment_access: Bool32,
    pub max_descriptor_set_total_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_total_storage_buffers_dynamic: u32,
    pub max_descriptor_set_total_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_total_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_total_storage_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_total_buffers_dynamic: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceMaintenance7PropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceMaintenance7PropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceMaintenance7PropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceMaintenance7PropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceMaintenance7PropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceMaintenance7PropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            robust_fragment_shading_rate_attachment_access: Default::default(),
            separate_depth_stencil_attachment_access: Default::default(),
            max_descriptor_set_total_uniform_buffers_dynamic: Default::default(),
            max_descriptor_set_total_storage_buffers_dynamic: Default::default(),
            max_descriptor_set_total_buffers_dynamic: Default::default(),
            max_descriptor_set_update_after_bind_total_uniform_buffers_dynamic: Default::default(),
            max_descriptor_set_update_after_bind_total_storage_buffers_dynamic: Default::default(),
            max_descriptor_set_update_after_bind_total_buffers_dynamic: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceMaintenance7PropertiesKHR<'a> {
    #[inline]
    pub fn robust_fragment_shading_rate_attachment_access(
        mut self,
        value: impl Into<Bool32>,
    ) -> Self {
        self.robust_fragment_shading_rate_attachment_access = value.into();
        self
    }
    #[inline]
    pub fn separate_depth_stencil_attachment_access(mut self, value: impl Into<Bool32>) -> Self {
        self.separate_depth_stencil_attachment_access = value.into();
        self
    }
    #[inline]
    pub fn max_descriptor_set_total_uniform_buffers_dynamic(mut self, value: u32) -> Self {
        self.max_descriptor_set_total_uniform_buffers_dynamic = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_total_storage_buffers_dynamic(mut self, value: u32) -> Self {
        self.max_descriptor_set_total_storage_buffers_dynamic = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_total_buffers_dynamic(mut self, value: u32) -> Self {
        self.max_descriptor_set_total_buffers_dynamic = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_total_uniform_buffers_dynamic(
        mut self,
        value: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_total_uniform_buffers_dynamic = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_total_storage_buffers_dynamic(
        mut self,
        value: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_total_storage_buffers_dynamic = value;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_total_buffers_dynamic(
        mut self,
        value: u32,
    ) -> Self {
        self.max_descriptor_set_update_after_bind_total_buffers_dynamic = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLayeredApiPropertiesListKHR.html>"]
#[doc(alias = "VkPhysicalDeviceLayeredApiPropertiesListKHR")]
pub struct PhysicalDeviceLayeredApiPropertiesListKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub layered_api_count: u32,
    pub(crate) p_layered_apis: *const PhysicalDeviceLayeredApiPropertiesKHR<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceLayeredApiPropertiesListKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceLayeredApiPropertiesListKHR;
}
unsafe impl<'a> Send for PhysicalDeviceLayeredApiPropertiesListKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceLayeredApiPropertiesListKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceLayeredApiPropertiesListKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceLayeredApiPropertiesListKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            layered_api_count: Default::default(),
            p_layered_apis: ptr::null(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceLayeredApiPropertiesListKHR<'a> {
    #[inline]
    pub fn layered_api_count(mut self, value: u32) -> Self {
        self.layered_api_count = value;
        self
    }
    #[inline]
    pub fn layered_apis(
        mut self,
        p_layered_apis: impl AsSlice<'a, PhysicalDeviceLayeredApiPropertiesKHR<'a>>,
    ) -> Self {
        self.p_layered_apis = p_layered_apis.as_slice().as_ptr().cast();
        self.layered_api_count = p_layered_apis.as_slice().len() as _;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLayeredApiPropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceLayeredApiPropertiesKHR")]
pub struct PhysicalDeviceLayeredApiPropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub vendor_id: u32,
    pub device_id: u32,
    pub layered_api: PhysicalDeviceLayeredApiKHR,
    pub device_name: [c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE as _],
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceLayeredApiPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::PhysicalDeviceLayeredApiPropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceLayeredApiPropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceLayeredApiPropertiesKHR<'a> {}
impl<'a> Default for PhysicalDeviceLayeredApiPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            vendor_id: Default::default(),
            device_id: Default::default(),
            layered_api: PhysicalDeviceLayeredApiKHR::Vulkan,
            device_name: array::from_fn(|_| Default::default()),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceLayeredApiPropertiesKHR<'a> {
    #[inline]
    pub fn vendor_id(mut self, value: u32) -> Self {
        self.vendor_id = value;
        self
    }
    #[inline]
    pub fn device_id(mut self, value: u32) -> Self {
        self.device_id = value;
        self
    }
    #[inline]
    pub fn layered_api(mut self, value: PhysicalDeviceLayeredApiKHR) -> Self {
        self.layered_api = value;
        self
    }
    #[inline]
    pub fn device_name(mut self, value: [c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE as _]) -> Self {
        self.device_name = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLayeredApiVulkanPropertiesKHR.html>"]
#[doc(alias = "VkPhysicalDeviceLayeredApiVulkanPropertiesKHR")]
pub struct PhysicalDeviceLayeredApiVulkanPropertiesKHR<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub properties: PhysicalDeviceProperties2<'a>,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceLayeredApiVulkanPropertiesKHR<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceLayeredApiVulkanPropertiesKHR;
}
unsafe impl<'a> Send for PhysicalDeviceLayeredApiVulkanPropertiesKHR<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceLayeredApiVulkanPropertiesKHR<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceLayeredApiPropertiesKHR<'b>>
    for PhysicalDeviceLayeredApiVulkanPropertiesKHR<'a>
{
}
impl<'a> Default for PhysicalDeviceLayeredApiVulkanPropertiesKHR<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            properties: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceLayeredApiVulkanPropertiesKHR<'a> {
    #[inline]
    pub fn properties(mut self, value: PhysicalDeviceProperties2<'a>) -> Self {
        self.properties = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV")]
pub struct PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_float16_vector_atomics: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_float16_vector_atomics: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV<'a> {
    #[inline]
    pub fn shader_float16_vector_atomics(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_float16_vector_atomics = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT.html>"]
#[doc(alias = "VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT")]
pub struct PhysicalDeviceShaderReplicatedCompositesFeaturesEXT<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub shader_replicated_composites: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceShaderReplicatedCompositesFeaturesEXT<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceShaderReplicatedCompositesFeaturesEXT;
}
unsafe impl<'a> Send for PhysicalDeviceShaderReplicatedCompositesFeaturesEXT<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceShaderReplicatedCompositesFeaturesEXT<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceShaderReplicatedCompositesFeaturesEXT<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceShaderReplicatedCompositesFeaturesEXT<'a>
{
}
impl<'a> Default for PhysicalDeviceShaderReplicatedCompositesFeaturesEXT<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            shader_replicated_composites: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceShaderReplicatedCompositesFeaturesEXT<'a> {
    #[inline]
    pub fn shader_replicated_composites(mut self, value: impl Into<Bool32>) -> Self {
        self.shader_replicated_composites = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingValidationFeaturesNV.html>"]
#[doc(alias = "VkPhysicalDeviceRayTracingValidationFeaturesNV")]
pub struct PhysicalDeviceRayTracingValidationFeaturesNV<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub ray_tracing_validation: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceRayTracingValidationFeaturesNV<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceRayTracingValidationFeaturesNV;
}
unsafe impl<'a> Send for PhysicalDeviceRayTracingValidationFeaturesNV<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceRayTracingValidationFeaturesNV<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceRayTracingValidationFeaturesNV<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceRayTracingValidationFeaturesNV<'a>
{
}
impl<'a> Default for PhysicalDeviceRayTracingValidationFeaturesNV<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            ray_tracing_validation: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceRayTracingValidationFeaturesNV<'a> {
    #[inline]
    pub fn ray_tracing_validation(mut self, value: impl Into<Bool32>) -> Self {
        self.ray_tracing_validation = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageAlignmentControlFeaturesMESA.html>"]
#[doc(alias = "VkPhysicalDeviceImageAlignmentControlFeaturesMESA")]
pub struct PhysicalDeviceImageAlignmentControlFeaturesMESA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub image_alignment_control: Bool32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageAlignmentControlFeaturesMESA<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceImageAlignmentControlFeaturesMESA;
}
unsafe impl<'a> Send for PhysicalDeviceImageAlignmentControlFeaturesMESA<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageAlignmentControlFeaturesMESA<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceFeatures2<'b>>
    for PhysicalDeviceImageAlignmentControlFeaturesMESA<'a>
{
}
unsafe impl<'a, 'b> ExtendingStructure<DeviceCreateInfo<'b>>
    for PhysicalDeviceImageAlignmentControlFeaturesMESA<'a>
{
}
impl<'a> Default for PhysicalDeviceImageAlignmentControlFeaturesMESA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            image_alignment_control: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageAlignmentControlFeaturesMESA<'a> {
    #[inline]
    pub fn image_alignment_control(mut self, value: impl Into<Bool32>) -> Self {
        self.image_alignment_control = value.into();
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageAlignmentControlPropertiesMESA.html>"]
#[doc(alias = "VkPhysicalDeviceImageAlignmentControlPropertiesMESA")]
pub struct PhysicalDeviceImageAlignmentControlPropertiesMESA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub supported_image_alignment_mask: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for PhysicalDeviceImageAlignmentControlPropertiesMESA<'a> {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PhysicalDeviceImageAlignmentControlPropertiesMESA;
}
unsafe impl<'a> Send for PhysicalDeviceImageAlignmentControlPropertiesMESA<'a> {}
unsafe impl<'a> Sync for PhysicalDeviceImageAlignmentControlPropertiesMESA<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<PhysicalDeviceProperties2<'b>>
    for PhysicalDeviceImageAlignmentControlPropertiesMESA<'a>
{
}
impl<'a> Default for PhysicalDeviceImageAlignmentControlPropertiesMESA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            supported_image_alignment_mask: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> PhysicalDeviceImageAlignmentControlPropertiesMESA<'a> {
    #[inline]
    pub fn supported_image_alignment_mask(mut self, value: u32) -> Self {
        self.supported_image_alignment_mask = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
#[repr(C)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageAlignmentControlCreateInfoMESA.html>"]
#[doc(alias = "VkImageAlignmentControlCreateInfoMESA")]
pub struct ImageAlignmentControlCreateInfoMESA<'a> {
    pub(crate) s_type: StructureType,
    pub(crate) p_next: Cell<*const Header>,
    pub maximum_requested_alignment: u32,
    phantom: PhantomData<&'a ()>,
}
unsafe impl<'a> ExtendableStructure for ImageAlignmentControlCreateInfoMESA<'a> {
    const STRUCTURE_TYPE: StructureType = StructureType::ImageAlignmentControlCreateInfoMESA;
}
unsafe impl<'a> Send for ImageAlignmentControlCreateInfoMESA<'a> {}
unsafe impl<'a> Sync for ImageAlignmentControlCreateInfoMESA<'a> {}
unsafe impl<'a, 'b> ExtendingStructure<ImageCreateInfo<'b>>
    for ImageAlignmentControlCreateInfoMESA<'a>
{
}
impl<'a> Default for ImageAlignmentControlCreateInfoMESA<'a> {
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: Cell::new(ptr::null()),
            maximum_requested_alignment: Default::default(),
            phantom: PhantomData,
        }
    }
}
impl<'a> ImageAlignmentControlCreateInfoMESA<'a> {
    #[inline]
    pub fn maximum_requested_alignment(mut self, value: u32) -> Self {
        self.maximum_requested_alignment = value;
        self
    }
    #[inline]
    pub fn push_next<T: ExtendingStructure<Self>>(self, ext: &'a mut T) -> Self {
        unsafe { self.push_next_unchecked(ext) };
        self
    }
}
